! function e(t, i, r) {
    function n(a, s) {
        if (!i[a]) {
            if (!t[a]) {
                var l = "function" == typeof require && require;
                if (!s && l) return l(a, !0);
                if (o) return o(a, !0);
                var c = new Error("Cannot find module '" + a + "'");
                throw c.code = "MODULE_NOT_FOUND", c
            }
            var h = i[a] = {
                exports: {}
            };
            t[a][0].call(h.exports, function(e) {
                var i = t[a][1][e];
                return n(i ? i : e)
            }, h, h.exports, e, t, i, r)
        }
        return i[a].exports
    }
    for (var o = "function" == typeof require && require, a = 0; a < r.length; a++) n(r[a]);
    return n
}({
    1: [function(e, t, i) {
        (function(e) {
            var i = "undefined" != typeof t && t.exports && "undefined" != typeof e ? e : this || window;
            (i._gsQueue || (i._gsQueue = [])).push(function() {
                    "use strict";
                    i._gsDefine("TweenMax", ["core.Animation", "core.SimpleTimeline", "TweenLite"], function(e, t, i) {
                            var r = function(e) {
                                    var t, i = [],
                                        r = e.length;
                                    for (t = 0; t !== r; i.push(e[t++]));
                                    return i
                                },
                                n = function(e, t, i) {
                                    var r, n, o = e.cycle;
                                    for (r in o) n = o[r], e[r] = "function" == typeof n ? n.call(t[i], i) : n[i % n.length];
                                    delete e.cycle
                                },
                                o = function(e, t, r) {
                                    i.call(this, e, t, r), this._cycle = 0, this._yoyo = this.vars.yoyo === !0, this._repeat = this.vars.repeat || 0, this._repeatDelay = this.vars.repeatDelay || 0, this._dirty = !0, this.render = o.prototype.render
                                },
                                a = 1e-10,
                                s = i._internals,
                                l = s.isSelector,
                                c = s.isArray,
                                h = o.prototype = i.to({}, .1, {}),
                                u = [];
                            o.version = "1.18.2", h.constructor = o, h.kill()._gc = !1, o.killTweensOf = o.killDelayedCallsTo = i.killTweensOf, o.getTweensOf = i.getTweensOf, o.lagSmoothing = i.lagSmoothing, o.ticker = i.ticker, o.render = i.render, h.invalidate = function() {
                                return this._yoyo = this.vars.yoyo === !0, this._repeat = this.vars.repeat || 0, this._repeatDelay = this.vars.repeatDelay || 0, this._uncache(!0), i.prototype.invalidate.call(this)
                            }, h.updateTo = function(e, t) {
                                var r, n = this.ratio,
                                    o = this.vars.immediateRender || e.immediateRender;
                                t && this._startTime < this._timeline._time && (this._startTime = this._timeline._time, this._uncache(!1), this._gc ? this._enabled(!0, !1) : this._timeline.insert(this, this._startTime - this._delay));
                                for (r in e) this.vars[r] = e[r];
                                if (this._initted || o)
                                    if (t) this._initted = !1, o && this.render(0, !0, !0);
                                    else if (this._gc && this._enabled(!0, !1), this._notifyPluginsOfEnabled && this._firstPT && i._onPluginEvent("_onDisable", this), this._time / this._duration > .998) {
                                    var a = this._totalTime;
                                    this.render(0, !0, !1), this._initted = !1, this.render(a, !0, !1)
                                } else if (this._initted = !1, this._init(), this._time > 0 || o)
                                    for (var s, l = 1 / (1 - n), c = this._firstPT; c;) s = c.s + c.c, c.c *= l, c.s = s - c.c, c = c._next;
                                return this
                            }, h.render = function(e, t, i) {
                                this._initted || 0 === this._duration && this.vars.repeat && this.invalidate();
                                var r, n, o, l, c, h, u, p, f = this._dirty ? this.totalDuration() : this._totalDuration,
                                    d = this._time,
                                    m = this._totalTime,
                                    g = this._cycle,
                                    v = this._duration,
                                    y = this._rawPrevTime;
                                if (e >= f - 1e-7 ? (this._totalTime = f, this._cycle = this._repeat, this._yoyo && 0 !== (1 & this._cycle) ? (this._time = 0, this.ratio = this._ease._calcEnd ? this._ease.getRatio(0) : 0) : (this._time = v, this.ratio = this._ease._calcEnd ? this._ease.getRatio(1) : 1), this._reversed || (r = !0, n = "onComplete", i = i || this._timeline.autoRemoveChildren), 0 === v && (this._initted || !this.vars.lazy || i) && (this._startTime === this._timeline._duration && (e = 0), (0 > y || 0 >= e && e >= -1e-7 || y === a && "isPause" !== this.data) && y !== e && (i = !0, y > a && (n = "onReverseComplete")), this._rawPrevTime = p = !t || e || y === e ? e : a)) : 1e-7 > e ? (this._totalTime = this._time = this._cycle = 0, this.ratio = this._ease._calcEnd ? this._ease.getRatio(0) : 0, (0 !== m || 0 === v && y > 0) && (n = "onReverseComplete", r = this._reversed), 0 > e && (this._active = !1, 0 === v && (this._initted || !this.vars.lazy || i) && (y >= 0 && (i = !0), this._rawPrevTime = p = !t || e || y === e ? e : a)), this._initted || (i = !0)) : (this._totalTime = this._time = e, 0 !== this._repeat && (l = v + this._repeatDelay, this._cycle = this._totalTime / l >> 0, 0 !== this._cycle && this._cycle === this._totalTime / l && this._cycle--, this._time = this._totalTime - this._cycle * l, this._yoyo && 0 !== (1 & this._cycle) && (this._time = v - this._time), this._time > v ? this._time = v : this._time < 0 && (this._time = 0)), this._easeType ? (c = this._time / v, h = this._easeType, u = this._easePower, (1 === h || 3 === h && c >= .5) && (c = 1 - c), 3 === h && (c *= 2), 1 === u ? c *= c : 2 === u ? c *= c * c : 3 === u ? c *= c * c * c : 4 === u && (c *= c * c * c * c), 1 === h ? this.ratio = 1 - c : 2 === h ? this.ratio = c : this._time / v < .5 ? this.ratio = c / 2 : this.ratio = 1 - c / 2) : this.ratio = this._ease.getRatio(this._time / v)), d === this._time && !i && g === this._cycle) return void(m !== this._totalTime && this._onUpdate && (t || this._callback("onUpdate")));
                                if (!this._initted) {
                                    if (this._init(), !this._initted || this._gc) return;
                                    if (!i && this._firstPT && (this.vars.lazy !== !1 && this._duration || this.vars.lazy && !this._duration)) return this._time = d, this._totalTime = m, this._rawPrevTime = y, this._cycle = g, s.lazyTweens.push(this), void(this._lazy = [e, t]);
                                    this._time && !r ? this.ratio = this._ease.getRatio(this._time / v) : r && this._ease._calcEnd && (this.ratio = this._ease.getRatio(0 === this._time ? 0 : 1))
                                }
                                for (this._lazy !== !1 && (this._lazy = !1), this._active || !this._paused && this._time !== d && e >= 0 && (this._active = !0), 0 === m && (2 === this._initted && e > 0 && this._init(), this._startAt && (e >= 0 ? this._startAt.render(e, t, i) : n || (n = "_dummyGS")), this.vars.onStart && (0 === this._totalTime && 0 !== v || t || this._callback("onStart"))), o = this._firstPT; o;) o.f ? o.t[o.p](o.c * this.ratio + o.s) : o.t[o.p] = o.c * this.ratio + o.s, o = o._next;
                                this._onUpdate && (0 > e && this._startAt && this._startTime && this._startAt.render(e, t, i), t || (this._totalTime !== m || r) && this._callback("onUpdate")), this._cycle !== g && (t || this._gc || this.vars.onRepeat && this._callback("onRepeat")), n && (this._gc && !i || (0 > e && this._startAt && !this._onUpdate && this._startTime && this._startAt.render(e, t, i), r && (this._timeline.autoRemoveChildren && this._enabled(!1, !1), this._active = !1), !t && this.vars[n] && this._callback(n), 0 === v && this._rawPrevTime === a && p !== a && (this._rawPrevTime = 0)))
                            }, o.to = function(e, t, i) {
                                return new o(e, t, i)
                            }, o.from = function(e, t, i) {
                                return i.runBackwards = !0, i.immediateRender = 0 != i.immediateRender, new o(e, t, i)
                            }, o.fromTo = function(e, t, i, r) {
                                return r.startAt = i, r.immediateRender = 0 != r.immediateRender && 0 != i.immediateRender, new o(e, t, r)
                            }, o.staggerTo = o.allTo = function(e, t, a, s, h, p, f) {
                                s = s || 0;
                                var d, m, g, v, y = 0,
                                    _ = [],
                                    x = function() {
                                        a.onComplete && a.onComplete.apply(a.onCompleteScope || this, arguments), h.apply(f || a.callbackScope || this, p || u)
                                    },
                                    b = a.cycle,
                                    w = a.startAt && a.startAt.cycle;
                                for (c(e) || ("string" == typeof e && (e = i.selector(e) || e), l(e) && (e = r(e))), e = e || [], 0 > s && (e = r(e), e.reverse(), s *= -1), d = e.length - 1, g = 0; d >= g; g++) {
                                    m = {};
                                    for (v in a) m[v] = a[v];
                                    if (b && n(m, e, g), w) {
                                        w = m.startAt = {};
                                        for (v in a.startAt) w[v] = a.startAt[v];
                                        n(m.startAt, e, g)
                                    }
                                    m.delay = y + (m.delay || 0), g === d && h && (m.onComplete = x), _[g] = new o(e[g], t, m), y += s
                                }
                                return _
                            }, o.staggerFrom = o.allFrom = function(e, t, i, r, n, a, s) {
                                return i.runBackwards = !0, i.immediateRender = 0 != i.immediateRender, o.staggerTo(e, t, i, r, n, a, s)
                            }, o.staggerFromTo = o.allFromTo = function(e, t, i, r, n, a, s, l) {
                                return r.startAt = i, r.immediateRender = 0 != r.immediateRender && 0 != i.immediateRender, o.staggerTo(e, t, r, n, a, s, l)
                            }, o.delayedCall = function(e, t, i, r, n) {
                                return new o(t, 0, {
                                    delay: e,
                                    onComplete: t,
                                    onCompleteParams: i,
                                    callbackScope: r,
                                    onReverseComplete: t,
                                    onReverseCompleteParams: i,
                                    immediateRender: !1,
                                    useFrames: n,
                                    overwrite: 0
                                })
                            }, o.set = function(e, t) {
                                return new o(e, 0, t)
                            }, o.isTweening = function(e) {
                                return i.getTweensOf(e, !0).length > 0
                            };
                            var p = function(e, t) {
                                    for (var r = [], n = 0, o = e._first; o;) o instanceof i ? r[n++] = o : (t && (r[n++] = o), r = r.concat(p(o, t)), n = r.length), o = o._next;
                                    return r
                                },
                                f = o.getAllTweens = function(t) {
                                    return p(e._rootTimeline, t).concat(p(e._rootFramesTimeline, t))
                                };
                            o.killAll = function(e, i, r, n) {
                                null == i && (i = !0), null == r && (r = !0);
                                var o, a, s, l = f(0 != n),
                                    c = l.length,
                                    h = i && r && n;
                                for (s = 0; c > s; s++) a = l[s], (h || a instanceof t || (o = a.target === a.vars.onComplete) && r || i && !o) && (e ? a.totalTime(a._reversed ? 0 : a.totalDuration()) : a._enabled(!1, !1))
                            }, o.killChildTweensOf = function(e, t) {
                                if (null != e) {
                                    var n, a, h, u, p, f = s.tweenLookup;
                                    if ("string" == typeof e && (e = i.selector(e) || e), l(e) && (e = r(e)), c(e))
                                        for (u = e.length; --u > -1;) o.killChildTweensOf(e[u], t);
                                    else {
                                        n = [];
                                        for (h in f)
                                            for (a = f[h].target.parentNode; a;) a === e && (n = n.concat(f[h].tweens)), a = a.parentNode;
                                        for (p = n.length, u = 0; p > u; u++) t && n[u].totalTime(n[u].totalDuration()), n[u]._enabled(!1, !1)
                                    }
                                }
                            };
                            var d = function(e, i, r, n) {
                                i = i !== !1, r = r !== !1, n = n !== !1;
                                for (var o, a, s = f(n), l = i && r && n, c = s.length; --c > -1;) a = s[c], (l || a instanceof t || (o = a.target === a.vars.onComplete) && r || i && !o) && a.paused(e)
                            };
                            return o.pauseAll = function(e, t, i) {
                                d(!0, e, t, i)
                            }, o.resumeAll = function(e, t, i) {
                                d(!1, e, t, i)
                            }, o.globalTimeScale = function(t) {
                                var r = e._rootTimeline,
                                    n = i.ticker.time;
                                return arguments.length ? (t = t || a, r._startTime = n - (n - r._startTime) * r._timeScale / t, r = e._rootFramesTimeline, n = i.ticker.frame, r._startTime = n - (n - r._startTime) * r._timeScale / t, r._timeScale = e._rootTimeline._timeScale = t, t) : r._timeScale
                            }, h.progress = function(e) {
                                return arguments.length ? this.totalTime(this.duration() * (this._yoyo && 0 !== (1 & this._cycle) ? 1 - e : e) + this._cycle * (this._duration + this._repeatDelay), !1) : this._time / this.duration()
                            }, h.totalProgress = function(e) {
                                return arguments.length ? this.totalTime(this.totalDuration() * e, !1) : this._totalTime / this.totalDuration()
                            }, h.time = function(e, t) {
                                return arguments.length ? (this._dirty && this.totalDuration(), e > this._duration && (e = this._duration), this._yoyo && 0 !== (1 & this._cycle) ? e = this._duration - e + this._cycle * (this._duration + this._repeatDelay) : 0 !== this._repeat && (e += this._cycle * (this._duration + this._repeatDelay)), this.totalTime(e, t)) : this._time
                            }, h.duration = function(t) {
                                return arguments.length ? e.prototype.duration.call(this, t) : this._duration
                            }, h.totalDuration = function(e) {
                                return arguments.length ? -1 === this._repeat ? this : this.duration((e - this._repeat * this._repeatDelay) / (this._repeat + 1)) : (this._dirty && (this._totalDuration = -1 === this._repeat ? 999999999999 : this._duration * (this._repeat + 1) + this._repeatDelay * this._repeat, this._dirty = !1), this._totalDuration)
                            }, h.repeat = function(e) {
                                return arguments.length ? (this._repeat = e, this._uncache(!0)) : this._repeat
                            }, h.repeatDelay = function(e) {
                                return arguments.length ? (this._repeatDelay = e, this._uncache(!0)) : this._repeatDelay
                            }, h.yoyo = function(e) {
                                return arguments.length ? (this._yoyo = e, this) : this._yoyo
                            }, o
                        }, !0), i._gsDefine("TimelineLite", ["core.Animation", "core.SimpleTimeline", "TweenLite"], function(e, t, r) {
                            var n = function(e) {
                                    t.call(this, e), this._labels = {}, this.autoRemoveChildren = this.vars.autoRemoveChildren === !0, this.smoothChildTiming = this.vars.smoothChildTiming === !0, this._sortChildren = !0, this._onUpdate = this.vars.onUpdate;
                                    var i, r, n = this.vars;
                                    for (r in n) i = n[r], c(i) && -1 !== i.join("").indexOf("{self}") && (n[r] = this._swapSelfInParams(i));
                                    c(n.tweens) && this.add(n.tweens, 0, n.align, n.stagger)
                                },
                                o = 1e-10,
                                a = r._internals,
                                s = n._internals = {},
                                l = a.isSelector,
                                c = a.isArray,
                                h = a.lazyTweens,
                                u = a.lazyRender,
                                p = i._gsDefine.globals,
                                f = function(e) {
                                    var t, i = {};
                                    for (t in e) i[t] = e[t];
                                    return i
                                },
                                d = function(e, t, i) {
                                    var r, n, o = e.cycle;
                                    for (r in o) n = o[r], e[r] = "function" == typeof n ? n.call(t[i], i) : n[i % n.length];
                                    delete e.cycle
                                },
                                m = s.pauseCallback = function() {},
                                g = function(e) {
                                    var t, i = [],
                                        r = e.length;
                                    for (t = 0; t !== r; i.push(e[t++]));
                                    return i
                                },
                                v = n.prototype = new t;
                            return n.version = "1.18.2", v.constructor = n, v.kill()._gc = v._forcingPlayhead = v._hasPause = !1, v.to = function(e, t, i, n) {
                                var o = i.repeat && p.TweenMax || r;
                                return t ? this.add(new o(e, t, i), n) : this.set(e, i, n)
                            }, v.from = function(e, t, i, n) {
                                return this.add((i.repeat && p.TweenMax || r).from(e, t, i), n)
                            }, v.fromTo = function(e, t, i, n, o) {
                                var a = n.repeat && p.TweenMax || r;
                                return t ? this.add(a.fromTo(e, t, i, n), o) : this.set(e, n, o)
                            }, v.staggerTo = function(e, t, i, o, a, s, c, h) {
                                var u, p, m = new n({
                                        onComplete: s,
                                        onCompleteParams: c,
                                        callbackScope: h,
                                        smoothChildTiming: this.smoothChildTiming
                                    }),
                                    v = i.cycle;
                                for ("string" == typeof e && (e = r.selector(e) || e), e = e || [], l(e) && (e = g(e)), o = o || 0, 0 > o && (e = g(e), e.reverse(), o *= -1), p = 0; p < e.length; p++) u = f(i), u.startAt && (u.startAt = f(u.startAt), u.startAt.cycle && d(u.startAt, e, p)), v && d(u, e, p), m.to(e[p], t, u, p * o);
                                return this.add(m, a)
                            }, v.staggerFrom = function(e, t, i, r, n, o, a, s) {
                                return i.immediateRender = 0 != i.immediateRender, i.runBackwards = !0, this.staggerTo(e, t, i, r, n, o, a, s)
                            }, v.staggerFromTo = function(e, t, i, r, n, o, a, s, l) {
                                return r.startAt = i, r.immediateRender = 0 != r.immediateRender && 0 != i.immediateRender, this.staggerTo(e, t, r, n, o, a, s, l)
                            }, v.call = function(e, t, i, n) {
                                return this.add(r.delayedCall(0, e, t, i), n)
                            }, v.set = function(e, t, i) {
                                return i = this._parseTimeOrLabel(i, 0, !0), null == t.immediateRender && (t.immediateRender = i === this._time && !this._paused), this.add(new r(e, 0, t), i)
                            }, n.exportRoot = function(e, t) {
                                e = e || {}, null == e.smoothChildTiming && (e.smoothChildTiming = !0);
                                var i, o, a = new n(e),
                                    s = a._timeline;
                                for (null == t && (t = !0), s._remove(a, !0), a._startTime = 0, a._rawPrevTime = a._time = a._totalTime = s._time, i = s._first; i;) o = i._next, t && i instanceof r && i.target === i.vars.onComplete || a.add(i, i._startTime - i._delay), i = o;
                                return s.add(a, 0), a
                            }, v.add = function(i, o, a, s) {
                                var l, h, u, p, f, d;
                                if ("number" != typeof o && (o = this._parseTimeOrLabel(o, 0, !0, i)), !(i instanceof e)) {
                                    if (i instanceof Array || i && i.push && c(i)) {
                                        for (a = a || "normal", s = s || 0, l = o, h = i.length, u = 0; h > u; u++) c(p = i[u]) && (p = new n({
                                            tweens: p
                                        })), this.add(p, l), "string" != typeof p && "function" != typeof p && ("sequence" === a ? l = p._startTime + p.totalDuration() / p._timeScale : "start" === a && (p._startTime -= p.delay())), l += s;
                                        return this._uncache(!0)
                                    }
                                    if ("string" == typeof i) return this.addLabel(i, o);
                                    if ("function" != typeof i) throw "Cannot add " + i + " into the timeline; it is not a tween, timeline, function, or string.";
                                    i = r.delayedCall(0, i)
                                }
                                if (t.prototype.add.call(this, i, o), (this._gc || this._time === this._duration) && !this._paused && this._duration < this.duration())
                                    for (f = this, d = f.rawTime() > i._startTime; f._timeline;) d && f._timeline.smoothChildTiming ? f.totalTime(f._totalTime, !0) : f._gc && f._enabled(!0, !1), f = f._timeline;
                                return this
                            }, v.remove = function(t) {
                                if (t instanceof e) {
                                    this._remove(t, !1);
                                    var i = t._timeline = t.vars.useFrames ? e._rootFramesTimeline : e._rootTimeline;
                                    return t._startTime = (t._paused ? t._pauseTime : i._time) - (t._reversed ? t.totalDuration() - t._totalTime : t._totalTime) / t._timeScale, this
                                }
                                if (t instanceof Array || t && t.push && c(t)) {
                                    for (var r = t.length; --r > -1;) this.remove(t[r]);
                                    return this
                                }
                                return "string" == typeof t ? this.removeLabel(t) : this.kill(null, t)
                            }, v._remove = function(e, i) {
                                t.prototype._remove.call(this, e, i);
                                var r = this._last;
                                return r ? this._time > r._startTime + r._totalDuration / r._timeScale && (this._time = this.duration(), this._totalTime = this._totalDuration) : this._time = this._totalTime = this._duration = this._totalDuration = 0, this
                            }, v.append = function(e, t) {
                                return this.add(e, this._parseTimeOrLabel(null, t, !0, e))
                            }, v.insert = v.insertMultiple = function(e, t, i, r) {
                                return this.add(e, t || 0, i, r)
                            }, v.appendMultiple = function(e, t, i, r) {
                                return this.add(e, this._parseTimeOrLabel(null, t, !0, e), i, r)
                            }, v.addLabel = function(e, t) {
                                return this._labels[e] = this._parseTimeOrLabel(t), this
                            }, v.addPause = function(e, t, i, n) {
                                var o = r.delayedCall(0, m, i, n || this);
                                return o.vars.onComplete = o.vars.onReverseComplete = t, o.data = "isPause", this._hasPause = !0, this.add(o, e)
                            }, v.removeLabel = function(e) {
                                return delete this._labels[e], this
                            }, v.getLabelTime = function(e) {
                                return null != this._labels[e] ? this._labels[e] : -1
                            }, v._parseTimeOrLabel = function(t, i, r, n) {
                                var o;
                                if (n instanceof e && n.timeline === this) this.remove(n);
                                else if (n && (n instanceof Array || n.push && c(n)))
                                    for (o = n.length; --o > -1;) n[o] instanceof e && n[o].timeline === this && this.remove(n[o]);
                                if ("string" == typeof i) return this._parseTimeOrLabel(i, r && "number" == typeof t && null == this._labels[i] ? t - this.duration() : 0, r);
                                if (i = i || 0, "string" != typeof t || !isNaN(t) && null == this._labels[t]) null == t && (t = this.duration());
                                else {
                                    if (o = t.indexOf("="), -1 === o) return null == this._labels[t] ? r ? this._labels[t] = this.duration() + i : i : this._labels[t] + i;
                                    i = parseInt(t.charAt(o - 1) + "1", 10) * Number(t.substr(o + 1)), t = o > 1 ? this._parseTimeOrLabel(t.substr(0, o - 1), 0, r) : this.duration()
                                }
                                return Number(t) + i
                            }, v.seek = function(e, t) {
                                return this.totalTime("number" == typeof e ? e : this._parseTimeOrLabel(e), t !== !1)
                            }, v.stop = function() {
                                return this.paused(!0)
                            }, v.gotoAndPlay = function(e, t) {
                                return this.play(e, t)
                            }, v.gotoAndStop = function(e, t) {
                                return this.pause(e, t)
                            }, v.render = function(e, t, i) {
                                this._gc && this._enabled(!0, !1);
                                var r, n, a, s, l, c, p, f = this._dirty ? this.totalDuration() : this._totalDuration,
                                    d = this._time,
                                    m = this._startTime,
                                    g = this._timeScale,
                                    v = this._paused;
                                if (e >= f - 1e-7) this._totalTime = this._time = f, this._reversed || this._hasPausedChild() || (n = !0, s = "onComplete", l = !!this._timeline.autoRemoveChildren, 0 === this._duration && (0 >= e && e >= -1e-7 || this._rawPrevTime < 0 || this._rawPrevTime === o) && this._rawPrevTime !== e && this._first && (l = !0, this._rawPrevTime > o && (s = "onReverseComplete"))), this._rawPrevTime = this._duration || !t || e || this._rawPrevTime === e ? e : o, e = f + 1e-4;
                                else if (1e-7 > e)
                                    if (this._totalTime = this._time = 0, (0 !== d || 0 === this._duration && this._rawPrevTime !== o && (this._rawPrevTime > 0 || 0 > e && this._rawPrevTime >= 0)) && (s = "onReverseComplete", n = this._reversed), 0 > e) this._active = !1, this._timeline.autoRemoveChildren && this._reversed ? (l = n = !0, s = "onReverseComplete") : this._rawPrevTime >= 0 && this._first && (l = !0), this._rawPrevTime = e;
                                    else {
                                        if (this._rawPrevTime = this._duration || !t || e || this._rawPrevTime === e ? e : o, 0 === e && n)
                                            for (r = this._first; r && 0 === r._startTime;) r._duration || (n = !1), r = r._next;
                                        e = 0, this._initted || (l = !0)
                                    } else {
                                    if (this._hasPause && !this._forcingPlayhead && !t) {
                                        if (e >= d)
                                            for (r = this._first; r && r._startTime <= e && !c;) r._duration || "isPause" !== r.data || r.ratio || 0 === r._startTime && 0 === this._rawPrevTime || (c = r), r = r._next;
                                        else
                                            for (r = this._last; r && r._startTime >= e && !c;) r._duration || "isPause" === r.data && r._rawPrevTime > 0 && (c = r), r = r._prev;
                                        c && (this._time = e = c._startTime, this._totalTime = e + this._cycle * (this._totalDuration + this._repeatDelay))
                                    }
                                    this._totalTime = this._time = this._rawPrevTime = e
                                }
                                if (this._time !== d && this._first || i || l || c) {
                                    if (this._initted || (this._initted = !0), this._active || !this._paused && this._time !== d && e > 0 && (this._active = !0), 0 === d && this.vars.onStart && 0 !== this._time && (t || this._callback("onStart")), p = this._time, p >= d)
                                        for (r = this._first; r && (a = r._next, p === this._time && (!this._paused || v));)(r._active || r._startTime <= p && !r._paused && !r._gc) && (c === r && this.pause(), r._reversed ? r.render((r._dirty ? r.totalDuration() : r._totalDuration) - (e - r._startTime) * r._timeScale, t, i) : r.render((e - r._startTime) * r._timeScale, t, i)), r = a;
                                    else
                                        for (r = this._last; r && (a = r._prev, p === this._time && (!this._paused || v));) {
                                            if (r._active || r._startTime <= d && !r._paused && !r._gc) {
                                                if (c === r) {
                                                    for (c = r._prev; c && c.endTime() > this._time;) c.render(c._reversed ? c.totalDuration() - (e - c._startTime) * c._timeScale : (e - c._startTime) * c._timeScale, t, i), c = c._prev;
                                                    c = null, this.pause()
                                                }
                                                r._reversed ? r.render((r._dirty ? r.totalDuration() : r._totalDuration) - (e - r._startTime) * r._timeScale, t, i) : r.render((e - r._startTime) * r._timeScale, t, i)
                                            }
                                            r = a
                                        }
                                    this._onUpdate && (t || (h.length && u(), this._callback("onUpdate"))), s && (this._gc || m !== this._startTime && g === this._timeScale || (0 === this._time || f >= this.totalDuration()) && (n && (h.length && u(), this._timeline.autoRemoveChildren && this._enabled(!1, !1), this._active = !1), !t && this.vars[s] && this._callback(s)))
                                }
                            }, v._hasPausedChild = function() {
                                for (var e = this._first; e;) {
                                    if (e._paused || e instanceof n && e._hasPausedChild()) return !0;
                                    e = e._next
                                }
                                return !1
                            }, v.getChildren = function(e, t, i, n) {
                                n = n || -9999999999;
                                for (var o = [], a = this._first, s = 0; a;) a._startTime < n || (a instanceof r ? t !== !1 && (o[s++] = a) : (i !== !1 && (o[s++] = a), e !== !1 && (o = o.concat(a.getChildren(!0, t, i)), s = o.length))), a = a._next;
                                return o
                            }, v.getTweensOf = function(e, t) {
                                var i, n, o = this._gc,
                                    a = [],
                                    s = 0;
                                for (o && this._enabled(!0, !0), i = r.getTweensOf(e), n = i.length; --n > -1;)(i[n].timeline === this || t && this._contains(i[n])) && (a[s++] = i[n]);
                                return o && this._enabled(!1, !0), a
                            }, v.recent = function() {
                                return this._recent
                            }, v._contains = function(e) {
                                for (var t = e.timeline; t;) {
                                    if (t === this) return !0;
                                    t = t.timeline
                                }
                                return !1
                            }, v.shiftChildren = function(e, t, i) {
                                i = i || 0;
                                for (var r, n = this._first, o = this._labels; n;) n._startTime >= i && (n._startTime += e), n = n._next;
                                if (t)
                                    for (r in o) o[r] >= i && (o[r] += e);
                                return this._uncache(!0)
                            }, v._kill = function(e, t) {
                                if (!e && !t) return this._enabled(!1, !1);
                                for (var i = t ? this.getTweensOf(t) : this.getChildren(!0, !0, !1), r = i.length, n = !1; --r > -1;) i[r]._kill(e, t) && (n = !0);
                                return n
                            }, v.clear = function(e) {
                                var t = this.getChildren(!1, !0, !0),
                                    i = t.length;
                                for (this._time = this._totalTime = 0; --i > -1;) t[i]._enabled(!1, !1);
                                return e !== !1 && (this._labels = {}), this._uncache(!0)
                            }, v.invalidate = function() {
                                for (var t = this._first; t;) t.invalidate(), t = t._next;
                                return e.prototype.invalidate.call(this)
                            }, v._enabled = function(e, i) {
                                if (e === this._gc)
                                    for (var r = this._first; r;) r._enabled(e, !0), r = r._next;
                                return t.prototype._enabled.call(this, e, i)
                            }, v.totalTime = function(t, i, r) {
                                this._forcingPlayhead = !0;
                                var n = e.prototype.totalTime.apply(this, arguments);
                                return this._forcingPlayhead = !1, n
                            }, v.duration = function(e) {
                                return arguments.length ? (0 !== this.duration() && 0 !== e && this.timeScale(this._duration / e), this) : (this._dirty && this.totalDuration(), this._duration)
                            }, v.totalDuration = function(e) {
                                if (!arguments.length) {
                                    if (this._dirty) {
                                        for (var t, i, r = 0, n = this._last, o = 999999999999; n;) t = n._prev, n._dirty && n.totalDuration(), n._startTime > o && this._sortChildren && !n._paused ? this.add(n, n._startTime - n._delay) : o = n._startTime, n._startTime < 0 && !n._paused && (r -= n._startTime, this._timeline.smoothChildTiming && (this._startTime += n._startTime / this._timeScale), this.shiftChildren(-n._startTime, !1, -9999999999), o = 0), i = n._startTime + n._totalDuration / n._timeScale, i > r && (r = i), n = t;
                                        this._duration = this._totalDuration = r, this._dirty = !1
                                    }
                                    return this._totalDuration
                                }
                                return e && this.totalDuration() ? this.timeScale(this._totalDuration / e) : this
                            }, v.paused = function(t) {
                                if (!t)
                                    for (var i = this._first, r = this._time; i;) i._startTime === r && "isPause" === i.data && (i._rawPrevTime = 0), i = i._next;
                                return e.prototype.paused.apply(this, arguments)
                            }, v.usesFrames = function() {
                                for (var t = this._timeline; t._timeline;) t = t._timeline;
                                return t === e._rootFramesTimeline
                            }, v.rawTime = function() {
                                return this._paused ? this._totalTime : (this._timeline.rawTime() - this._startTime) * this._timeScale
                            }, n
                        }, !0), i._gsDefine("TimelineMax", ["TimelineLite", "TweenLite", "easing.Ease"], function(e, t, i) {
                            var r = function(t) {
                                    e.call(this, t), this._repeat = this.vars.repeat || 0, this._repeatDelay = this.vars.repeatDelay || 0, this._cycle = 0, this._yoyo = this.vars.yoyo === !0, this._dirty = !0
                                },
                                n = 1e-10,
                                o = t._internals,
                                a = o.lazyTweens,
                                s = o.lazyRender,
                                l = new i(null, null, 1, 0),
                                c = r.prototype = new e;
                            return c.constructor = r, c.kill()._gc = !1, r.version = "1.18.2", c.invalidate = function() {
                                return this._yoyo = this.vars.yoyo === !0, this._repeat = this.vars.repeat || 0, this._repeatDelay = this.vars.repeatDelay || 0, this._uncache(!0), e.prototype.invalidate.call(this)
                            }, c.addCallback = function(e, i, r, n) {
                                return this.add(t.delayedCall(0, e, r, n), i)
                            }, c.removeCallback = function(e, t) {
                                if (e)
                                    if (null == t) this._kill(null, e);
                                    else
                                        for (var i = this.getTweensOf(e, !1), r = i.length, n = this._parseTimeOrLabel(t); --r > -1;) i[r]._startTime === n && i[r]._enabled(!1, !1);
                                return this
                            }, c.removePause = function(t) {
                                return this.removeCallback(e._internals.pauseCallback, t)
                            }, c.tweenTo = function(e, i) {
                                i = i || {};
                                var r, n, o, a = {
                                    ease: l,
                                    useFrames: this.usesFrames(),
                                    immediateRender: !1
                                };
                                for (n in i) a[n] = i[n];
                                return a.time = this._parseTimeOrLabel(e), r = Math.abs(Number(a.time) - this._time) / this._timeScale || .001, o = new t(this, r, a), a.onStart = function() {
                                    o.target.paused(!0), o.vars.time !== o.target.time() && r === o.duration() && o.duration(Math.abs(o.vars.time - o.target.time()) / o.target._timeScale), i.onStart && o._callback("onStart")
                                }, o
                            }, c.tweenFromTo = function(e, t, i) {
                                i = i || {}, e = this._parseTimeOrLabel(e), i.startAt = {
                                    onComplete: this.seek,
                                    onCompleteParams: [e],
                                    callbackScope: this
                                }, i.immediateRender = i.immediateRender !== !1;
                                var r = this.tweenTo(t, i);
                                return r.duration(Math.abs(r.vars.time - e) / this._timeScale || .001)
                            }, c.render = function(e, t, i) {
                                this._gc && this._enabled(!0, !1);
                                var r, o, l, c, h, u, p, f, d = this._dirty ? this.totalDuration() : this._totalDuration,
                                    m = this._duration,
                                    g = this._time,
                                    v = this._totalTime,
                                    y = this._startTime,
                                    _ = this._timeScale,
                                    x = this._rawPrevTime,
                                    b = this._paused,
                                    w = this._cycle;
                                if (e >= d - 1e-7) this._locked || (this._totalTime = d, this._cycle = this._repeat), this._reversed || this._hasPausedChild() || (o = !0, c = "onComplete", h = !!this._timeline.autoRemoveChildren, 0 === this._duration && (0 >= e && e >= -1e-7 || 0 > x || x === n) && x !== e && this._first && (h = !0, x > n && (c = "onReverseComplete"))), this._rawPrevTime = this._duration || !t || e || this._rawPrevTime === e ? e : n, this._yoyo && 0 !== (1 & this._cycle) ? this._time = e = 0 : (this._time = m, e = m + 1e-4);
                                else if (1e-7 > e)
                                    if (this._locked || (this._totalTime = this._cycle = 0), this._time = 0, (0 !== g || 0 === m && x !== n && (x > 0 || 0 > e && x >= 0) && !this._locked) && (c = "onReverseComplete", o = this._reversed), 0 > e) this._active = !1, this._timeline.autoRemoveChildren && this._reversed ? (h = o = !0, c = "onReverseComplete") : x >= 0 && this._first && (h = !0), this._rawPrevTime = e;
                                    else {
                                        if (this._rawPrevTime = m || !t || e || this._rawPrevTime === e ? e : n, 0 === e && o)
                                            for (r = this._first; r && 0 === r._startTime;) r._duration || (o = !1), r = r._next;
                                        e = 0, this._initted || (h = !0)
                                    } else if (0 === m && 0 > x && (h = !0), this._time = this._rawPrevTime = e, this._locked || (this._totalTime = e, 0 !== this._repeat && (u = m + this._repeatDelay, this._cycle = this._totalTime / u >> 0, 0 !== this._cycle && this._cycle === this._totalTime / u && this._cycle--, this._time = this._totalTime - this._cycle * u, this._yoyo && 0 !== (1 & this._cycle) && (this._time = m - this._time), this._time > m ? (this._time = m, e = m + 1e-4) : this._time < 0 ? this._time = e = 0 : e = this._time)), this._hasPause && !this._forcingPlayhead && !t) {
                                    if (e = this._time, e >= g)
                                        for (r = this._first; r && r._startTime <= e && !p;) r._duration || "isPause" !== r.data || r.ratio || 0 === r._startTime && 0 === this._rawPrevTime || (p = r), r = r._next;
                                    else
                                        for (r = this._last; r && r._startTime >= e && !p;) r._duration || "isPause" === r.data && r._rawPrevTime > 0 && (p = r), r = r._prev;
                                    p && (this._time = e = p._startTime, this._totalTime = e + this._cycle * (this._totalDuration + this._repeatDelay))
                                }
                                if (this._cycle !== w && !this._locked) {
                                    var T = this._yoyo && 0 !== (1 & w),
                                        M = T === (this._yoyo && 0 !== (1 & this._cycle)),
                                        S = this._totalTime,
                                        E = this._cycle,
                                        A = this._rawPrevTime,
                                        C = this._time;
                                    if (this._totalTime = w * m, this._cycle < w ? T = !T : this._totalTime += m, this._time = g, this._rawPrevTime = 0 === m ? x - 1e-4 : x, this._cycle = w, this._locked = !0, g = T ? 0 : m, this.render(g, t, 0 === m), t || this._gc || this.vars.onRepeat && this._callback("onRepeat"), g !== this._time) return;
                                    if (M && (g = T ? m + 1e-4 : -1e-4, this.render(g, !0, !1)), this._locked = !1, this._paused && !b) return;
                                    this._time = C, this._totalTime = S, this._cycle = E, this._rawPrevTime = A
                                }
                                if (!(this._time !== g && this._first || i || h || p)) return void(v !== this._totalTime && this._onUpdate && (t || this._callback("onUpdate")));
                                if (this._initted || (this._initted = !0), this._active || !this._paused && this._totalTime !== v && e > 0 && (this._active = !0), 0 === v && this.vars.onStart && 0 !== this._totalTime && (t || this._callback("onStart")), f = this._time, f >= g)
                                    for (r = this._first; r && (l = r._next, f === this._time && (!this._paused || b));)(r._active || r._startTime <= this._time && !r._paused && !r._gc) && (p === r && this.pause(), r._reversed ? r.render((r._dirty ? r.totalDuration() : r._totalDuration) - (e - r._startTime) * r._timeScale, t, i) : r.render((e - r._startTime) * r._timeScale, t, i)), r = l;
                                else
                                    for (r = this._last; r && (l = r._prev, f === this._time && (!this._paused || b));) {
                                        if (r._active || r._startTime <= g && !r._paused && !r._gc) {
                                            if (p === r) {
                                                for (p = r._prev; p && p.endTime() > this._time;) p.render(p._reversed ? p.totalDuration() - (e - p._startTime) * p._timeScale : (e - p._startTime) * p._timeScale, t, i), p = p._prev;
                                                p = null, this.pause()
                                            }
                                            r._reversed ? r.render((r._dirty ? r.totalDuration() : r._totalDuration) - (e - r._startTime) * r._timeScale, t, i) : r.render((e - r._startTime) * r._timeScale, t, i)
                                        }
                                        r = l
                                    }
                                this._onUpdate && (t || (a.length && s(), this._callback("onUpdate"))), c && (this._locked || this._gc || y !== this._startTime && _ === this._timeScale || (0 === this._time || d >= this.totalDuration()) && (o && (a.length && s(), this._timeline.autoRemoveChildren && this._enabled(!1, !1), this._active = !1), !t && this.vars[c] && this._callback(c)))
                            }, c.getActive = function(e, t, i) {
                                null == e && (e = !0), null == t && (t = !0), null == i && (i = !1);
                                var r, n, o = [],
                                    a = this.getChildren(e, t, i),
                                    s = 0,
                                    l = a.length;
                                for (r = 0; l > r; r++) n = a[r], n.isActive() && (o[s++] = n);
                                return o
                            }, c.getLabelAfter = function(e) {
                                e || 0 !== e && (e = this._time);
                                var t, i = this.getLabelsArray(),
                                    r = i.length;
                                for (t = 0; r > t; t++)
                                    if (i[t].time > e) return i[t].name;
                                return null
                            }, c.getLabelBefore = function(e) {
                                null == e && (e = this._time);
                                for (var t = this.getLabelsArray(), i = t.length; --i > -1;)
                                    if (t[i].time < e) return t[i].name;
                                return null
                            }, c.getLabelsArray = function() {
                                var e, t = [],
                                    i = 0;
                                for (e in this._labels) t[i++] = {
                                    time: this._labels[e],
                                    name: e
                                };
                                return t.sort(function(e, t) {
                                    return e.time - t.time
                                }), t
                            }, c.progress = function(e, t) {
                                return arguments.length ? this.totalTime(this.duration() * (this._yoyo && 0 !== (1 & this._cycle) ? 1 - e : e) + this._cycle * (this._duration + this._repeatDelay), t) : this._time / this.duration()
                            }, c.totalProgress = function(e, t) {
                                return arguments.length ? this.totalTime(this.totalDuration() * e, t) : this._totalTime / this.totalDuration()
                            }, c.totalDuration = function(t) {
                                return arguments.length ? -1 !== this._repeat && t ? this.timeScale(this.totalDuration() / t) : this : (this._dirty && (e.prototype.totalDuration.call(this), this._totalDuration = -1 === this._repeat ? 999999999999 : this._duration * (this._repeat + 1) + this._repeatDelay * this._repeat), this._totalDuration)
                            }, c.time = function(e, t) {
                                return arguments.length ? (this._dirty && this.totalDuration(), e > this._duration && (e = this._duration), this._yoyo && 0 !== (1 & this._cycle) ? e = this._duration - e + this._cycle * (this._duration + this._repeatDelay) : 0 !== this._repeat && (e += this._cycle * (this._duration + this._repeatDelay)), this.totalTime(e, t)) : this._time
                            }, c.repeat = function(e) {
                                return arguments.length ? (this._repeat = e, this._uncache(!0)) : this._repeat
                            }, c.repeatDelay = function(e) {
                                return arguments.length ? (this._repeatDelay = e, this._uncache(!0)) : this._repeatDelay
                            }, c.yoyo = function(e) {
                                return arguments.length ? (this._yoyo = e, this) : this._yoyo
                            }, c.currentLabel = function(e) {
                                return arguments.length ? this.seek(e, !0) : this.getLabelBefore(this._time + 1e-8)
                            }, r
                        }, !0),
                        function() {
                            var e = 180 / Math.PI,
                                t = [],
                                r = [],
                                n = [],
                                o = {},
                                a = i._gsDefine.globals,
                                s = function(e, t, i, r) {
                                    this.a = e, this.b = t, this.c = i, this.d = r, this.da = r - e, this.ca = i - e, this.ba = t - e
                                },
                                l = ",x,y,z,left,top,right,bottom,marginTop,marginLeft,marginRight,marginBottom,paddingLeft,paddingTop,paddingRight,paddingBottom,backgroundPosition,backgroundPosition_y,",
                                c = function(e, t, i, r) {
                                    var n = {
                                            a: e
                                        },
                                        o = {},
                                        a = {},
                                        s = {
                                            c: r
                                        },
                                        l = (e + t) / 2,
                                        c = (t + i) / 2,
                                        h = (i + r) / 2,
                                        u = (l + c) / 2,
                                        p = (c + h) / 2,
                                        f = (p - u) / 8;
                                    return n.b = l + (e - l) / 4, o.b = u + f, n.c = o.a = (n.b + o.b) / 2, o.c = a.a = (u + p) / 2, a.b = p - f, s.b = h + (r - h) / 4, a.c = s.a = (a.b + s.b) / 2, [n, o, a, s]
                                },
                                h = function(e, i, o, a, s) {
                                    var l, h, u, p, f, d, m, g, v, y, _, x, b, w = e.length - 1,
                                        T = 0,
                                        M = e[0].a;
                                    for (l = 0; w > l; l++) f = e[T], h = f.a, u = f.d, p = e[T + 1].d, s ? (_ = t[l], x = r[l], b = (x + _) * i * .25 / (a ? .5 : n[l] || .5), d = u - (u - h) * (a ? .5 * i : 0 !== _ ? b / _ : 0), m = u + (p - u) * (a ? .5 * i : 0 !== x ? b / x : 0), g = u - (d + ((m - d) * (3 * _ / (_ + x) + .5) / 4 || 0))) : (d = u - (u - h) * i * .5, m = u + (p - u) * i * .5, g = u - (d + m) / 2), d += g, m += g, f.c = v = d, 0 !== l ? f.b = M : f.b = M = f.a + .6 * (f.c - f.a), f.da = u - h, f.ca = v - h, f.ba = M - h, o ? (y = c(h, M, v, u), e.splice(T, 1, y[0], y[1], y[2], y[3]), T += 4) : T++, M = m;
                                    f = e[T], f.b = M, f.c = M + .4 * (f.d - M), f.da = f.d - f.a, f.ca = f.c - f.a, f.ba = M - f.a, o && (y = c(f.a, M, f.c, f.d), e.splice(T, 1, y[0], y[1], y[2], y[3]))
                                },
                                u = function(e, i, n, o) {
                                    var a, l, c, h, u, p, f = [];
                                    if (o)
                                        for (e = [o].concat(e), l = e.length; --l > -1;) "string" == typeof(p = e[l][i]) && "=" === p.charAt(1) && (e[l][i] = o[i] + Number(p.charAt(0) + p.substr(2)));
                                    if (a = e.length - 2, 0 > a) return f[0] = new s(e[0][i], 0, 0, e[-1 > a ? 0 : 1][i]), f;
                                    for (l = 0; a > l; l++) c = e[l][i], h = e[l + 1][i], f[l] = new s(c, 0, 0, h), n && (u = e[l + 2][i], t[l] = (t[l] || 0) + (h - c) * (h - c), r[l] = (r[l] || 0) + (u - h) * (u - h));
                                    return f[l] = new s(e[l][i], 0, 0, e[l + 1][i]), f
                                },
                                p = function(e, i, a, s, c, p) {
                                    var f, d, m, g, v, y, _, x, b = {},
                                        w = [],
                                        T = p || e[0];
                                    c = "string" == typeof c ? "," + c + "," : l, null == i && (i = 1);
                                    for (d in e[0]) w.push(d);
                                    if (e.length > 1) {
                                        for (x = e[e.length - 1], _ = !0, f = w.length; --f > -1;)
                                            if (d = w[f], Math.abs(T[d] - x[d]) > .05) {
                                                _ = !1;
                                                break
                                            }
                                        _ && (e = e.concat(), p && e.unshift(p), e.push(e[1]), p = e[e.length - 3])
                                    }
                                    for (t.length = r.length = n.length = 0, f = w.length; --f > -1;) d = w[f], o[d] = -1 !== c.indexOf("," + d + ","), b[d] = u(e, d, o[d], p);
                                    for (f = t.length; --f > -1;) t[f] = Math.sqrt(t[f]), r[f] = Math.sqrt(r[f]);
                                    if (!s) {
                                        for (f = w.length; --f > -1;)
                                            if (o[d])
                                                for (m = b[w[f]], y = m.length - 1, g = 0; y > g; g++) v = m[g + 1].da / r[g] + m[g].da / t[g], n[g] = (n[g] || 0) + v * v;
                                        for (f = n.length; --f > -1;) n[f] = Math.sqrt(n[f])
                                    }
                                    for (f = w.length, g = a ? 4 : 1; --f > -1;) d = w[f], m = b[d], h(m, i, a, s, o[d]), _ && (m.splice(0, g), m.splice(m.length - g, g));
                                    return b
                                },
                                f = function(e, t, i) {
                                    t = t || "soft";
                                    var r, n, o, a, l, c, h, u, p, f, d, m = {},
                                        g = "cubic" === t ? 3 : 2,
                                        v = "soft" === t,
                                        y = [];
                                    if (v && i && (e = [i].concat(e)), null == e || e.length < g + 1) throw "invalid Bezier data";
                                    for (p in e[0]) y.push(p);
                                    for (c = y.length; --c > -1;) {
                                        for (p = y[c], m[p] = l = [], f = 0, u = e.length, h = 0; u > h; h++) r = null == i ? e[h][p] : "string" == typeof(d = e[h][p]) && "=" === d.charAt(1) ? i[p] + Number(d.charAt(0) + d.substr(2)) : Number(d), v && h > 1 && u - 1 > h && (l[f++] = (r + l[f - 2]) / 2), l[f++] = r;
                                        for (u = f - g + 1, f = 0, h = 0; u > h; h += g) r = l[h], n = l[h + 1], o = l[h + 2], a = 2 === g ? 0 : l[h + 3], l[f++] = d = 3 === g ? new s(r, n, o, a) : new s(r, (2 * n + r) / 3, (2 * n + o) / 3, o);
                                        l.length = f
                                    }
                                    return m
                                },
                                d = function(e, t, i) {
                                    for (var r, n, o, a, s, l, c, h, u, p, f, d = 1 / i, m = e.length; --m > -1;)
                                        for (p = e[m], o = p.a, a = p.d - o, s = p.c - o, l = p.b - o, r = n = 0, h = 1; i >= h; h++) c = d * h, u = 1 - c, r = n - (n = (c * c * a + 3 * u * (c * s + u * l)) * c), f = m * i + h - 1, t[f] = (t[f] || 0) + r * r
                                },
                                m = function(e, t) {
                                    t = t >> 0 || 6;
                                    var i, r, n, o, a = [],
                                        s = [],
                                        l = 0,
                                        c = 0,
                                        h = t - 1,
                                        u = [],
                                        p = [];
                                    for (i in e) d(e[i], a, t);
                                    for (n = a.length, r = 0; n > r; r++) l += Math.sqrt(a[r]), o = r % t, p[o] = l, o === h && (c += l, o = r / t >> 0, u[o] = p, s[o] = c, l = 0, p = []);
                                    return {
                                        length: c,
                                        lengths: s,
                                        segments: u
                                    }
                                },
                                g = i._gsDefine.plugin({
                                    propName: "bezier",
                                    priority: -1,
                                    version: "1.3.4",
                                    API: 2,
                                    global: !0,
                                    init: function(e, t, i) {
                                        this._target = e, t instanceof Array && (t = {
                                            values: t
                                        }), this._func = {}, this._round = {}, this._props = [], this._timeRes = null == t.timeResolution ? 6 : parseInt(t.timeResolution, 10);
                                        var r, n, o, a, s, l = t.values || [],
                                            c = {},
                                            h = l[0],
                                            u = t.autoRotate || i.vars.orientToBezier;
                                        this._autoRotate = u ? u instanceof Array ? u : [
                                            ["x", "y", "rotation", u === !0 ? 0 : Number(u) || 0]
                                        ] : null;
                                        for (r in h) this._props.push(r);
                                        for (o = this._props.length; --o > -1;) r = this._props[o], this._overwriteProps.push(r), n = this._func[r] = "function" == typeof e[r], c[r] = n ? e[r.indexOf("set") || "function" != typeof e["get" + r.substr(3)] ? r : "get" + r.substr(3)]() : parseFloat(e[r]), s || c[r] !== l[0][r] && (s = c);
                                        if (this._beziers = "cubic" !== t.type && "quadratic" !== t.type && "soft" !== t.type ? p(l, isNaN(t.curviness) ? 1 : t.curviness, !1, "thruBasic" === t.type, t.correlate, s) : f(l, t.type, c), this._segCount = this._beziers[r].length, this._timeRes) {
                                            var d = m(this._beziers, this._timeRes);
                                            this._length = d.length, this._lengths = d.lengths, this._segments = d.segments, this._l1 = this._li = this._s1 = this._si = 0, this._l2 = this._lengths[0], this._curSeg = this._segments[0], this._s2 = this._curSeg[0], this._prec = 1 / this._curSeg.length
                                        }
                                        if (u = this._autoRotate)
                                            for (this._initialRotations = [], u[0] instanceof Array || (this._autoRotate = u = [u]), o = u.length; --o > -1;) {
                                                for (a = 0; 3 > a; a++) r = u[o][a], this._func[r] = "function" == typeof e[r] ? e[r.indexOf("set") || "function" != typeof e["get" + r.substr(3)] ? r : "get" + r.substr(3)] : !1;
                                                r = u[o][2], this._initialRotations[o] = this._func[r] ? this._func[r].call(this._target) : this._target[r]
                                            }
                                        return this._startRatio = i.vars.runBackwards ? 1 : 0, !0
                                    },
                                    set: function(t) {
                                        var i, r, n, o, a, s, l, c, h, u, p = this._segCount,
                                            f = this._func,
                                            d = this._target,
                                            m = t !== this._startRatio;
                                        if (this._timeRes) {
                                            if (h = this._lengths, u = this._curSeg, t *= this._length, n = this._li, t > this._l2 && p - 1 > n) {
                                                for (c = p - 1; c > n && (this._l2 = h[++n]) <= t;);
                                                this._l1 = h[n - 1], this._li = n, this._curSeg = u = this._segments[n], this._s2 = u[this._s1 = this._si = 0]
                                            } else if (t < this._l1 && n > 0) {
                                                for (; n > 0 && (this._l1 = h[--n]) >= t;);
                                                0 === n && t < this._l1 ? this._l1 = 0 : n++, this._l2 = h[n], this._li = n, this._curSeg = u = this._segments[n], this._s1 = u[(this._si = u.length - 1) - 1] || 0, this._s2 = u[this._si]
                                            }
                                            if (i = n, t -= this._l1, n = this._si, t > this._s2 && n < u.length - 1) {
                                                for (c = u.length - 1; c > n && (this._s2 = u[++n]) <= t;);
                                                this._s1 = u[n - 1], this._si = n
                                            } else if (t < this._s1 && n > 0) {
                                                for (; n > 0 && (this._s1 = u[--n]) >= t;);
                                                0 === n && t < this._s1 ? this._s1 = 0 : n++, this._s2 = u[n], this._si = n
                                            }
                                            s = (n + (t - this._s1) / (this._s2 - this._s1)) * this._prec
                                        } else i = 0 > t ? 0 : t >= 1 ? p - 1 : p * t >> 0, s = (t - i * (1 / p)) * p;
                                        for (r = 1 - s, n = this._props.length; --n > -1;) o = this._props[n], a = this._beziers[o][i], l = (s * s * a.da + 3 * r * (s * a.ca + r * a.ba)) * s + a.a, this._round[o] && (l = Math.round(l)), f[o] ? d[o](l) : d[o] = l;
                                        if (this._autoRotate) {
                                            var g, v, y, _, x, b, w, T = this._autoRotate;
                                            for (n = T.length; --n > -1;) o = T[n][2], b = T[n][3] || 0, w = T[n][4] === !0 ? 1 : e, a = this._beziers[T[n][0]], g = this._beziers[T[n][1]], a && g && (a = a[i], g = g[i], v = a.a + (a.b - a.a) * s, _ = a.b + (a.c - a.b) * s, v += (_ - v) * s, _ += (a.c + (a.d - a.c) * s - _) * s, y = g.a + (g.b - g.a) * s, x = g.b + (g.c - g.b) * s, y += (x - y) * s, x += (g.c + (g.d - g.c) * s - x) * s, l = m ? Math.atan2(x - y, _ - v) * w + b : this._initialRotations[n], f[o] ? d[o](l) : d[o] = l)
                                        }
                                    }
                                }),
                                v = g.prototype;
                            g.bezierThrough = p, g.cubicToQuadratic = c, g._autoCSS = !0, g.quadraticToCubic = function(e, t, i) {
                                return new s(e, (2 * t + e) / 3, (2 * t + i) / 3, i)
                            }, g._cssRegister = function() {
                                var e = a.CSSPlugin;
                                if (e) {
                                    var t = e._internals,
                                        i = t._parseToProxy,
                                        r = t._setPluginRatio,
                                        n = t.CSSPropTween;
                                    t._registerComplexSpecialProp("bezier", {
                                        parser: function(e, t, o, a, s, l) {
                                            t instanceof Array && (t = {
                                                values: t
                                            }), l = new g;
                                            var c, h, u, p = t.values,
                                                f = p.length - 1,
                                                d = [],
                                                m = {};
                                            if (0 > f) return s;
                                            for (c = 0; f >= c; c++) u = i(e, p[c], a, s, l, f !== c), d[c] = u.end;
                                            for (h in t) m[h] = t[h];
                                            return m.values = d, s = new n(e, "bezier", 0, 0, u.pt, 2), s.data = u, s.plugin = l, s.setRatio = r, 0 === m.autoRotate && (m.autoRotate = !0), !m.autoRotate || m.autoRotate instanceof Array || (c = m.autoRotate === !0 ? 0 : Number(m.autoRotate), m.autoRotate = null != u.end.left ? [
                                                ["left", "top", "rotation", c, !1]
                                            ] : null != u.end.x ? [
                                                ["x", "y", "rotation", c, !1]
                                            ] : !1), m.autoRotate && (a._transform || a._enableTransforms(!1), u.autoRotate = a._target._gsTransform), l._onInitTween(u.proxy, m, a._tween), s
                                        }
                                    })
                                }
                            }, v._roundProps = function(e, t) {
                                for (var i = this._overwriteProps, r = i.length; --r > -1;)(e[i[r]] || e.bezier || e.bezierThrough) && (this._round[i[r]] = t)
                            }, v._kill = function(e) {
                                var t, i, r = this._props;
                                for (t in this._beziers)
                                    if (t in e)
                                        for (delete this._beziers[t], delete this._func[t], i = r.length; --i > -1;) r[i] === t && r.splice(i, 1);
                                return this._super._kill.call(this, e)
                            }
                        }(), i._gsDefine("plugins.CSSPlugin", ["plugins.TweenPlugin", "TweenLite"], function(e, t) {
                            var r, n, o, a, s = function() {
                                    e.call(this, "css"), this._overwriteProps.length = 0, this.setRatio = s.prototype.setRatio
                                },
                                l = i._gsDefine.globals,
                                c = {},
                                h = s.prototype = new e("css");
                            h.constructor = s, s.version = "1.18.2", s.API = 2, s.defaultTransformPerspective = 0, s.defaultSkewType = "compensated", s.defaultSmoothOrigin = !0, h = "px", s.suffixMap = {
                                top: h,
                                right: h,
                                bottom: h,
                                left: h,
                                width: h,
                                height: h,
                                fontSize: h,
                                padding: h,
                                margin: h,
                                perspective: h,
                                lineHeight: ""
                            };
                            var u, p, f, d, m, g, v = /(?:\d|\-\d|\.\d|\-\.\d)+/g,
                                y = /(?:\d|\-\d|\.\d|\-\.\d|\+=\d|\-=\d|\+=.\d|\-=\.\d)+/g,
                                _ = /(?:\+=|\-=|\-|\b)[\d\-\.]+[a-zA-Z0-9]*(?:%|\b)/gi,
                                x = /(?![+-]?\d*\.?\d+|[+-]|e[+-]\d+)[^0-9]/g,
                                b = /(?:\d|\-|\+|=|#|\.)*/g,
                                w = /opacity *= *([^)]*)/i,
                                T = /opacity:([^;]*)/i,
                                M = /alpha\(opacity *=.+?\)/i,
                                S = /^(rgb|hsl)/,
                                E = /([A-Z])/g,
                                A = /-([a-z])/gi,
                                C = /(^(?:url\(\"|url\())|(?:(\"\))$|\)$)/gi,
                                L = function(e, t) {
                                    return t.toUpperCase()
                                },
                                P = /(?:Left|Right|Width)/i,
                                R = /(M11|M12|M21|M22)=[\d\-\.e]+/gi,
                                D = /progid\:DXImageTransform\.Microsoft\.Matrix\(.+?\)/i,
                                O = /,(?=[^\)]*(?:\(|$))/gi,
                                I = Math.PI / 180,
                                F = 180 / Math.PI,
                                N = {},
                                B = document,
                                k = function(e) {
                                    return B.createElementNS ? B.createElementNS("http://www.w3.org/1999/xhtml", e) : B.createElement(e)
                                },
                                U = k("div"),
                                V = k("img"),
                                z = s._internals = {
                                    _specialProps: c
                                },
                                G = navigator.userAgent,
                                H = function() {
                                    var e = G.indexOf("Android"),
                                        t = k("a");
                                    return f = -1 !== G.indexOf("Safari") && -1 === G.indexOf("Chrome") && (-1 === e || Number(G.substr(e + 8, 1)) > 3), m = f && Number(G.substr(G.indexOf("Version/") + 8, 1)) < 6, d = -1 !== G.indexOf("Firefox"), (/MSIE ([0-9]{1,}[\.0-9]{0,})/.exec(G) || /Trident\/.*rv:([0-9]{1,}[\.0-9]{0,})/.exec(G)) && (g = parseFloat(RegExp.$1)), t ? (t.style.cssText = "top:1px;opacity:.55;", /^0.55/.test(t.style.opacity)) : !1
                                }(),
                                j = function(e) {
                                    return w.test("string" == typeof e ? e : (e.currentStyle ? e.currentStyle.filter : e.style.filter) || "") ? parseFloat(RegExp.$1) / 100 : 1
                                },
                                W = function(e) {
                                    window.console && console.log(e)
                                },
                                X = "",
                                q = "",
                                Y = function(e, t) {
                                    t = t || U;
                                    var i, r, n = t.style;
                                    if (void 0 !== n[e]) return e;
                                    for (e = e.charAt(0).toUpperCase() + e.substr(1), i = ["O", "Moz", "ms", "Ms", "Webkit"], r = 5; --r > -1 && void 0 === n[i[r] + e];);
                                    return r >= 0 ? (q = 3 === r ? "ms" : i[r], X = "-" + q.toLowerCase() + "-", q + e) : null
                                },
                                Z = B.defaultView ? B.defaultView.getComputedStyle : function() {},
                                Q = s.getStyle = function(e, t, i, r, n) {
                                    var o;
                                    return H || "opacity" !== t ? (!r && e.style[t] ? o = e.style[t] : (i = i || Z(e)) ? o = i[t] || i.getPropertyValue(t) || i.getPropertyValue(t.replace(E, "-$1").toLowerCase()) : e.currentStyle && (o = e.currentStyle[t]), null == n || o && "none" !== o && "auto" !== o && "auto auto" !== o ? o : n) : j(e)
                                },
                                K = z.convertToPixels = function(e, i, r, n, o) {
                                    if ("px" === n || !n) return r;
                                    if ("auto" === n || !r) return 0;
                                    var a, l, c, h = P.test(i),
                                        u = e,
                                        p = U.style,
                                        f = 0 > r;
                                    if (f && (r = -r), "%" === n && -1 !== i.indexOf("border")) a = r / 100 * (h ? e.clientWidth : e.clientHeight);
                                    else {
                                        if (p.cssText = "border:0 solid red;position:" + Q(e, "position") + ";line-height:0;", "%" !== n && u.appendChild && "v" !== n.charAt(0) && "rem" !== n) p[h ? "borderLeftWidth" : "borderTopWidth"] = r + n;
                                        else {
                                            if (u = e.parentNode || B.body, l = u._gsCache, c = t.ticker.frame, l && h && l.time === c) return l.width * r / 100;
                                            p[h ? "width" : "height"] = r + n
                                        }
                                        u.appendChild(U), a = parseFloat(U[h ? "offsetWidth" : "offsetHeight"]), u.removeChild(U), h && "%" === n && s.cacheWidths !== !1 && (l = u._gsCache = u._gsCache || {}, l.time = c, l.width = a / r * 100), 0 !== a || o || (a = K(e, i, r, n, !0))
                                    }
                                    return f ? -a : a
                                },
                                $ = z.calculateOffset = function(e, t, i) {
                                    if ("absolute" !== Q(e, "position", i)) return 0;
                                    var r = "left" === t ? "Left" : "Top",
                                        n = Q(e, "margin" + r, i);
                                    return e["offset" + r] - (K(e, t, parseFloat(n), n.replace(b, "")) || 0)
                                },
                                J = function(e, t) {
                                    var i, r, n, o = {};
                                    if (t = t || Z(e, null))
                                        if (i = t.length)
                                            for (; --i > -1;) n = t[i], -1 !== n.indexOf("-transform") && Ee !== n || (o[n.replace(A, L)] = t.getPropertyValue(n));
                                        else
                                            for (i in t) - 1 !== i.indexOf("Transform") && Se !== i || (o[i] = t[i]);
                                    else if (t = e.currentStyle || e.style)
                                        for (i in t) "string" == typeof i && void 0 === o[i] && (o[i.replace(A, L)] = t[i]);
                                    return H || (o.opacity = j(e)), r = ke(e, t, !1), o.rotation = r.rotation, o.skewX = r.skewX, o.scaleX = r.scaleX, o.scaleY = r.scaleY, o.x = r.x, o.y = r.y, Ce && (o.z = r.z, o.rotationX = r.rotationX, o.rotationY = r.rotationY, o.scaleZ = r.scaleZ), o.filters && delete o.filters, o
                                },
                                ee = function(e, t, i, r, n) {
                                    var o, a, s, l = {},
                                        c = e.style;
                                    for (a in i) "cssText" !== a && "length" !== a && isNaN(a) && (t[a] !== (o = i[a]) || n && n[a]) && -1 === a.indexOf("Origin") && ("number" != typeof o && "string" != typeof o || (l[a] = "auto" !== o || "left" !== a && "top" !== a ? "" !== o && "auto" !== o && "none" !== o || "string" != typeof t[a] || "" === t[a].replace(x, "") ? o : 0 : $(e, a), void 0 !== c[a] && (s = new me(c, a, c[a], s))));
                                    if (r)
                                        for (a in r) "className" !== a && (l[a] = r[a]);
                                    return {
                                        difs: l,
                                        firstMPT: s
                                    }
                                },
                                te = {
                                    width: ["Left", "Right"],
                                    height: ["Top", "Bottom"]
                                },
                                ie = ["marginLeft", "marginRight", "marginTop", "marginBottom"],
                                re = function(e, t, i) {
                                    var r = parseFloat("width" === t ? e.offsetWidth : e.offsetHeight),
                                        n = te[t],
                                        o = n.length;
                                    for (i = i || Z(e, null); --o > -1;) r -= parseFloat(Q(e, "padding" + n[o], i, !0)) || 0, r -= parseFloat(Q(e, "border" + n[o] + "Width", i, !0)) || 0;
                                    return r
                                },
                                ne = function(e, t) {
                                    if ("contain" === e || "auto" === e || "auto auto" === e) return e + " ";
                                    null != e && "" !== e || (e = "0 0");
                                    var i = e.split(" "),
                                        r = -1 !== e.indexOf("left") ? "0%" : -1 !== e.indexOf("right") ? "100%" : i[0],
                                        n = -1 !== e.indexOf("top") ? "0%" : -1 !== e.indexOf("bottom") ? "100%" : i[1];
                                    return null == n ? n = "center" === r ? "50%" : "0" : "center" === n && (n = "50%"), ("center" === r || isNaN(parseFloat(r)) && -1 === (r + "").indexOf("=")) && (r = "50%"), e = r + " " + n + (i.length > 2 ? " " + i[2] : ""), t && (t.oxp = -1 !== r.indexOf("%"), t.oyp = -1 !== n.indexOf("%"), t.oxr = "=" === r.charAt(1), t.oyr = "=" === n.charAt(1), t.ox = parseFloat(r.replace(x, "")), t.oy = parseFloat(n.replace(x, "")), t.v = e), t || e
                                },
                                oe = function(e, t) {
                                    return "string" == typeof e && "=" === e.charAt(1) ? parseInt(e.charAt(0) + "1", 10) * parseFloat(e.substr(2)) : parseFloat(e) - parseFloat(t)
                                },
                                ae = function(e, t) {
                                    return null == e ? t : "string" == typeof e && "=" === e.charAt(1) ? parseInt(e.charAt(0) + "1", 10) * parseFloat(e.substr(2)) + t : parseFloat(e)
                                },
                                se = function(e, t, i, r) {
                                    var n, o, a, s, l, c = 1e-6;
                                    return null == e ? s = t : "number" == typeof e ? s = e : (n = 360, o = e.split("_"), l = "=" === e.charAt(1), a = (l ? parseInt(e.charAt(0) + "1", 10) * parseFloat(o[0].substr(2)) : parseFloat(o[0])) * (-1 === e.indexOf("rad") ? 1 : F) - (l ? 0 : t), o.length && (r && (r[i] = t + a), -1 !== e.indexOf("short") && (a %= n, a !== a % (n / 2) && (a = 0 > a ? a + n : a - n)), -1 !== e.indexOf("_cw") && 0 > a ? a = (a + 9999999999 * n) % n - (a / n | 0) * n : -1 !== e.indexOf("ccw") && a > 0 && (a = (a - 9999999999 * n) % n - (a / n | 0) * n)), s = t + a), c > s && s > -c && (s = 0), s
                                },
                                le = {
                                    aqua: [0, 255, 255],
                                    lime: [0, 255, 0],
                                    silver: [192, 192, 192],
                                    black: [0, 0, 0],
                                    maroon: [128, 0, 0],
                                    teal: [0, 128, 128],
                                    blue: [0, 0, 255],
                                    navy: [0, 0, 128],
                                    white: [255, 255, 255],
                                    fuchsia: [255, 0, 255],
                                    olive: [128, 128, 0],
                                    yellow: [255, 255, 0],
                                    orange: [255, 165, 0],
                                    gray: [128, 128, 128],
                                    purple: [128, 0, 128],
                                    green: [0, 128, 0],
                                    red: [255, 0, 0],
                                    pink: [255, 192, 203],
                                    cyan: [0, 255, 255],
                                    transparent: [255, 255, 255, 0]
                                },
                                ce = function(e, t, i) {
                                    return e = 0 > e ? e + 1 : e > 1 ? e - 1 : e, 255 * (1 > 6 * e ? t + (i - t) * e * 6 : .5 > e ? i : 2 > 3 * e ? t + (i - t) * (2 / 3 - e) * 6 : t) + .5 | 0
                                },
                                he = s.parseColor = function(e, t) {
                                    var i, r, n, o, a, s, l, c, h, u, p;
                                    if (e)
                                        if ("number" == typeof e) i = [e >> 16, e >> 8 & 255, 255 & e];
                                        else {
                                            if ("," === e.charAt(e.length - 1) && (e = e.substr(0, e.length - 1)), le[e]) i = le[e];
                                            else if ("#" === e.charAt(0)) 4 === e.length && (r = e.charAt(1), n = e.charAt(2), o = e.charAt(3), e = "#" + r + r + n + n + o + o), e = parseInt(e.substr(1), 16), i = [e >> 16, e >> 8 & 255, 255 & e];
                                            else if ("hsl" === e.substr(0, 3))
                                                if (i = p = e.match(v), t) {
                                                    if (-1 !== e.indexOf("=")) return e.match(y)
                                                } else a = Number(i[0]) % 360 / 360, s = Number(i[1]) / 100, l = Number(i[2]) / 100, n = .5 >= l ? l * (s + 1) : l + s - l * s, r = 2 * l - n, i.length > 3 && (i[3] = Number(e[3])), i[0] = ce(a + 1 / 3, r, n), i[1] = ce(a, r, n), i[2] = ce(a - 1 / 3, r, n);
                                            else i = e.match(v) || le.transparent;
                                            i[0] = Number(i[0]), i[1] = Number(i[1]), i[2] = Number(i[2]), i.length > 3 && (i[3] = Number(i[3]))
                                        } else i = le.black;
                                    return t && !p && (r = i[0] / 255, n = i[1] / 255, o = i[2] / 255, c = Math.max(r, n, o), h = Math.min(r, n, o), l = (c + h) / 2, c === h ? a = s = 0 : (u = c - h, s = l > .5 ? u / (2 - c - h) : u / (c + h), a = c === r ? (n - o) / u + (o > n ? 6 : 0) : c === n ? (o - r) / u + 2 : (r - n) / u + 4, a *= 60), i[0] = a + .5 | 0, i[1] = 100 * s + .5 | 0, i[2] = 100 * l + .5 | 0), i
                                },
                                ue = function(e, t) {
                                    var i, r, n, o = e.match(pe) || [],
                                        a = 0,
                                        s = o.length ? "" : e;
                                    for (i = 0; i < o.length; i++) r = o[i], n = e.substr(a, e.indexOf(r, a) - a), a += n.length + r.length, r = he(r, t), 3 === r.length && r.push(1), s += n + (t ? "hsla(" + r[0] + "," + r[1] + "%," + r[2] + "%," + r[3] : "rgba(" + r.join(",")) + ")";
                                    return s
                                },
                                pe = "(?:\\b(?:(?:rgb|rgba|hsl|hsla)\\(.+?\\))|\\B#(?:[0-9a-f]{3}){1,2}\\b";
                            for (h in le) pe += "|" + h + "\\b";
                            pe = new RegExp(pe + ")", "gi"), s.colorStringFilter = function(e) {
                                var t, i = e[0] + e[1];
                                pe.lastIndex = 0, pe.test(i) && (t = -1 !== i.indexOf("hsl(") || -1 !== i.indexOf("hsla("), e[0] = ue(e[0], t), e[1] = ue(e[1], t))
                            }, t.defaultStringFilter || (t.defaultStringFilter = s.colorStringFilter);
                            var fe = function(e, t, i, r) {
                                    if (null == e) return function(e) {
                                        return e
                                    };
                                    var n, o = t ? (e.match(pe) || [""])[0] : "",
                                        a = e.split(o).join("").match(_) || [],
                                        s = e.substr(0, e.indexOf(a[0])),
                                        l = ")" === e.charAt(e.length - 1) ? ")" : "",
                                        c = -1 !== e.indexOf(" ") ? " " : ",",
                                        h = a.length,
                                        u = h > 0 ? a[0].replace(v, "") : "";
                                    return h ? n = t ? function(e) {
                                        var t, p, f, d;
                                        if ("number" == typeof e) e += u;
                                        else if (r && O.test(e)) {
                                            for (d = e.replace(O, "|").split("|"), f = 0; f < d.length; f++) d[f] = n(d[f]);
                                            return d.join(",")
                                        }
                                        if (t = (e.match(pe) || [o])[0], p = e.split(t).join("").match(_) || [], f = p.length, h > f--)
                                            for (; ++f < h;) p[f] = i ? p[(f - 1) / 2 | 0] : a[f];
                                        return s + p.join(c) + c + t + l + (-1 !== e.indexOf("inset") ? " inset" : "")
                                    } : function(e) {
                                        var t, o, p;
                                        if ("number" == typeof e) e += u;
                                        else if (r && O.test(e)) {
                                            for (o = e.replace(O, "|").split("|"), p = 0; p < o.length; p++) o[p] = n(o[p]);
                                            return o.join(",")
                                        }
                                        if (t = e.match(_) || [], p = t.length, h > p--)
                                            for (; ++p < h;) t[p] = i ? t[(p - 1) / 2 | 0] : a[p];
                                        return s + t.join(c) + l
                                    } : function(e) {
                                        return e
                                    }
                                },
                                de = function(e) {
                                    return e = e.split(","),
                                        function(t, i, r, n, o, a, s) {
                                            var l, c = (i + "").split(" ");
                                            for (s = {}, l = 0; 4 > l; l++) s[e[l]] = c[l] = c[l] || c[(l - 1) / 2 >> 0];
                                            return n.parse(t, s, o, a)
                                        }
                                },
                                me = (z._setPluginRatio = function(e) {
                                    this.plugin.setRatio(e);
                                    for (var t, i, r, n, o, a = this.data, s = a.proxy, l = a.firstMPT, c = 1e-6; l;) t = s[l.v], l.r ? t = Math.round(t) : c > t && t > -c && (t = 0), l.t[l.p] = t, l = l._next;
                                    if (a.autoRotate && (a.autoRotate.rotation = s.rotation), 1 === e || 0 === e)
                                        for (l = a.firstMPT, o = 1 === e ? "e" : "b"; l;) {
                                            if (i = l.t, i.type) {
                                                if (1 === i.type) {
                                                    for (n = i.xs0 + i.s + i.xs1, r = 1; r < i.l; r++) n += i["xn" + r] + i["xs" + (r + 1)];
                                                    i[o] = n
                                                }
                                            } else i[o] = i.s + i.xs0;
                                            l = l._next
                                        }
                                }, function(e, t, i, r, n) {
                                    this.t = e, this.p = t, this.v = i, this.r = n, r && (r._prev = this, this._next = r)
                                }),
                                ge = (z._parseToProxy = function(e, t, i, r, n, o) {
                                    var a, s, l, c, h, u = r,
                                        p = {},
                                        f = {},
                                        d = i._transform,
                                        m = N;
                                    for (i._transform = null, N = t, r = h = i.parse(e, t, r, n), N = m, o && (i._transform = d, u && (u._prev = null, u._prev && (u._prev._next = null))); r && r !== u;) {
                                        if (r.type <= 1 && (s = r.p, f[s] = r.s + r.c, p[s] = r.s, o || (c = new me(r, "s", s, c, r.r), r.c = 0), 1 === r.type))
                                            for (a = r.l; --a > 0;) l = "xn" + a, s = r.p + "_" + l, f[s] = r.data[l], p[s] = r[l], o || (c = new me(r, l, s, c, r.rxp[l]));
                                        r = r._next
                                    }
                                    return {
                                        proxy: p,
                                        end: f,
                                        firstMPT: c,
                                        pt: h
                                    }
                                }, z.CSSPropTween = function(e, t, i, n, o, s, l, c, h, u, p) {
                                    this.t = e, this.p = t, this.s = i, this.c = n, this.n = l || t, e instanceof ge || a.push(this.n), this.r = c, this.type = s || 0, h && (this.pr = h, r = !0), this.b = void 0 === u ? i : u, this.e = void 0 === p ? i + n : p, o && (this._next = o, o._prev = this)
                                }),
                                ve = function(e, t, i, r, n, o) {
                                    var a = new ge(e, t, i, r - i, n, -1, o);
                                    return a.b = i, a.e = a.xs0 = r, a
                                },
                                ye = s.parseComplex = function(e, t, i, r, n, o, a, s, l, c) {
                                    i = i || o || "", a = new ge(e, t, 0, 0, a, c ? 2 : 1, null, !1, s, i, r), r += "";
                                    var h, p, f, d, m, g, _, x, b, w, T, M, S, E = i.split(", ").join(",").split(" "),
                                        A = r.split(", ").join(",").split(" "),
                                        C = E.length,
                                        L = u !== !1;
                                    for (-1 === r.indexOf(",") && -1 === i.indexOf(",") || (E = E.join(" ").replace(O, ", ").split(" "), A = A.join(" ").replace(O, ", ").split(" "), C = E.length), C !== A.length && (E = (o || "").split(" "), C = E.length), a.plugin = l, a.setRatio = c, pe.lastIndex = 0, h = 0; C > h; h++)
                                        if (d = E[h], m = A[h], x = parseFloat(d), x || 0 === x) a.appendXtra("", x, oe(m, x), m.replace(y, ""), L && -1 !== m.indexOf("px"), !0);
                                        else if (n && pe.test(d)) M = "," === m.charAt(m.length - 1) ? ")," : ")", S = -1 !== m.indexOf("hsl") && H, d = he(d, S), m = he(m, S), b = d.length + m.length > 6, b && !H && 0 === m[3] ? (a["xs" + a.l] += a.l ? " transparent" : "transparent", a.e = a.e.split(A[h]).join("transparent")) : (H || (b = !1), S ? a.appendXtra(b ? "hsla(" : "hsl(", d[0], oe(m[0], d[0]), ",", !1, !0).appendXtra("", d[1], oe(m[1], d[1]), "%,", !1).appendXtra("", d[2], oe(m[2], d[2]), b ? "%," : "%" + M, !1) : a.appendXtra(b ? "rgba(" : "rgb(", d[0], m[0] - d[0], ",", !0, !0).appendXtra("", d[1], m[1] - d[1], ",", !0).appendXtra("", d[2], m[2] - d[2], b ? "," : M, !0), b && (d = d.length < 4 ? 1 : d[3], a.appendXtra("", d, (m.length < 4 ? 1 : m[3]) - d, M, !1))), pe.lastIndex = 0;
                                    else if (g = d.match(v)) {
                                        if (_ = m.match(y), !_ || _.length !== g.length) return a;
                                        for (f = 0, p = 0; p < g.length; p++) T = g[p], w = d.indexOf(T, f), a.appendXtra(d.substr(f, w - f), Number(T), oe(_[p], T), "", L && "px" === d.substr(w + T.length, 2), 0 === p), f = w + T.length;
                                        a["xs" + a.l] += d.substr(f)
                                    } else a["xs" + a.l] += a.l ? " " + m : m;
                                    if (-1 !== r.indexOf("=") && a.data) {
                                        for (M = a.xs0 + a.data.s, h = 1; h < a.l; h++) M += a["xs" + h] + a.data["xn" + h];
                                        a.e = M + a["xs" + h]
                                    }
                                    return a.l || (a.type = -1, a.xs0 = a.e), a.xfirst || a
                                },
                                _e = 9;
                            for (h = ge.prototype, h.l = h.pr = 0; --_e > 0;) h["xn" + _e] = 0, h["xs" + _e] = "";
                            h.xs0 = "", h._next = h._prev = h.xfirst = h.data = h.plugin = h.setRatio = h.rxp = null, h.appendXtra = function(e, t, i, r, n, o) {
                                var a = this,
                                    s = a.l;
                                return a["xs" + s] += o && s ? " " + e : e || "", i || 0 === s || a.plugin ? (a.l++, a.type = a.setRatio ? 2 : 1, a["xs" + a.l] = r || "", s > 0 ? (a.data["xn" + s] = t + i, a.rxp["xn" + s] = n, a["xn" + s] = t, a.plugin || (a.xfirst = new ge(a, "xn" + s, t, i, a.xfirst || a, 0, a.n, n, a.pr), a.xfirst.xs0 = 0), a) : (a.data = {
                                    s: t + i
                                }, a.rxp = {}, a.s = t, a.c = i, a.r = n, a)) : (a["xs" + s] += t + (r || ""), a)
                            };
                            var xe = function(e, t) {
                                    t = t || {}, this.p = t.prefix ? Y(e) || e : e, c[e] = c[this.p] = this, this.format = t.formatter || fe(t.defaultValue, t.color, t.collapsible, t.multi), t.parser && (this.parse = t.parser), this.clrs = t.color, this.multi = t.multi, this.keyword = t.keyword, this.dflt = t.defaultValue, this.pr = t.priority || 0
                                },
                                be = z._registerComplexSpecialProp = function(e, t, i) {
                                    "object" != typeof t && (t = {
                                        parser: i
                                    });
                                    var r, n, o = e.split(","),
                                        a = t.defaultValue;
                                    for (i = i || [a], r = 0; r < o.length; r++) t.prefix = 0 === r && t.prefix, t.defaultValue = i[r] || a, n = new xe(o[r], t)
                                },
                                we = function(e) {
                                    if (!c[e]) {
                                        var t = e.charAt(0).toUpperCase() + e.substr(1) + "Plugin";
                                        be(e, {
                                            parser: function(e, i, r, n, o, a, s) {
                                                var h = l.com.greensock.plugins[t];
                                                return h ? (h._cssRegister(), c[r].parse(e, i, r, n, o, a, s)) : (W("Error: " + t + " js file not loaded."), o)
                                            }
                                        })
                                    }
                                };
                            h = xe.prototype, h.parseComplex = function(e, t, i, r, n, o) {
                                var a, s, l, c, h, u, p = this.keyword;
                                if (this.multi && (O.test(i) || O.test(t) ? (s = t.replace(O, "|").split("|"), l = i.replace(O, "|").split("|")) : p && (s = [t], l = [i])), l) {
                                    for (c = l.length > s.length ? l.length : s.length, a = 0; c > a; a++) t = s[a] = s[a] || this.dflt, i = l[a] = l[a] || this.dflt, p && (h = t.indexOf(p), u = i.indexOf(p), h !== u && (-1 === u ? s[a] = s[a].split(p).join("") : -1 === h && (s[a] += " " + p)));
                                    t = s.join(", "), i = l.join(", ")
                                }
                                return ye(e, this.p, t, i, this.clrs, this.dflt, r, this.pr, n, o)
                            }, h.parse = function(e, t, i, r, n, a, s) {
                                return this.parseComplex(e.style, this.format(Q(e, this.p, o, !1, this.dflt)), this.format(t), n, a)
                            }, s.registerSpecialProp = function(e, t, i) {
                                be(e, {
                                    parser: function(e, r, n, o, a, s, l) {
                                        var c = new ge(e, n, 0, 0, a, 2, n, !1, i);
                                        return c.plugin = s, c.setRatio = t(e, r, o._tween, n), c
                                    },
                                    priority: i
                                })
                            }, s.useSVGTransformAttr = f || d;
                            var Te, Me = "scaleX,scaleY,scaleZ,x,y,z,skewX,skewY,rotation,rotationX,rotationY,perspective,xPercent,yPercent".split(","),
                                Se = Y("transform"),
                                Ee = X + "transform",
                                Ae = Y("transformOrigin"),
                                Ce = null !== Y("perspective"),
                                Le = z.Transform = function() {
                                    this.perspective = parseFloat(s.defaultTransformPerspective) || 0, this.force3D = s.defaultForce3D !== !1 && Ce ? s.defaultForce3D || "auto" : !1
                                },
                                Pe = window.SVGElement,
                                Re = function(e, t, i) {
                                    var r, n = B.createElementNS("http://www.w3.org/2000/svg", e),
                                        o = /([a-z])([A-Z])/g;
                                    for (r in i) n.setAttributeNS(null, r.replace(o, "$1-$2").toLowerCase(), i[r]);
                                    return t.appendChild(n), n
                                },
                                De = B.documentElement,
                                Oe = function() {
                                    var e, t, i, r = g || /Android/i.test(G) && !window.chrome;
                                    return B.createElementNS && !r && (e = Re("svg", De), t = Re("rect", e, {
                                        width: 100,
                                        height: 50,
                                        x: 100
                                    }), i = t.getBoundingClientRect().width, t.style[Ae] = "50% 50%", t.style[Se] = "scaleX(0.5)", r = i === t.getBoundingClientRect().width && !(d && Ce), De.removeChild(e)), r
                                }(),
                                Ie = function(e, t, i, r, n) {
                                    var o, a, l, c, h, u, p, f, d, m, g, v, y, _, x = e._gsTransform,
                                        b = Be(e, !0);
                                    x && (y = x.xOrigin, _ = x.yOrigin), (!r || (o = r.split(" ")).length < 2) && (p = e.getBBox(), t = ne(t).split(" "), o = [(-1 !== t[0].indexOf("%") ? parseFloat(t[0]) / 100 * p.width : parseFloat(t[0])) + p.x, (-1 !== t[1].indexOf("%") ? parseFloat(t[1]) / 100 * p.height : parseFloat(t[1])) + p.y]), i.xOrigin = c = parseFloat(o[0]), i.yOrigin = h = parseFloat(o[1]), r && b !== Ne && (u = b[0], p = b[1], f = b[2], d = b[3], m = b[4], g = b[5], v = u * d - p * f, a = c * (d / v) + h * (-f / v) + (f * g - d * m) / v, l = c * (-p / v) + h * (u / v) - (u * g - p * m) / v, c = i.xOrigin = o[0] = a, h = i.yOrigin = o[1] = l), x && (n || n !== !1 && s.defaultSmoothOrigin !== !1 ? (a = c - y, l = h - _, x.xOffset += a * b[0] + l * b[2] - a, x.yOffset += a * b[1] + l * b[3] - l) : x.xOffset = x.yOffset = 0), e.setAttribute("data-svg-origin", o.join(" "))
                                },
                                Fe = function(e) {
                                    return !!(Pe && "function" == typeof e.getBBox && e.getCTM && (!e.parentNode || e.parentNode.getBBox && e.parentNode.getCTM))
                                },
                                Ne = [1, 0, 0, 1, 0, 0],
                                Be = function(e, t) {
                                    var i, r, n, o, a, s = e._gsTransform || new Le,
                                        l = 1e5;
                                    if (Se ? r = Q(e, Ee, null, !0) : e.currentStyle && (r = e.currentStyle.filter.match(R), r = r && 4 === r.length ? [r[0].substr(4), Number(r[2].substr(4)), Number(r[1].substr(4)), r[3].substr(4), s.x || 0, s.y || 0].join(",") : ""), i = !r || "none" === r || "matrix(1, 0, 0, 1, 0, 0)" === r, (s.svg || e.getBBox && Fe(e)) && (i && -1 !== (e.style[Se] + "").indexOf("matrix") && (r = e.style[Se], i = 0), n = e.getAttribute("transform"), i && n && (-1 !== n.indexOf("matrix") ? (r = n, i = 0) : -1 !== n.indexOf("translate") && (r = "matrix(1,0,0,1," + n.match(/(?:\-|\b)[\d\-\.e]+\b/gi).join(",") + ")", i = 0))), i) return Ne;
                                    for (n = (r || "").match(/(?:\-|\b)[\d\-\.e]+\b/gi) || [], _e = n.length; --_e > -1;) o = Number(n[_e]), n[_e] = (a = o - (o |= 0)) ? (a * l + (0 > a ? -.5 : .5) | 0) / l + o : o;
                                    return t && n.length > 6 ? [n[0], n[1], n[4], n[5], n[12], n[13]] : n
                                },
                                ke = z.getTransform = function(e, i, r, n) {
                                    if (e._gsTransform && r && !n) return e._gsTransform;
                                    var a, l, c, h, u, p, f = r ? e._gsTransform || new Le : new Le,
                                        d = f.scaleX < 0,
                                        m = 2e-5,
                                        g = 1e5,
                                        v = Ce ? parseFloat(Q(e, Ae, i, !1, "0 0 0").split(" ")[2]) || f.zOrigin || 0 : 0,
                                        y = parseFloat(s.defaultTransformPerspective) || 0;
                                    if (f.svg = !(!e.getBBox || !Fe(e)), f.svg && (Ie(e, Q(e, Ae, o, !1, "50% 50%") + "", f, e.getAttribute("data-svg-origin")), Te = s.useSVGTransformAttr || Oe), a = Be(e), a !== Ne) {
                                        if (16 === a.length) {
                                            var _, x, b, w, T, M = a[0],
                                                S = a[1],
                                                E = a[2],
                                                A = a[3],
                                                C = a[4],
                                                L = a[5],
                                                P = a[6],
                                                R = a[7],
                                                D = a[8],
                                                O = a[9],
                                                I = a[10],
                                                N = a[12],
                                                B = a[13],
                                                k = a[14],
                                                U = a[11],
                                                V = Math.atan2(P, I);
                                            f.zOrigin && (k = -f.zOrigin, N = D * k - a[12], B = O * k - a[13], k = I * k + f.zOrigin - a[14]), f.rotationX = V * F, V && (w = Math.cos(-V), T = Math.sin(-V), _ = C * w + D * T, x = L * w + O * T, b = P * w + I * T, D = C * -T + D * w, O = L * -T + O * w, I = P * -T + I * w, U = R * -T + U * w, C = _, L = x, P = b), V = Math.atan2(-E, I), f.rotationY = V * F, V && (w = Math.cos(-V), T = Math.sin(-V), _ = M * w - D * T, x = S * w - O * T, b = E * w - I * T, O = S * T + O * w, I = E * T + I * w, U = A * T + U * w, M = _, S = x, E = b), V = Math.atan2(S, M), f.rotation = V * F, V && (w = Math.cos(-V), T = Math.sin(-V), M = M * w + C * T, x = S * w + L * T, L = S * -T + L * w, P = E * -T + P * w, S = x), f.rotationX && Math.abs(f.rotationX) + Math.abs(f.rotation) > 359.9 && (f.rotationX = f.rotation = 0, f.rotationY = 180 - f.rotationY), f.scaleX = (Math.sqrt(M * M + S * S) * g + .5 | 0) / g, f.scaleY = (Math.sqrt(L * L + O * O) * g + .5 | 0) / g, f.scaleZ = (Math.sqrt(P * P + I * I) * g + .5 | 0) / g, f.skewX = 0, f.perspective = U ? 1 / (0 > U ? -U : U) : 0, f.x = N, f.y = B, f.z = k, f.svg && (f.x -= f.xOrigin - (f.xOrigin * M - f.yOrigin * C), f.y -= f.yOrigin - (f.yOrigin * S - f.xOrigin * L))
                                        } else if ((!Ce || n || !a.length || f.x !== a[4] || f.y !== a[5] || !f.rotationX && !f.rotationY) && (void 0 === f.x || "none" !== Q(e, "display", i))) {
                                            var z = a.length >= 6,
                                                G = z ? a[0] : 1,
                                                H = a[1] || 0,
                                                j = a[2] || 0,
                                                W = z ? a[3] : 1;
                                            f.x = a[4] || 0, f.y = a[5] || 0, c = Math.sqrt(G * G + H * H), h = Math.sqrt(W * W + j * j), u = G || H ? Math.atan2(H, G) * F : f.rotation || 0, p = j || W ? Math.atan2(j, W) * F + u : f.skewX || 0, Math.abs(p) > 90 && Math.abs(p) < 270 && (d ? (c *= -1, p += 0 >= u ? 180 : -180, u += 0 >= u ? 180 : -180) : (h *= -1, p += 0 >= p ? 180 : -180)), f.scaleX = c, f.scaleY = h, f.rotation = u, f.skewX = p, Ce && (f.rotationX = f.rotationY = f.z = 0, f.perspective = y, f.scaleZ = 1), f.svg && (f.x -= f.xOrigin - (f.xOrigin * G + f.yOrigin * j), f.y -= f.yOrigin - (f.xOrigin * H + f.yOrigin * W))
                                        }
                                        f.zOrigin = v;
                                        for (l in f) f[l] < m && f[l] > -m && (f[l] = 0)
                                    }
                                    return r && (e._gsTransform = f, f.svg && (Te && e.style[Se] ? t.delayedCall(.001, function() {
                                        Ge(e.style, Se)
                                    }) : !Te && e.getAttribute("transform") && t.delayedCall(.001, function() {
                                        e.removeAttribute("transform")
                                    }))), f
                                },
                                Ue = function(e) {
                                    var t, i, r = this.data,
                                        n = -r.rotation * I,
                                        o = n + r.skewX * I,
                                        a = 1e5,
                                        s = (Math.cos(n) * r.scaleX * a | 0) / a,
                                        l = (Math.sin(n) * r.scaleX * a | 0) / a,
                                        c = (Math.sin(o) * -r.scaleY * a | 0) / a,
                                        h = (Math.cos(o) * r.scaleY * a | 0) / a,
                                        u = this.t.style,
                                        p = this.t.currentStyle;
                                    if (p) {
                                        i = l, l = -c, c = -i, t = p.filter, u.filter = "";
                                        var f, d, m = this.t.offsetWidth,
                                            v = this.t.offsetHeight,
                                            y = "absolute" !== p.position,
                                            _ = "progid:DXImageTransform.Microsoft.Matrix(M11=" + s + ", M12=" + l + ", M21=" + c + ", M22=" + h,
                                            x = r.x + m * r.xPercent / 100,
                                            T = r.y + v * r.yPercent / 100;
                                        if (null != r.ox && (f = (r.oxp ? m * r.ox * .01 : r.ox) - m / 2, d = (r.oyp ? v * r.oy * .01 : r.oy) - v / 2, x += f - (f * s + d * l), T += d - (f * c + d * h)), y ? (f = m / 2, d = v / 2, _ += ", Dx=" + (f - (f * s + d * l) + x) + ", Dy=" + (d - (f * c + d * h) + T) + ")") : _ += ", sizingMethod='auto expand')", -1 !== t.indexOf("DXImageTransform.Microsoft.Matrix(") ? u.filter = t.replace(D, _) : u.filter = _ + " " + t, 0 !== e && 1 !== e || 1 === s && 0 === l && 0 === c && 1 === h && (y && -1 === _.indexOf("Dx=0, Dy=0") || w.test(t) && 100 !== parseFloat(RegExp.$1) || -1 === t.indexOf(t.indexOf("Alpha")) && u.removeAttribute("filter")), !y) {
                                            var M, S, E, A = 8 > g ? 1 : -1;
                                            for (f = r.ieOffsetX || 0, d = r.ieOffsetY || 0, r.ieOffsetX = Math.round((m - ((0 > s ? -s : s) * m + (0 > l ? -l : l) * v)) / 2 + x), r.ieOffsetY = Math.round((v - ((0 > h ? -h : h) * v + (0 > c ? -c : c) * m)) / 2 + T), _e = 0; 4 > _e; _e++) S = ie[_e], M = p[S], i = -1 !== M.indexOf("px") ? parseFloat(M) : K(this.t, S, parseFloat(M), M.replace(b, "")) || 0, E = i !== r[S] ? 2 > _e ? -r.ieOffsetX : -r.ieOffsetY : 2 > _e ? f - r.ieOffsetX : d - r.ieOffsetY, u[S] = (r[S] = Math.round(i - E * (0 === _e || 2 === _e ? 1 : A))) + "px"
                                        }
                                    }
                                },
                                Ve = z.set3DTransformRatio = z.setTransformRatio = function(e) {
                                    var t, i, r, n, o, a, s, l, c, h, u, p, f, m, g, v, y, _, x, b, w, T, M, S = this.data,
                                        E = this.t.style,
                                        A = S.rotation,
                                        C = S.rotationX,
                                        L = S.rotationY,
                                        P = S.scaleX,
                                        R = S.scaleY,
                                        D = S.scaleZ,
                                        O = S.x,
                                        F = S.y,
                                        N = S.z,
                                        B = S.svg,
                                        k = S.perspective,
                                        U = S.force3D;
                                    if (((1 === e || 0 === e) && "auto" === U && (this.tween._totalTime === this.tween._totalDuration || !this.tween._totalTime) || !U) && !N && !k && !L && !C && 1 === D || Te && B || !Ce) return void(A || S.skewX || B ? (A *= I, T = S.skewX * I, M = 1e5, t = Math.cos(A) * P, n = Math.sin(A) * P, i = Math.sin(A - T) * -R, o = Math.cos(A - T) * R, T && "simple" === S.skewType && (y = Math.tan(T), y = Math.sqrt(1 + y * y), i *= y, o *= y, S.skewY && (t *= y, n *= y)), B && (O += S.xOrigin - (S.xOrigin * t + S.yOrigin * i) + S.xOffset, F += S.yOrigin - (S.xOrigin * n + S.yOrigin * o) + S.yOffset, Te && (S.xPercent || S.yPercent) && (m = this.t.getBBox(), O += .01 * S.xPercent * m.width, F += .01 * S.yPercent * m.height), m = 1e-6, m > O && O > -m && (O = 0), m > F && F > -m && (F = 0)), x = (t * M | 0) / M + "," + (n * M | 0) / M + "," + (i * M | 0) / M + "," + (o * M | 0) / M + "," + O + "," + F + ")", B && Te ? this.t.setAttribute("transform", "matrix(" + x) : E[Se] = (S.xPercent || S.yPercent ? "translate(" + S.xPercent + "%," + S.yPercent + "%) matrix(" : "matrix(") + x) : E[Se] = (S.xPercent || S.yPercent ? "translate(" + S.xPercent + "%," + S.yPercent + "%) matrix(" : "matrix(") + P + ",0,0," + R + "," + O + "," + F + ")");
                                    if (d && (m = 1e-4, m > P && P > -m && (P = D = 2e-5), m > R && R > -m && (R = D = 2e-5), !k || S.z || S.rotationX || S.rotationY || (k = 0)), A || S.skewX) A *= I, g = t = Math.cos(A), v = n = Math.sin(A), S.skewX && (A -= S.skewX * I, g = Math.cos(A), v = Math.sin(A), "simple" === S.skewType && (y = Math.tan(S.skewX * I), y = Math.sqrt(1 + y * y), g *= y, v *= y, S.skewY && (t *= y, n *= y))), i = -v, o = g;
                                    else {
                                        if (!(L || C || 1 !== D || k || B)) return void(E[Se] = (S.xPercent || S.yPercent ? "translate(" + S.xPercent + "%," + S.yPercent + "%) translate3d(" : "translate3d(") + O + "px," + F + "px," + N + "px)" + (1 !== P || 1 !== R ? " scale(" + P + "," + R + ")" : ""));
                                        t = o = 1, i = n = 0
                                    }
                                    c = 1, r = a = s = l = h = u = 0, p = k ? -1 / k : 0, f = S.zOrigin, m = 1e-6, b = ",", w = "0", A = L * I, A && (g = Math.cos(A), v = Math.sin(A), s = -v, h = p * -v, r = t * v, a = n * v, c = g, p *= g, t *= g, n *= g), A = C * I, A && (g = Math.cos(A), v = Math.sin(A), y = i * g + r * v, _ = o * g + a * v, l = c * v, u = p * v, r = i * -v + r * g, a = o * -v + a * g, c *= g, p *= g, i = y, o = _), 1 !== D && (r *= D, a *= D, c *= D, p *= D), 1 !== R && (i *= R, o *= R, l *= R, u *= R), 1 !== P && (t *= P, n *= P, s *= P, h *= P), (f || B) && (f && (O += r * -f, F += a * -f, N += c * -f + f), B && (O += S.xOrigin - (S.xOrigin * t + S.yOrigin * i) + S.xOffset, F += S.yOrigin - (S.xOrigin * n + S.yOrigin * o) + S.yOffset), m > O && O > -m && (O = w), m > F && F > -m && (F = w), m > N && N > -m && (N = 0)), x = S.xPercent || S.yPercent ? "translate(" + S.xPercent + "%," + S.yPercent + "%) matrix3d(" : "matrix3d(", x += (m > t && t > -m ? w : t) + b + (m > n && n > -m ? w : n) + b + (m > s && s > -m ? w : s), x += b + (m > h && h > -m ? w : h) + b + (m > i && i > -m ? w : i) + b + (m > o && o > -m ? w : o), C || L || 1 !== D ? (x += b + (m > l && l > -m ? w : l) + b + (m > u && u > -m ? w : u) + b + (m > r && r > -m ? w : r), x += b + (m > a && a > -m ? w : a) + b + (m > c && c > -m ? w : c) + b + (m > p && p > -m ? w : p) + b) : x += ",0,0,0,0,1,0,", x += O + b + F + b + N + b + (k ? 1 + -N / k : 1) + ")", E[Se] = x
                                };
                            h = Le.prototype, h.x = h.y = h.z = h.skewX = h.skewY = h.rotation = h.rotationX = h.rotationY = h.zOrigin = h.xPercent = h.yPercent = h.xOffset = h.yOffset = 0, h.scaleX = h.scaleY = h.scaleZ = 1, be("transform,scale,scaleX,scaleY,scaleZ,x,y,z,rotation,rotationX,rotationY,rotationZ,skewX,skewY,shortRotation,shortRotationX,shortRotationY,shortRotationZ,transformOrigin,svgOrigin,transformPerspective,directionalRotation,parseTransform,force3D,skewType,xPercent,yPercent,smoothOrigin", {
                                parser: function(e, t, i, r, n, a, l) {
                                    if (r._lastParsedTransform === l) return n;
                                    r._lastParsedTransform = l;
                                    var c, h, u, p, f, d, m, g, v, y, _ = e._gsTransform,
                                        x = e.style,
                                        b = 1e-6,
                                        w = Me.length,
                                        T = l,
                                        M = {},
                                        S = "transformOrigin";
                                    if (l.display ? (p = Q(e, "display"), x.display = "block", c = ke(e, o, !0, l.parseTransform), x.display = p) : c = ke(e, o, !0, l.parseTransform), r._transform = c, "string" == typeof T.transform && Se) p = U.style, p[Se] = T.transform, p.display = "block", p.position = "absolute", B.body.appendChild(U), h = ke(U, null, !1), B.body.removeChild(U), h.perspective || (h.perspective = c.perspective), null != T.xPercent && (h.xPercent = ae(T.xPercent, c.xPercent)), null != T.yPercent && (h.yPercent = ae(T.yPercent, c.yPercent));
                                    else if ("object" == typeof T) {
                                        if (h = {
                                                scaleX: ae(null != T.scaleX ? T.scaleX : T.scale, c.scaleX),
                                                scaleY: ae(null != T.scaleY ? T.scaleY : T.scale, c.scaleY),
                                                scaleZ: ae(T.scaleZ, c.scaleZ),
                                                x: ae(T.x, c.x),
                                                y: ae(T.y, c.y),
                                                z: ae(T.z, c.z),
                                                xPercent: ae(T.xPercent, c.xPercent),
                                                yPercent: ae(T.yPercent, c.yPercent),
                                                perspective: ae(T.transformPerspective, c.perspective)
                                            }, g = T.directionalRotation, null != g)
                                            if ("object" == typeof g)
                                                for (p in g) T[p] = g[p];
                                            else T.rotation = g;
                                            "string" == typeof T.x && -1 !== T.x.indexOf("%") && (h.x = 0, h.xPercent = ae(T.x, c.xPercent)), "string" == typeof T.y && -1 !== T.y.indexOf("%") && (h.y = 0, h.yPercent = ae(T.y, c.yPercent)), h.rotation = se("rotation" in T ? T.rotation : "shortRotation" in T ? T.shortRotation + "_short" : "rotationZ" in T ? T.rotationZ : c.rotation, c.rotation, "rotation", M), Ce && (h.rotationX = se("rotationX" in T ? T.rotationX : "shortRotationX" in T ? T.shortRotationX + "_short" : c.rotationX || 0, c.rotationX, "rotationX", M), h.rotationY = se("rotationY" in T ? T.rotationY : "shortRotationY" in T ? T.shortRotationY + "_short" : c.rotationY || 0, c.rotationY, "rotationY", M)), h.skewX = null == T.skewX ? c.skewX : se(T.skewX, c.skewX), h.skewY = null == T.skewY ? c.skewY : se(T.skewY, c.skewY), (u = h.skewY - c.skewY) && (h.skewX += u, h.rotation += u)
                                    }
                                    for (Ce && null != T.force3D && (c.force3D = T.force3D, m = !0), c.skewType = T.skewType || c.skewType || s.defaultSkewType, d = c.force3D || c.z || c.rotationX || c.rotationY || h.z || h.rotationX || h.rotationY || h.perspective, d || null == T.scale || (h.scaleZ = 1); --w > -1;) i = Me[w], f = h[i] - c[i], (f > b || -b > f || null != T[i] || null != N[i]) && (m = !0, n = new ge(c, i, c[i], f, n), i in M && (n.e = M[i]), n.xs0 = 0, n.plugin = a, r._overwriteProps.push(n.n));
                                    return f = T.transformOrigin, c.svg && (f || T.svgOrigin) && (v = c.xOffset, y = c.yOffset, Ie(e, ne(f), h, T.svgOrigin, T.smoothOrigin), n = ve(c, "xOrigin", (_ ? c : h).xOrigin, h.xOrigin, n, S), n = ve(c, "yOrigin", (_ ? c : h).yOrigin, h.yOrigin, n, S), v === c.xOffset && y === c.yOffset || (n = ve(c, "xOffset", _ ? v : c.xOffset, c.xOffset, n, S), n = ve(c, "yOffset", _ ? y : c.yOffset, c.yOffset, n, S)), f = Te ? null : "0px 0px"), (f || Ce && d && c.zOrigin) && (Se ? (m = !0, i = Ae, f = (f || Q(e, i, o, !1, "50% 50%")) + "", n = new ge(x, i, 0, 0, n, -1, S), n.b = x[i], n.plugin = a, Ce ? (p = c.zOrigin, f = f.split(" "), c.zOrigin = (f.length > 2 && (0 === p || "0px" !== f[2]) ? parseFloat(f[2]) : p) || 0, n.xs0 = n.e = f[0] + " " + (f[1] || "50%") + " 0px", n = new ge(c, "zOrigin", 0, 0, n, -1, n.n), n.b = p, n.xs0 = n.e = c.zOrigin) : n.xs0 = n.e = f) : ne(f + "", c)), m && (r._transformType = c.svg && Te || !d && 3 !== this._transformType ? 2 : 3), n
                                },
                                prefix: !0
                            }), be("boxShadow", {
                                defaultValue: "0px 0px 0px 0px #999",
                                prefix: !0,
                                color: !0,
                                multi: !0,
                                keyword: "inset"
                            }), be("borderRadius", {
                                defaultValue: "0px",
                                parser: function(e, t, i, r, a, s) {
                                    t = this.format(t);
                                    var l, c, h, u, p, f, d, m, g, v, y, _, x, b, w, T, M = ["borderTopLeftRadius", "borderTopRightRadius", "borderBottomRightRadius", "borderBottomLeftRadius"],
                                        S = e.style;
                                    for (g = parseFloat(e.offsetWidth), v = parseFloat(e.offsetHeight), l = t.split(" "), c = 0; c < M.length; c++) this.p.indexOf("border") && (M[c] = Y(M[c])), p = u = Q(e, M[c], o, !1, "0px"), -1 !== p.indexOf(" ") && (u = p.split(" "), p = u[0], u = u[1]), f = h = l[c], d = parseFloat(p), _ = p.substr((d + "").length), x = "=" === f.charAt(1), x ? (m = parseInt(f.charAt(0) + "1", 10), f = f.substr(2), m *= parseFloat(f), y = f.substr((m + "").length - (0 > m ? 1 : 0)) || "") : (m = parseFloat(f),
                                        y = f.substr((m + "").length)), "" === y && (y = n[i] || _), y !== _ && (b = K(e, "borderLeft", d, _), w = K(e, "borderTop", d, _), "%" === y ? (p = b / g * 100 + "%", u = w / v * 100 + "%") : "em" === y ? (T = K(e, "borderLeft", 1, "em"), p = b / T + "em", u = w / T + "em") : (p = b + "px", u = w + "px"), x && (f = parseFloat(p) + m + y, h = parseFloat(u) + m + y)), a = ye(S, M[c], p + " " + u, f + " " + h, !1, "0px", a);
                                    return a
                                },
                                prefix: !0,
                                formatter: fe("0px 0px 0px 0px", !1, !0)
                            }), be("backgroundPosition", {
                                defaultValue: "0 0",
                                parser: function(e, t, i, r, n, a) {
                                    var s, l, c, h, u, p, f = "background-position",
                                        d = o || Z(e, null),
                                        m = this.format((d ? g ? d.getPropertyValue(f + "-x") + " " + d.getPropertyValue(f + "-y") : d.getPropertyValue(f) : e.currentStyle.backgroundPositionX + " " + e.currentStyle.backgroundPositionY) || "0 0"),
                                        v = this.format(t);
                                    if (-1 !== m.indexOf("%") != (-1 !== v.indexOf("%")) && (p = Q(e, "backgroundImage").replace(C, ""), p && "none" !== p)) {
                                        for (s = m.split(" "), l = v.split(" "), V.setAttribute("src", p), c = 2; --c > -1;) m = s[c], h = -1 !== m.indexOf("%"), h !== (-1 !== l[c].indexOf("%")) && (u = 0 === c ? e.offsetWidth - V.width : e.offsetHeight - V.height, s[c] = h ? parseFloat(m) / 100 * u + "px" : parseFloat(m) / u * 100 + "%");
                                        m = s.join(" ")
                                    }
                                    return this.parseComplex(e.style, m, v, n, a)
                                },
                                formatter: ne
                            }), be("backgroundSize", {
                                defaultValue: "0 0",
                                formatter: ne
                            }), be("perspective", {
                                defaultValue: "0px",
                                prefix: !0
                            }), be("perspectiveOrigin", {
                                defaultValue: "50% 50%",
                                prefix: !0
                            }), be("transformStyle", {
                                prefix: !0
                            }), be("backfaceVisibility", {
                                prefix: !0
                            }), be("userSelect", {
                                prefix: !0
                            }), be("margin", {
                                parser: de("marginTop,marginRight,marginBottom,marginLeft")
                            }), be("padding", {
                                parser: de("paddingTop,paddingRight,paddingBottom,paddingLeft")
                            }), be("clip", {
                                defaultValue: "rect(0px,0px,0px,0px)",
                                parser: function(e, t, i, r, n, a) {
                                    var s, l, c;
                                    return 9 > g ? (l = e.currentStyle, c = 8 > g ? " " : ",", s = "rect(" + l.clipTop + c + l.clipRight + c + l.clipBottom + c + l.clipLeft + ")", t = this.format(t).split(",").join(c)) : (s = this.format(Q(e, this.p, o, !1, this.dflt)), t = this.format(t)), this.parseComplex(e.style, s, t, n, a)
                                }
                            }), be("textShadow", {
                                defaultValue: "0px 0px 0px #999",
                                color: !0,
                                multi: !0
                            }), be("autoRound,strictUnits", {
                                parser: function(e, t, i, r, n) {
                                    return n
                                }
                            }), be("border", {
                                defaultValue: "0px solid #000",
                                parser: function(e, t, i, r, n, a) {
                                    return this.parseComplex(e.style, this.format(Q(e, "borderTopWidth", o, !1, "0px") + " " + Q(e, "borderTopStyle", o, !1, "solid") + " " + Q(e, "borderTopColor", o, !1, "#000")), this.format(t), n, a)
                                },
                                color: !0,
                                formatter: function(e) {
                                    var t = e.split(" ");
                                    return t[0] + " " + (t[1] || "solid") + " " + (e.match(pe) || ["#000"])[0]
                                }
                            }), be("borderWidth", {
                                parser: de("borderTopWidth,borderRightWidth,borderBottomWidth,borderLeftWidth")
                            }), be("float,cssFloat,styleFloat", {
                                parser: function(e, t, i, r, n, o) {
                                    var a = e.style,
                                        s = "cssFloat" in a ? "cssFloat" : "styleFloat";
                                    return new ge(a, s, 0, 0, n, -1, i, !1, 0, a[s], t)
                                }
                            });
                            var ze = function(e) {
                                var t, i = this.t,
                                    r = i.filter || Q(this.data, "filter") || "",
                                    n = this.s + this.c * e | 0;
                                100 === n && (-1 === r.indexOf("atrix(") && -1 === r.indexOf("radient(") && -1 === r.indexOf("oader(") ? (i.removeAttribute("filter"), t = !Q(this.data, "filter")) : (i.filter = r.replace(M, ""), t = !0)), t || (this.xn1 && (i.filter = r = r || "alpha(opacity=" + n + ")"), -1 === r.indexOf("pacity") ? 0 === n && this.xn1 || (i.filter = r + " alpha(opacity=" + n + ")") : i.filter = r.replace(w, "opacity=" + n))
                            };
                            be("opacity,alpha,autoAlpha", {
                                defaultValue: "1",
                                parser: function(e, t, i, r, n, a) {
                                    var s = parseFloat(Q(e, "opacity", o, !1, "1")),
                                        l = e.style,
                                        c = "autoAlpha" === i;
                                    return "string" == typeof t && "=" === t.charAt(1) && (t = ("-" === t.charAt(0) ? -1 : 1) * parseFloat(t.substr(2)) + s), c && 1 === s && "hidden" === Q(e, "visibility", o) && 0 !== t && (s = 0), H ? n = new ge(l, "opacity", s, t - s, n) : (n = new ge(l, "opacity", 100 * s, 100 * (t - s), n), n.xn1 = c ? 1 : 0, l.zoom = 1, n.type = 2, n.b = "alpha(opacity=" + n.s + ")", n.e = "alpha(opacity=" + (n.s + n.c) + ")", n.data = e, n.plugin = a, n.setRatio = ze), c && (n = new ge(l, "visibility", 0, 0, n, -1, null, !1, 0, 0 !== s ? "inherit" : "hidden", 0 === t ? "hidden" : "inherit"), n.xs0 = "inherit", r._overwriteProps.push(n.n), r._overwriteProps.push(i)), n
                                }
                            });
                            var Ge = function(e, t) {
                                    t && (e.removeProperty ? ("ms" !== t.substr(0, 2) && "webkit" !== t.substr(0, 6) || (t = "-" + t), e.removeProperty(t.replace(E, "-$1").toLowerCase())) : e.removeAttribute(t))
                                },
                                He = function(e) {
                                    if (this.t._gsClassPT = this, 1 === e || 0 === e) {
                                        this.t.setAttribute("class", 0 === e ? this.b : this.e);
                                        for (var t = this.data, i = this.t.style; t;) t.v ? i[t.p] = t.v : Ge(i, t.p), t = t._next;
                                        1 === e && this.t._gsClassPT === this && (this.t._gsClassPT = null)
                                    } else this.t.getAttribute("class") !== this.e && this.t.setAttribute("class", this.e)
                                };
                            be("className", {
                                parser: function(e, t, i, n, a, s, l) {
                                    var c, h, u, p, f, d = e.getAttribute("class") || "",
                                        m = e.style.cssText;
                                    if (a = n._classNamePT = new ge(e, i, 0, 0, a, 2), a.setRatio = He, a.pr = -11, r = !0, a.b = d, h = J(e, o), u = e._gsClassPT) {
                                        for (p = {}, f = u.data; f;) p[f.p] = 1, f = f._next;
                                        u.setRatio(1)
                                    }
                                    return e._gsClassPT = a, a.e = "=" !== t.charAt(1) ? t : d.replace(new RegExp("\\s*\\b" + t.substr(2) + "\\b"), "") + ("+" === t.charAt(0) ? " " + t.substr(2) : ""), e.setAttribute("class", a.e), c = ee(e, h, J(e), l, p), e.setAttribute("class", d), a.data = c.firstMPT, e.style.cssText = m, a = a.xfirst = n.parse(e, c.difs, a, s)
                                }
                            });
                            var je = function(e) {
                                if ((1 === e || 0 === e) && this.data._totalTime === this.data._totalDuration && "isFromStart" !== this.data.data) {
                                    var t, i, r, n, o, a = this.t.style,
                                        s = c.transform.parse;
                                    if ("all" === this.e) a.cssText = "", n = !0;
                                    else
                                        for (t = this.e.split(" ").join("").split(","), r = t.length; --r > -1;) i = t[r], c[i] && (c[i].parse === s ? n = !0 : i = "transformOrigin" === i ? Ae : c[i].p), Ge(a, i);
                                    n && (Ge(a, Se), o = this.t._gsTransform, o && (o.svg && (this.t.removeAttribute("data-svg-origin"), this.t.removeAttribute("transform")), delete this.t._gsTransform))
                                }
                            };
                            for (be("clearProps", {
                                    parser: function(e, t, i, n, o) {
                                        return o = new ge(e, i, 0, 0, o, 2), o.setRatio = je, o.e = t, o.pr = -10, o.data = n._tween, r = !0, o
                                    }
                                }), h = "bezier,throwProps,physicsProps,physics2D".split(","), _e = h.length; _e--;) we(h[_e]);
                            h = s.prototype, h._firstPT = h._lastParsedTransform = h._transform = null, h._onInitTween = function(e, t, i) {
                                if (!e.nodeType) return !1;
                                this._target = e, this._tween = i, this._vars = t, u = t.autoRound, r = !1, n = t.suffixMap || s.suffixMap, o = Z(e, ""), a = this._overwriteProps;
                                var l, h, d, g, v, y, _, x, b, w = e.style;
                                if (p && "" === w.zIndex && (l = Q(e, "zIndex", o), "auto" !== l && "" !== l || this._addLazySet(w, "zIndex", 0)), "string" == typeof t && (g = w.cssText, l = J(e, o), w.cssText = g + ";" + t, l = ee(e, l, J(e)).difs, !H && T.test(t) && (l.opacity = parseFloat(RegExp.$1)), t = l, w.cssText = g), t.className ? this._firstPT = h = c.className.parse(e, t.className, "className", this, null, null, t) : this._firstPT = h = this.parse(e, t, null), this._transformType) {
                                    for (b = 3 === this._transformType, Se ? f && (p = !0, "" === w.zIndex && (_ = Q(e, "zIndex", o), "auto" !== _ && "" !== _ || this._addLazySet(w, "zIndex", 0)), m && this._addLazySet(w, "WebkitBackfaceVisibility", this._vars.WebkitBackfaceVisibility || (b ? "visible" : "hidden"))) : w.zoom = 1, d = h; d && d._next;) d = d._next;
                                    x = new ge(e, "transform", 0, 0, null, 2), this._linkCSSP(x, null, d), x.setRatio = Se ? Ve : Ue, x.data = this._transform || ke(e, o, !0), x.tween = i, x.pr = -1, a.pop()
                                }
                                if (r) {
                                    for (; h;) {
                                        for (y = h._next, d = g; d && d.pr > h.pr;) d = d._next;
                                        (h._prev = d ? d._prev : v) ? h._prev._next = h: g = h, (h._next = d) ? d._prev = h : v = h, h = y
                                    }
                                    this._firstPT = g
                                }
                                return !0
                            }, h.parse = function(e, t, i, r) {
                                var a, s, l, h, p, f, d, m, g, v, y = e.style;
                                for (a in t) f = t[a], s = c[a], s ? i = s.parse(e, f, a, this, i, r, t) : (p = Q(e, a, o) + "", g = "string" == typeof f, "color" === a || "fill" === a || "stroke" === a || -1 !== a.indexOf("Color") || g && S.test(f) ? (g || (f = he(f), f = (f.length > 3 ? "rgba(" : "rgb(") + f.join(",") + ")"), i = ye(y, a, p, f, !0, "transparent", i, 0, r)) : !g || -1 === f.indexOf(" ") && -1 === f.indexOf(",") ? (l = parseFloat(p), d = l || 0 === l ? p.substr((l + "").length) : "", "" !== p && "auto" !== p || ("width" === a || "height" === a ? (l = re(e, a, o), d = "px") : "left" === a || "top" === a ? (l = $(e, a, o), d = "px") : (l = "opacity" !== a ? 0 : 1, d = "")), v = g && "=" === f.charAt(1), v ? (h = parseInt(f.charAt(0) + "1", 10), f = f.substr(2), h *= parseFloat(f), m = f.replace(b, "")) : (h = parseFloat(f), m = g ? f.replace(b, "") : ""), "" === m && (m = a in n ? n[a] : d), f = h || 0 === h ? (v ? h + l : h) + m : t[a], d !== m && "" !== m && (h || 0 === h) && l && (l = K(e, a, l, d), "%" === m ? (l /= K(e, a, 100, "%") / 100, t.strictUnits !== !0 && (p = l + "%")) : "em" === m || "rem" === m || "vw" === m || "vh" === m ? l /= K(e, a, 1, m) : "px" !== m && (h = K(e, a, h, m), m = "px"), v && (h || 0 === h) && (f = h + l + m)), v && (h += l), !l && 0 !== l || !h && 0 !== h ? void 0 !== y[a] && (f || f + "" != "NaN" && null != f) ? (i = new ge(y, a, h || l || 0, 0, i, -1, a, !1, 0, p, f), i.xs0 = "none" !== f || "display" !== a && -1 === a.indexOf("Style") ? f : p) : W("invalid " + a + " tween value: " + t[a]) : (i = new ge(y, a, l, h - l, i, 0, a, u !== !1 && ("px" === m || "zIndex" === a), 0, p, f), i.xs0 = m)) : i = ye(y, a, p, f, !0, null, i, 0, r)), r && i && !i.plugin && (i.plugin = r);
                                return i
                            }, h.setRatio = function(e) {
                                var t, i, r, n = this._firstPT,
                                    o = 1e-6;
                                if (1 !== e || this._tween._time !== this._tween._duration && 0 !== this._tween._time)
                                    if (e || this._tween._time !== this._tween._duration && 0 !== this._tween._time || this._tween._rawPrevTime === -1e-6)
                                        for (; n;) {
                                            if (t = n.c * e + n.s, n.r ? t = Math.round(t) : o > t && t > -o && (t = 0), n.type)
                                                if (1 === n.type)
                                                    if (r = n.l, 2 === r) n.t[n.p] = n.xs0 + t + n.xs1 + n.xn1 + n.xs2;
                                                    else if (3 === r) n.t[n.p] = n.xs0 + t + n.xs1 + n.xn1 + n.xs2 + n.xn2 + n.xs3;
                                            else if (4 === r) n.t[n.p] = n.xs0 + t + n.xs1 + n.xn1 + n.xs2 + n.xn2 + n.xs3 + n.xn3 + n.xs4;
                                            else if (5 === r) n.t[n.p] = n.xs0 + t + n.xs1 + n.xn1 + n.xs2 + n.xn2 + n.xs3 + n.xn3 + n.xs4 + n.xn4 + n.xs5;
                                            else {
                                                for (i = n.xs0 + t + n.xs1, r = 1; r < n.l; r++) i += n["xn" + r] + n["xs" + (r + 1)];
                                                n.t[n.p] = i
                                            } else -1 === n.type ? n.t[n.p] = n.xs0 : n.setRatio && n.setRatio(e);
                                            else n.t[n.p] = t + n.xs0;
                                            n = n._next
                                        } else
                                            for (; n;) 2 !== n.type ? n.t[n.p] = n.b : n.setRatio(e), n = n._next;
                                    else
                                        for (; n;) {
                                            if (2 !== n.type)
                                                if (n.r && -1 !== n.type)
                                                    if (t = Math.round(n.s + n.c), n.type) {
                                                        if (1 === n.type) {
                                                            for (r = n.l, i = n.xs0 + t + n.xs1, r = 1; r < n.l; r++) i += n["xn" + r] + n["xs" + (r + 1)];
                                                            n.t[n.p] = i
                                                        }
                                                    } else n.t[n.p] = t + n.xs0;
                                            else n.t[n.p] = n.e;
                                            else n.setRatio(e);
                                            n = n._next
                                        }
                            }, h._enableTransforms = function(e) {
                                this._transform = this._transform || ke(this._target, o, !0), this._transformType = this._transform.svg && Te || !e && 3 !== this._transformType ? 2 : 3
                            };
                            var We = function(e) {
                                this.t[this.p] = this.e, this.data._linkCSSP(this, this._next, null, !0)
                            };
                            h._addLazySet = function(e, t, i) {
                                var r = this._firstPT = new ge(e, t, 0, 0, this._firstPT, 2);
                                r.e = i, r.setRatio = We, r.data = this
                            }, h._linkCSSP = function(e, t, i, r) {
                                return e && (t && (t._prev = e), e._next && (e._next._prev = e._prev), e._prev ? e._prev._next = e._next : this._firstPT === e && (this._firstPT = e._next, r = !0), i ? i._next = e : r || null !== this._firstPT || (this._firstPT = e), e._next = t, e._prev = i), e
                            }, h._kill = function(t) {
                                var i, r, n, o = t;
                                if (t.autoAlpha || t.alpha) {
                                    o = {};
                                    for (r in t) o[r] = t[r];
                                    o.opacity = 1, o.autoAlpha && (o.visibility = 1)
                                }
                                return t.className && (i = this._classNamePT) && (n = i.xfirst, n && n._prev ? this._linkCSSP(n._prev, i._next, n._prev._prev) : n === this._firstPT && (this._firstPT = i._next), i._next && this._linkCSSP(i._next, i._next._next, n._prev), this._classNamePT = null), e.prototype._kill.call(this, o)
                            };
                            var Xe = function(e, t, i) {
                                var r, n, o, a;
                                if (e.slice)
                                    for (n = e.length; --n > -1;) Xe(e[n], t, i);
                                else
                                    for (r = e.childNodes, n = r.length; --n > -1;) o = r[n], a = o.type, o.style && (t.push(J(o)), i && i.push(o)), 1 !== a && 9 !== a && 11 !== a || !o.childNodes.length || Xe(o, t, i)
                            };
                            return s.cascadeTo = function(e, i, r) {
                                var n, o, a, s, l = t.to(e, i, r),
                                    c = [l],
                                    h = [],
                                    u = [],
                                    p = [],
                                    f = t._internals.reservedProps;
                                for (e = l._targets || l.target, Xe(e, h, p), l.render(i, !0, !0), Xe(e, u), l.render(0, !0, !0), l._enabled(!0), n = p.length; --n > -1;)
                                    if (o = ee(p[n], h[n], u[n]), o.firstMPT) {
                                        o = o.difs;
                                        for (a in r) f[a] && (o[a] = r[a]);
                                        s = {};
                                        for (a in o) s[a] = h[n][a];
                                        c.push(t.fromTo(p[n], i, s, o))
                                    }
                                return c
                            }, e.activate([s]), s
                        }, !0),
                        function() {
                            var e = i._gsDefine.plugin({
                                    propName: "roundProps",
                                    version: "1.5",
                                    priority: -1,
                                    API: 2,
                                    init: function(e, t, i) {
                                        return this._tween = i, !0
                                    }
                                }),
                                t = function(e) {
                                    for (; e;) e.f || e.blob || (e.r = 1), e = e._next
                                },
                                r = e.prototype;
                            r._onInitAllProps = function() {
                                for (var e, i, r, n = this._tween, o = n.vars.roundProps.join ? n.vars.roundProps : n.vars.roundProps.split(","), a = o.length, s = {}, l = n._propLookup.roundProps; --a > -1;) s[o[a]] = 1;
                                for (a = o.length; --a > -1;)
                                    for (e = o[a], i = n._firstPT; i;) r = i._next, i.pg ? i.t._roundProps(s, !0) : i.n === e && (2 === i.f && i.t ? t(i.t._firstPT) : (this._add(i.t, e, i.s, i.c), r && (r._prev = i._prev), i._prev ? i._prev._next = r : n._firstPT === i && (n._firstPT = r), i._next = i._prev = null, n._propLookup[e] = l)), i = r;
                                return !1
                            }, r._add = function(e, t, i, r) {
                                this._addTween(e, t, i, i + r, t, !0), this._overwriteProps.push(t)
                            }
                        }(),
                        function() {
                            i._gsDefine.plugin({
                                propName: "attr",
                                API: 2,
                                version: "0.5.0",
                                init: function(e, t, i) {
                                    var r;
                                    if ("function" != typeof e.setAttribute) return !1;
                                    for (r in t) this._addTween(e, "setAttribute", e.getAttribute(r) + "", t[r] + "", r, !1, r), this._overwriteProps.push(r);
                                    return !0
                                }
                            })
                        }(), i._gsDefine.plugin({
                            propName: "directionalRotation",
                            version: "0.2.1",
                            API: 2,
                            init: function(e, t, i) {
                                "object" != typeof t && (t = {
                                    rotation: t
                                }), this.finals = {};
                                var r, n, o, a, s, l, c = t.useRadians === !0 ? 2 * Math.PI : 360,
                                    h = 1e-6;
                                for (r in t) "useRadians" !== r && (l = (t[r] + "").split("_"), n = l[0], o = parseFloat("function" != typeof e[r] ? e[r] : e[r.indexOf("set") || "function" != typeof e["get" + r.substr(3)] ? r : "get" + r.substr(3)]()), a = this.finals[r] = "string" == typeof n && "=" === n.charAt(1) ? o + parseInt(n.charAt(0) + "1", 10) * Number(n.substr(2)) : Number(n) || 0, s = a - o, l.length && (n = l.join("_"), -1 !== n.indexOf("short") && (s %= c, s !== s % (c / 2) && (s = 0 > s ? s + c : s - c)), -1 !== n.indexOf("_cw") && 0 > s ? s = (s + 9999999999 * c) % c - (s / c | 0) * c : -1 !== n.indexOf("ccw") && s > 0 && (s = (s - 9999999999 * c) % c - (s / c | 0) * c)), (s > h || -h > s) && (this._addTween(e, r, o, o + s, r), this._overwriteProps.push(r)));
                                return !0
                            },
                            set: function(e) {
                                var t;
                                if (1 !== e) this._super.setRatio.call(this, e);
                                else
                                    for (t = this._firstPT; t;) t.f ? t.t[t.p](this.finals[t.p]) : t.t[t.p] = this.finals[t.p], t = t._next
                            }
                        })._autoCSS = !0, i._gsDefine("easing.Back", ["easing.Ease"], function(e) {
                            var t, r, n, o = i.GreenSockGlobals || i,
                                a = o.com.greensock,
                                s = 2 * Math.PI,
                                l = Math.PI / 2,
                                c = a._class,
                                h = function(t, i) {
                                    var r = c("easing." + t, function() {}, !0),
                                        n = r.prototype = new e;
                                    return n.constructor = r, n.getRatio = i, r
                                },
                                u = e.register || function() {},
                                p = function(e, t, i, r, n) {
                                    var o = c("easing." + e, {
                                        easeOut: new t,
                                        easeIn: new i,
                                        easeInOut: new r
                                    }, !0);
                                    return u(o, e), o
                                },
                                f = function(e, t, i) {
                                    this.t = e, this.v = t, i && (this.next = i, i.prev = this, this.c = i.v - t, this.gap = i.t - e)
                                },
                                d = function(t, i) {
                                    var r = c("easing." + t, function(e) {
                                            this._p1 = e || 0 === e ? e : 1.70158, this._p2 = 1.525 * this._p1
                                        }, !0),
                                        n = r.prototype = new e;
                                    return n.constructor = r, n.getRatio = i, n.config = function(e) {
                                        return new r(e)
                                    }, r
                                },
                                m = p("Back", d("BackOut", function(e) {
                                    return (e -= 1) * e * ((this._p1 + 1) * e + this._p1) + 1
                                }), d("BackIn", function(e) {
                                    return e * e * ((this._p1 + 1) * e - this._p1)
                                }), d("BackInOut", function(e) {
                                    return (e *= 2) < 1 ? .5 * e * e * ((this._p2 + 1) * e - this._p2) : .5 * ((e -= 2) * e * ((this._p2 + 1) * e + this._p2) + 2)
                                })),
                                g = c("easing.SlowMo", function(e, t, i) {
                                    t = t || 0 === t ? t : .7, null == e ? e = .7 : e > 1 && (e = 1), this._p = 1 !== e ? t : 0, this._p1 = (1 - e) / 2, this._p2 = e, this._p3 = this._p1 + this._p2, this._calcEnd = i === !0
                                }, !0),
                                v = g.prototype = new e;
                            return v.constructor = g, v.getRatio = function(e) {
                                var t = e + (.5 - e) * this._p;
                                return e < this._p1 ? this._calcEnd ? 1 - (e = 1 - e / this._p1) * e : t - (e = 1 - e / this._p1) * e * e * e * t : e > this._p3 ? this._calcEnd ? 1 - (e = (e - this._p3) / this._p1) * e : t + (e - t) * (e = (e - this._p3) / this._p1) * e * e * e : this._calcEnd ? 1 : t
                            }, g.ease = new g(.7, .7), v.config = g.config = function(e, t, i) {
                                return new g(e, t, i)
                            }, t = c("easing.SteppedEase", function(e) {
                                e = e || 1, this._p1 = 1 / e, this._p2 = e + 1
                            }, !0), v = t.prototype = new e, v.constructor = t, v.getRatio = function(e) {
                                return 0 > e ? e = 0 : e >= 1 && (e = .999999999), (this._p2 * e >> 0) * this._p1
                            }, v.config = t.config = function(e) {
                                return new t(e)
                            }, r = c("easing.RoughEase", function(t) {
                                t = t || {};
                                for (var i, r, n, o, a, s, l = t.taper || "none", c = [], h = 0, u = 0 | (t.points || 20), p = u, d = t.randomize !== !1, m = t.clamp === !0, g = t.template instanceof e ? t.template : null, v = "number" == typeof t.strength ? .4 * t.strength : .4; --p > -1;) i = d ? Math.random() : 1 / u * p, r = g ? g.getRatio(i) : i, "none" === l ? n = v : "out" === l ? (o = 1 - i, n = o * o * v) : "in" === l ? n = i * i * v : .5 > i ? (o = 2 * i, n = o * o * .5 * v) : (o = 2 * (1 - i), n = o * o * .5 * v), d ? r += Math.random() * n - .5 * n : p % 2 ? r += .5 * n : r -= .5 * n, m && (r > 1 ? r = 1 : 0 > r && (r = 0)), c[h++] = {
                                    x: i,
                                    y: r
                                };
                                for (c.sort(function(e, t) {
                                        return e.x - t.x
                                    }), s = new f(1, 1, null), p = u; --p > -1;) a = c[p], s = new f(a.x, a.y, s);
                                this._prev = new f(0, 0, 0 !== s.t ? s : s.next)
                            }, !0), v = r.prototype = new e, v.constructor = r, v.getRatio = function(e) {
                                var t = this._prev;
                                if (e > t.t) {
                                    for (; t.next && e >= t.t;) t = t.next;
                                    t = t.prev
                                } else
                                    for (; t.prev && e <= t.t;) t = t.prev;
                                return this._prev = t, t.v + (e - t.t) / t.gap * t.c
                            }, v.config = function(e) {
                                return new r(e)
                            }, r.ease = new r, p("Bounce", h("BounceOut", function(e) {
                                return 1 / 2.75 > e ? 7.5625 * e * e : 2 / 2.75 > e ? 7.5625 * (e -= 1.5 / 2.75) * e + .75 : 2.5 / 2.75 > e ? 7.5625 * (e -= 2.25 / 2.75) * e + .9375 : 7.5625 * (e -= 2.625 / 2.75) * e + .984375
                            }), h("BounceIn", function(e) {
                                return (e = 1 - e) < 1 / 2.75 ? 1 - 7.5625 * e * e : 2 / 2.75 > e ? 1 - (7.5625 * (e -= 1.5 / 2.75) * e + .75) : 2.5 / 2.75 > e ? 1 - (7.5625 * (e -= 2.25 / 2.75) * e + .9375) : 1 - (7.5625 * (e -= 2.625 / 2.75) * e + .984375)
                            }), h("BounceInOut", function(e) {
                                var t = .5 > e;
                                return e = t ? 1 - 2 * e : 2 * e - 1, e = 1 / 2.75 > e ? 7.5625 * e * e : 2 / 2.75 > e ? 7.5625 * (e -= 1.5 / 2.75) * e + .75 : 2.5 / 2.75 > e ? 7.5625 * (e -= 2.25 / 2.75) * e + .9375 : 7.5625 * (e -= 2.625 / 2.75) * e + .984375, t ? .5 * (1 - e) : .5 * e + .5
                            })), p("Circ", h("CircOut", function(e) {
                                return Math.sqrt(1 - (e -= 1) * e)
                            }), h("CircIn", function(e) {
                                return -(Math.sqrt(1 - e * e) - 1)
                            }), h("CircInOut", function(e) {
                                return (e *= 2) < 1 ? -.5 * (Math.sqrt(1 - e * e) - 1) : .5 * (Math.sqrt(1 - (e -= 2) * e) + 1)
                            })), n = function(t, i, r) {
                                var n = c("easing." + t, function(e, t) {
                                        this._p1 = e >= 1 ? e : 1, this._p2 = (t || r) / (1 > e ? e : 1), this._p3 = this._p2 / s * (Math.asin(1 / this._p1) || 0), this._p2 = s / this._p2
                                    }, !0),
                                    o = n.prototype = new e;
                                return o.constructor = n, o.getRatio = i, o.config = function(e, t) {
                                    return new n(e, t)
                                }, n
                            }, p("Elastic", n("ElasticOut", function(e) {
                                return this._p1 * Math.pow(2, -10 * e) * Math.sin((e - this._p3) * this._p2) + 1
                            }, .3), n("ElasticIn", function(e) {
                                return -(this._p1 * Math.pow(2, 10 * (e -= 1)) * Math.sin((e - this._p3) * this._p2))
                            }, .3), n("ElasticInOut", function(e) {
                                return (e *= 2) < 1 ? -.5 * (this._p1 * Math.pow(2, 10 * (e -= 1)) * Math.sin((e - this._p3) * this._p2)) : this._p1 * Math.pow(2, -10 * (e -= 1)) * Math.sin((e - this._p3) * this._p2) * .5 + 1
                            }, .45)), p("Expo", h("ExpoOut", function(e) {
                                return 1 - Math.pow(2, -10 * e)
                            }), h("ExpoIn", function(e) {
                                return Math.pow(2, 10 * (e - 1)) - .001
                            }), h("ExpoInOut", function(e) {
                                return (e *= 2) < 1 ? .5 * Math.pow(2, 10 * (e - 1)) : .5 * (2 - Math.pow(2, -10 * (e - 1)))
                            })), p("Sine", h("SineOut", function(e) {
                                return Math.sin(e * l)
                            }), h("SineIn", function(e) {
                                return -Math.cos(e * l) + 1
                            }), h("SineInOut", function(e) {
                                return -.5 * (Math.cos(Math.PI * e) - 1)
                            })), c("easing.EaseLookup", {
                                find: function(t) {
                                    return e.map[t]
                                }
                            }, !0), u(o.SlowMo, "SlowMo", "ease,"), u(r, "RoughEase", "ease,"), u(t, "SteppedEase", "ease,"), m
                        }, !0)
                }), i._gsDefine && i._gsQueue.pop()(),
                function(e, i) {
                    "use strict";
                    var r = e.GreenSockGlobals = e.GreenSockGlobals || e;
                    if (!r.TweenLite) {
                        var n, o, a, s, l, c = function(e) {
                                var t, i = e.split("."),
                                    n = r;
                                for (t = 0; t < i.length; t++) n[i[t]] = n = n[i[t]] || {};
                                return n
                            },
                            h = c("com.greensock"),
                            u = 1e-10,
                            p = function(e) {
                                var t, i = [],
                                    r = e.length;
                                for (t = 0; t !== r; i.push(e[t++]));
                                return i
                            },
                            f = function() {},
                            d = function() {
                                var e = Object.prototype.toString,
                                    t = e.call([]);
                                return function(i) {
                                    return null != i && (i instanceof Array || "object" == typeof i && !!i.push && e.call(i) === t)
                                }
                            }(),
                            m = {},
                            g = function(n, o, a, s) {
                                this.sc = m[n] ? m[n].sc : [], m[n] = this, this.gsClass = null, this.func = a;
                                var l = [];
                                this.check = function(h) {
                                    for (var u, p, f, d, v, y = o.length, _ = y; --y > -1;)(u = m[o[y]] || new g(o[y], [])).gsClass ? (l[y] = u.gsClass, _--) : h && u.sc.push(this);
                                    if (0 === _ && a)
                                        for (p = ("com.greensock." + n).split("."), f = p.pop(), d = c(p.join("."))[f] = this.gsClass = a.apply(a, l), s && (r[f] = d, v = "undefined" != typeof t && t.exports, !v && "function" == typeof define && define.amd ? define((e.GreenSockAMDPath ? e.GreenSockAMDPath + "/" : "") + n.split(".").pop(), [], function() {
                                                return d
                                            }) : n === i && v && (t.exports = d)), y = 0; y < this.sc.length; y++) this.sc[y].check()
                                }, this.check(!0)
                            },
                            v = e._gsDefine = function(e, t, i, r) {
                                return new g(e, t, i, r)
                            },
                            y = h._class = function(e, t, i) {
                                return t = t || function() {}, v(e, [], function() {
                                    return t
                                }, i), t
                            };
                        v.globals = r;
                        var _ = [0, 0, 1, 1],
                            x = [],
                            b = y("easing.Ease", function(e, t, i, r) {
                                this._func = e, this._type = i || 0, this._power = r || 0, this._params = t ? _.concat(t) : _
                            }, !0),
                            w = b.map = {},
                            T = b.register = function(e, t, i, r) {
                                for (var n, o, a, s, l = t.split(","), c = l.length, u = (i || "easeIn,easeOut,easeInOut").split(","); --c > -1;)
                                    for (o = l[c], n = r ? y("easing." + o, null, !0) : h.easing[o] || {}, a = u.length; --a > -1;) s = u[a], w[o + "." + s] = w[s + o] = n[s] = e.getRatio ? e : e[s] || new e
                            };
                        for (a = b.prototype, a._calcEnd = !1, a.getRatio = function(e) {
                                if (this._func) return this._params[0] = e, this._func.apply(null, this._params);
                                var t = this._type,
                                    i = this._power,
                                    r = 1 === t ? 1 - e : 2 === t ? e : .5 > e ? 2 * e : 2 * (1 - e);
                                return 1 === i ? r *= r : 2 === i ? r *= r * r : 3 === i ? r *= r * r * r : 4 === i && (r *= r * r * r * r), 1 === t ? 1 - r : 2 === t ? r : .5 > e ? r / 2 : 1 - r / 2
                            }, n = ["Linear", "Quad", "Cubic", "Quart", "Quint,Strong"], o = n.length; --o > -1;) a = n[o] + ",Power" + o, T(new b(null, null, 1, o), a, "easeOut", !0), T(new b(null, null, 2, o), a, "easeIn" + (0 === o ? ",easeNone" : "")), T(new b(null, null, 3, o), a, "easeInOut");
                        w.linear = h.easing.Linear.easeIn, w.swing = h.easing.Quad.easeInOut;
                        var M = y("events.EventDispatcher", function(e) {
                            this._listeners = {}, this._eventTarget = e || this
                        });
                        a = M.prototype, a.addEventListener = function(e, t, i, r, n) {
                            n = n || 0;
                            var o, a, c = this._listeners[e],
                                h = 0;
                            for (null == c && (this._listeners[e] = c = []), a = c.length; --a > -1;) o = c[a], o.c === t && o.s === i ? c.splice(a, 1) : 0 === h && o.pr < n && (h = a + 1);
                            c.splice(h, 0, {
                                c: t,
                                s: i,
                                up: r,
                                pr: n
                            }), this !== s || l || s.wake()
                        }, a.removeEventListener = function(e, t) {
                            var i, r = this._listeners[e];
                            if (r)
                                for (i = r.length; --i > -1;)
                                    if (r[i].c === t) return void r.splice(i, 1)
                        }, a.dispatchEvent = function(e) {
                            var t, i, r, n = this._listeners[e];
                            if (n)
                                for (t = n.length, i = this._eventTarget; --t > -1;) r = n[t], r && (r.up ? r.c.call(r.s || i, {
                                    type: e,
                                    target: i
                                }) : r.c.call(r.s || i))
                        };
                        var S = e.requestAnimationFrame,
                            E = e.cancelAnimationFrame,
                            A = Date.now || function() {
                                return (new Date).getTime()
                            },
                            C = A();
                        for (n = ["ms", "moz", "webkit", "o"], o = n.length; --o > -1 && !S;) S = e[n[o] + "RequestAnimationFrame"], E = e[n[o] + "CancelAnimationFrame"] || e[n[o] + "CancelRequestAnimationFrame"];
                        y("Ticker", function(e, t) {
                            var i, r, n, o, a, c = this,
                                h = A(),
                                p = t !== !1 && S ? "auto" : !1,
                                d = 500,
                                m = 33,
                                g = "tick",
                                v = function(e) {
                                    var t, s, l = A() - C;
                                    l > d && (h += l - m), C += l, c.time = (C - h) / 1e3, t = c.time - a, (!i || t > 0 || e === !0) && (c.frame++, a += t + (t >= o ? .004 : o - t), s = !0), e !== !0 && (n = r(v)), s && c.dispatchEvent(g)
                                };
                            M.call(c), c.time = c.frame = 0, c.tick = function() {
                                v(!0)
                            }, c.lagSmoothing = function(e, t) {
                                d = e || 1 / u, m = Math.min(t, d, 0)
                            }, c.sleep = function() {
                                null != n && (p && E ? E(n) : clearTimeout(n), r = f, n = null, c === s && (l = !1))
                            }, c.wake = function(e) {
                                null !== n ? c.sleep() : e ? h += -C + (C = A()) : c.frame > 10 && (C = A() - d + 5), r = 0 === i ? f : p && S ? S : function(e) {
                                    return setTimeout(e, 1e3 * (a - c.time) + 1 | 0)
                                }, c === s && (l = !0), v(2)
                            }, c.fps = function(e) {
                                return arguments.length ? (i = e, o = 1 / (i || 60), a = this.time + o, void c.wake()) : i
                            }, c.useRAF = function(e) {
                                return arguments.length ? (c.sleep(), p = e, void c.fps(i)) : p
                            }, c.fps(e), setTimeout(function() {
                                "auto" === p && c.frame < 5 && "hidden" !== document.visibilityState && c.useRAF(!1)
                            }, 1500)
                        }), a = h.Ticker.prototype = new h.events.EventDispatcher, a.constructor = h.Ticker;
                        var L = y("core.Animation", function(e, t) {
                            if (this.vars = t = t || {}, this._duration = this._totalDuration = e || 0, this._delay = Number(t.delay) || 0, this._timeScale = 1, this._active = t.immediateRender === !0, this.data = t.data, this._reversed = t.reversed === !0, Y) {
                                l || s.wake();
                                var i = this.vars.useFrames ? q : Y;
                                i.add(this, i._time), this.vars.paused && this.paused(!0)
                            }
                        });
                        s = L.ticker = new h.Ticker, a = L.prototype, a._dirty = a._gc = a._initted = a._paused = !1, a._totalTime = a._time = 0, a._rawPrevTime = -1, a._next = a._last = a._onUpdate = a._timeline = a.timeline = null, a._paused = !1;
                        var P = function() {
                            l && A() - C > 2e3 && s.wake(), setTimeout(P, 2e3)
                        };
                        P(), a.play = function(e, t) {
                            return null != e && this.seek(e, t), this.reversed(!1).paused(!1)
                        }, a.pause = function(e, t) {
                            return null != e && this.seek(e, t), this.paused(!0)
                        }, a.resume = function(e, t) {
                            return null != e && this.seek(e, t), this.paused(!1)
                        }, a.seek = function(e, t) {
                            return this.totalTime(Number(e), t !== !1)
                        }, a.restart = function(e, t) {
                            return this.reversed(!1).paused(!1).totalTime(e ? -this._delay : 0, t !== !1, !0)
                        }, a.reverse = function(e, t) {
                            return null != e && this.seek(e || this.totalDuration(), t), this.reversed(!0).paused(!1)
                        }, a.render = function(e, t, i) {}, a.invalidate = function() {
                            return this._time = this._totalTime = 0, this._initted = this._gc = !1, this._rawPrevTime = -1, !this._gc && this.timeline || this._enabled(!0), this
                        }, a.isActive = function() {
                            var e, t = this._timeline,
                                i = this._startTime;
                            return !t || !this._gc && !this._paused && t.isActive() && (e = t.rawTime()) >= i && e < i + this.totalDuration() / this._timeScale
                        }, a._enabled = function(e, t) {
                            return l || s.wake(), this._gc = !e, this._active = this.isActive(), t !== !0 && (e && !this.timeline ? this._timeline.add(this, this._startTime - this._delay) : !e && this.timeline && this._timeline._remove(this, !0)), !1
                        }, a._kill = function(e, t) {
                            return this._enabled(!1, !1)
                        }, a.kill = function(e, t) {
                            return this._kill(e, t), this
                        }, a._uncache = function(e) {
                            for (var t = e ? this : this.timeline; t;) t._dirty = !0, t = t.timeline;
                            return this
                        }, a._swapSelfInParams = function(e) {
                            for (var t = e.length, i = e.concat(); --t > -1;) "{self}" === e[t] && (i[t] = this);
                            return i
                        }, a._callback = function(e) {
                            var t = this.vars;
                            t[e].apply(t[e + "Scope"] || t.callbackScope || this, t[e + "Params"] || x)
                        }, a.eventCallback = function(e, t, i, r) {
                            if ("on" === (e || "").substr(0, 2)) {
                                var n = this.vars;
                                if (1 === arguments.length) return n[e];
                                null == t ? delete n[e] : (n[e] = t, n[e + "Params"] = d(i) && -1 !== i.join("").indexOf("{self}") ? this._swapSelfInParams(i) : i, n[e + "Scope"] = r), "onUpdate" === e && (this._onUpdate = t)
                            }
                            return this
                        }, a.delay = function(e) {
                            return arguments.length ? (this._timeline.smoothChildTiming && this.startTime(this._startTime + e - this._delay), this._delay = e, this) : this._delay
                        }, a.duration = function(e) {
                            return arguments.length ? (this._duration = this._totalDuration = e, this._uncache(!0), this._timeline.smoothChildTiming && this._time > 0 && this._time < this._duration && 0 !== e && this.totalTime(this._totalTime * (e / this._duration), !0), this) : (this._dirty = !1, this._duration)
                        }, a.totalDuration = function(e) {
                            return this._dirty = !1, arguments.length ? this.duration(e) : this._totalDuration
                        }, a.time = function(e, t) {
                            return arguments.length ? (this._dirty && this.totalDuration(), this.totalTime(e > this._duration ? this._duration : e, t)) : this._time
                        }, a.totalTime = function(e, t, i) {
                            if (l || s.wake(), !arguments.length) return this._totalTime;
                            if (this._timeline) {
                                if (0 > e && !i && (e += this.totalDuration()), this._timeline.smoothChildTiming) {
                                    this._dirty && this.totalDuration();
                                    var r = this._totalDuration,
                                        n = this._timeline;
                                    if (e > r && !i && (e = r), this._startTime = (this._paused ? this._pauseTime : n._time) - (this._reversed ? r - e : e) / this._timeScale, n._dirty || this._uncache(!1), n._timeline)
                                        for (; n._timeline;) n._timeline._time !== (n._startTime + n._totalTime) / n._timeScale && n.totalTime(n._totalTime, !0), n = n._timeline
                                }
                                this._gc && this._enabled(!0, !1), this._totalTime === e && 0 !== this._duration || (F.length && Q(), this.render(e, t, !1), F.length && Q())
                            }
                            return this
                        }, a.progress = a.totalProgress = function(e, t) {
                            var i = this.duration();
                            return arguments.length ? this.totalTime(i * e, t) : i ? this._time / i : this.ratio
                        }, a.startTime = function(e) {
                            return arguments.length ? (e !== this._startTime && (this._startTime = e, this.timeline && this.timeline._sortChildren && this.timeline.add(this, e - this._delay)), this) : this._startTime
                        }, a.endTime = function(e) {
                            return this._startTime + (0 != e ? this.totalDuration() : this.duration()) / this._timeScale
                        }, a.timeScale = function(e) {
                            if (!arguments.length) return this._timeScale;
                            if (e = e || u, this._timeline && this._timeline.smoothChildTiming) {
                                var t = this._pauseTime,
                                    i = t || 0 === t ? t : this._timeline.totalTime();
                                this._startTime = i - (i - this._startTime) * this._timeScale / e
                            }
                            return this._timeScale = e, this._uncache(!1)
                        }, a.reversed = function(e) {
                            return arguments.length ? (e != this._reversed && (this._reversed = e, this.totalTime(this._timeline && !this._timeline.smoothChildTiming ? this.totalDuration() - this._totalTime : this._totalTime, !0)), this) : this._reversed
                        }, a.paused = function(e) {
                            if (!arguments.length) return this._paused;
                            var t, i, r = this._timeline;
                            return e != this._paused && r && (l || e || s.wake(), t = r.rawTime(), i = t - this._pauseTime, !e && r.smoothChildTiming && (this._startTime += i, this._uncache(!1)), this._pauseTime = e ? t : null, this._paused = e, this._active = this.isActive(), !e && 0 !== i && this._initted && this.duration() && (t = r.smoothChildTiming ? this._totalTime : (t - this._startTime) / this._timeScale, this.render(t, t === this._totalTime, !0))), this._gc && !e && this._enabled(!0, !1), this
                        };
                        var R = y("core.SimpleTimeline", function(e) {
                            L.call(this, 0, e), this.autoRemoveChildren = this.smoothChildTiming = !0
                        });
                        a = R.prototype = new L, a.constructor = R, a.kill()._gc = !1, a._first = a._last = a._recent = null, a._sortChildren = !1, a.add = a.insert = function(e, t, i, r) {
                            var n, o;
                            if (e._startTime = Number(t || 0) + e._delay, e._paused && this !== e._timeline && (e._pauseTime = e._startTime + (this.rawTime() - e._startTime) / e._timeScale), e.timeline && e.timeline._remove(e, !0), e.timeline = e._timeline = this, e._gc && e._enabled(!0, !0), n = this._last, this._sortChildren)
                                for (o = e._startTime; n && n._startTime > o;) n = n._prev;
                            return n ? (e._next = n._next, n._next = e) : (e._next = this._first, this._first = e), e._next ? e._next._prev = e : this._last = e, e._prev = n, this._recent = e, this._timeline && this._uncache(!0), this
                        }, a._remove = function(e, t) {
                            return e.timeline === this && (t || e._enabled(!1, !0), e._prev ? e._prev._next = e._next : this._first === e && (this._first = e._next), e._next ? e._next._prev = e._prev : this._last === e && (this._last = e._prev), e._next = e._prev = e.timeline = null, e === this._recent && (this._recent = this._last), this._timeline && this._uncache(!0)), this
                        }, a.render = function(e, t, i) {
                            var r, n = this._first;
                            for (this._totalTime = this._time = this._rawPrevTime = e; n;) r = n._next, (n._active || e >= n._startTime && !n._paused) && (n._reversed ? n.render((n._dirty ? n.totalDuration() : n._totalDuration) - (e - n._startTime) * n._timeScale, t, i) : n.render((e - n._startTime) * n._timeScale, t, i)), n = r
                        }, a.rawTime = function() {
                            return l || s.wake(), this._totalTime
                        };
                        var D = y("TweenLite", function(t, i, r) {
                                if (L.call(this, i, r), this.render = D.prototype.render, null == t) throw "Cannot tween a null target.";
                                this.target = t = "string" != typeof t ? t : D.selector(t) || t;
                                var n, o, a, s = t.jquery || t.length && t !== e && t[0] && (t[0] === e || t[0].nodeType && t[0].style && !t.nodeType),
                                    l = this.vars.overwrite;
                                if (this._overwrite = l = null == l ? X[D.defaultOverwrite] : "number" == typeof l ? l >> 0 : X[l], (s || t instanceof Array || t.push && d(t)) && "number" != typeof t[0])
                                    for (this._targets = a = p(t), this._propLookup = [], this._siblings = [], n = 0; n < a.length; n++) o = a[n], o ? "string" != typeof o ? o.length && o !== e && o[0] && (o[0] === e || o[0].nodeType && o[0].style && !o.nodeType) ? (a.splice(n--, 1), this._targets = a = a.concat(p(o))) : (this._siblings[n] = K(o, this, !1), 1 === l && this._siblings[n].length > 1 && J(o, this, null, 1, this._siblings[n])) : (o = a[n--] = D.selector(o), "string" == typeof o && a.splice(n + 1, 1)) : a.splice(n--, 1);
                                else this._propLookup = {}, this._siblings = K(t, this, !1), 1 === l && this._siblings.length > 1 && J(t, this, null, 1, this._siblings);
                                (this.vars.immediateRender || 0 === i && 0 === this._delay && this.vars.immediateRender !== !1) && (this._time = -u, this.render(-this._delay))
                            }, !0),
                            O = function(t) {
                                return t && t.length && t !== e && t[0] && (t[0] === e || t[0].nodeType && t[0].style && !t.nodeType)
                            },
                            I = function(e, t) {
                                var i, r = {};
                                for (i in e) W[i] || i in t && "transform" !== i && "x" !== i && "y" !== i && "width" !== i && "height" !== i && "className" !== i && "border" !== i || !(!G[i] || G[i] && G[i]._autoCSS) || (r[i] = e[i], delete e[i]);
                                e.css = r
                            };
                        a = D.prototype = new L, a.constructor = D, a.kill()._gc = !1, a.ratio = 0, a._firstPT = a._targets = a._overwrittenProps = a._startAt = null, a._notifyPluginsOfEnabled = a._lazy = !1, D.version = "1.18.2", D.defaultEase = a._ease = new b(null, null, 1, 1), D.defaultOverwrite = "auto", D.ticker = s, D.autoSleep = 120, D.lagSmoothing = function(e, t) {
                            s.lagSmoothing(e, t)
                        }, D.selector = e.$ || e.jQuery || function(t) {
                            var i = e.$ || e.jQuery;
                            return i ? (D.selector = i, i(t)) : "undefined" == typeof document ? t : document.querySelectorAll ? document.querySelectorAll(t) : document.getElementById("#" === t.charAt(0) ? t.substr(1) : t)
                        };
                        var F = [],
                            N = {},
                            B = /(?:(-|-=|\+=)?\d*\.?\d*(?:e[\-+]?\d+)?)[0-9]/gi,
                            k = function(e) {
                                for (var t, i = this._firstPT, r = 1e-6; i;) t = i.blob ? e ? this.join("") : this.start : i.c * e + i.s, i.r ? t = Math.round(t) : r > t && t > -r && (t = 0), i.f ? i.fp ? i.t[i.p](i.fp, t) : i.t[i.p](t) : i.t[i.p] = t, i = i._next
                            },
                            U = function(e, t, i, r) {
                                var n, o, a, s, l, c, h, u = [e, t],
                                    p = 0,
                                    f = "",
                                    d = 0;
                                for (u.start = e, i && (i(u), e = u[0], t = u[1]), u.length = 0, n = e.match(B) || [], o = t.match(B) || [], r && (r._next = null, r.blob = 1, u._firstPT = r), l = o.length, s = 0; l > s; s++) h = o[s], c = t.substr(p, t.indexOf(h, p) - p), f += c || !s ? c : ",", p += c.length, d ? d = (d + 1) % 5 : "rgba(" === c.substr(-5) && (d = 1), h === n[s] || n.length <= s ? f += h : (f && (u.push(f), f = ""), a = parseFloat(n[s]), u.push(a), u._firstPT = {
                                    _next: u._firstPT,
                                    t: u,
                                    p: u.length - 1,
                                    s: a,
                                    c: ("=" === h.charAt(1) ? parseInt(h.charAt(0) + "1", 10) * parseFloat(h.substr(2)) : parseFloat(h) - a) || 0,
                                    f: 0,
                                    r: d && 4 > d
                                }), p += h.length;
                                return f += t.substr(p), f && u.push(f), u.setRatio = k, u
                            },
                            V = function(e, t, i, r, n, o, a, s) {
                                var l, c, h = "get" === i ? e[t] : i,
                                    u = typeof e[t],
                                    p = "string" == typeof r && "=" === r.charAt(1),
                                    f = {
                                        t: e,
                                        p: t,
                                        s: h,
                                        f: "function" === u,
                                        pg: 0,
                                        n: n || t,
                                        r: o,
                                        pr: 0,
                                        c: p ? parseInt(r.charAt(0) + "1", 10) * parseFloat(r.substr(2)) : parseFloat(r) - h || 0
                                    };
                                return "number" !== u && ("function" === u && "get" === i && (c = t.indexOf("set") || "function" != typeof e["get" + t.substr(3)] ? t : "get" + t.substr(3), f.s = h = a ? e[c](a) : e[c]()), "string" == typeof h && (a || isNaN(h)) ? (f.fp = a, l = U(h, r, s || D.defaultStringFilter, f), f = {
                                    t: l,
                                    p: "setRatio",
                                    s: 0,
                                    c: 1,
                                    f: 2,
                                    pg: 0,
                                    n: n || t,
                                    pr: 0
                                }) : p || (f.s = parseFloat(h), f.c = parseFloat(r) - f.s || 0)), f.c ? ((f._next = this._firstPT) && (f._next._prev = f), this._firstPT = f, f) : void 0
                            },
                            z = D._internals = {
                                isArray: d,
                                isSelector: O,
                                lazyTweens: F,
                                blobDif: U
                            },
                            G = D._plugins = {},
                            H = z.tweenLookup = {},
                            j = 0,
                            W = z.reservedProps = {
                                ease: 1,
                                delay: 1,
                                overwrite: 1,
                                onComplete: 1,
                                onCompleteParams: 1,
                                onCompleteScope: 1,
                                useFrames: 1,
                                runBackwards: 1,
                                startAt: 1,
                                onUpdate: 1,
                                onUpdateParams: 1,
                                onUpdateScope: 1,
                                onStart: 1,
                                onStartParams: 1,
                                onStartScope: 1,
                                onReverseComplete: 1,
                                onReverseCompleteParams: 1,
                                onReverseCompleteScope: 1,
                                onRepeat: 1,
                                onRepeatParams: 1,
                                onRepeatScope: 1,
                                easeParams: 1,
                                yoyo: 1,
                                immediateRender: 1,
                                repeat: 1,
                                repeatDelay: 1,
                                data: 1,
                                paused: 1,
                                reversed: 1,
                                autoCSS: 1,
                                lazy: 1,
                                onOverwrite: 1,
                                callbackScope: 1,
                                stringFilter: 1
                            },
                            X = {
                                none: 0,
                                all: 1,
                                auto: 2,
                                concurrent: 3,
                                allOnStart: 4,
                                preexisting: 5,
                                "true": 1,
                                "false": 0
                            },
                            q = L._rootFramesTimeline = new R,
                            Y = L._rootTimeline = new R,
                            Z = 30,
                            Q = z.lazyRender = function() {
                                var e, t = F.length;
                                for (N = {}; --t > -1;) e = F[t], e && e._lazy !== !1 && (e.render(e._lazy[0], e._lazy[1], !0), e._lazy = !1);
                                F.length = 0
                            };
                        Y._startTime = s.time, q._startTime = s.frame, Y._active = q._active = !0, setTimeout(Q, 1), L._updateRoot = D.render = function() {
                            var e, t, i;
                            if (F.length && Q(), Y.render((s.time - Y._startTime) * Y._timeScale, !1, !1), q.render((s.frame - q._startTime) * q._timeScale, !1, !1), F.length && Q(), s.frame >= Z) {
                                Z = s.frame + (parseInt(D.autoSleep, 10) || 120);
                                for (i in H) {
                                    for (t = H[i].tweens, e = t.length; --e > -1;) t[e]._gc && t.splice(e, 1);
                                    0 === t.length && delete H[i]
                                }
                                if (i = Y._first, (!i || i._paused) && D.autoSleep && !q._first && 1 === s._listeners.tick.length) {
                                    for (; i && i._paused;) i = i._next;
                                    i || s.sleep()
                                }
                            }
                        }, s.addEventListener("tick", L._updateRoot);
                        var K = function(e, t, i) {
                                var r, n, o = e._gsTweenID;
                                if (H[o || (e._gsTweenID = o = "t" + j++)] || (H[o] = {
                                        target: e,
                                        tweens: []
                                    }), t && (r = H[o].tweens, r[n = r.length] = t, i))
                                    for (; --n > -1;) r[n] === t && r.splice(n, 1);
                                return H[o].tweens
                            },
                            $ = function(e, t, i, r) {
                                var n, o, a = e.vars.onOverwrite;
                                return a && (n = a(e, t, i, r)), a = D.onOverwrite, a && (o = a(e, t, i, r)), n !== !1 && o !== !1
                            },
                            J = function(e, t, i, r, n) {
                                var o, a, s, l;
                                if (1 === r || r >= 4) {
                                    for (l = n.length, o = 0; l > o; o++)
                                        if ((s = n[o]) !== t) s._gc || s._kill(null, e, t) && (a = !0);
                                        else if (5 === r) break;
                                    return a
                                }
                                var c, h = t._startTime + u,
                                    p = [],
                                    f = 0,
                                    d = 0 === t._duration;
                                for (o = n.length; --o > -1;)(s = n[o]) === t || s._gc || s._paused || (s._timeline !== t._timeline ? (c = c || ee(t, 0, d), 0 === ee(s, c, d) && (p[f++] = s)) : s._startTime <= h && s._startTime + s.totalDuration() / s._timeScale > h && ((d || !s._initted) && h - s._startTime <= 2e-10 || (p[f++] = s)));
                                for (o = f; --o > -1;)
                                    if (s = p[o], 2 === r && s._kill(i, e, t) && (a = !0), 2 !== r || !s._firstPT && s._initted) {
                                        if (2 !== r && !$(s, t)) continue;
                                        s._enabled(!1, !1) && (a = !0)
                                    }
                                return a
                            },
                            ee = function(e, t, i) {
                                for (var r = e._timeline, n = r._timeScale, o = e._startTime; r._timeline;) {
                                    if (o += r._startTime, n *= r._timeScale, r._paused) return -100;
                                    r = r._timeline
                                }
                                return o /= n, o > t ? o - t : i && o === t || !e._initted && 2 * u > o - t ? u : (o += e.totalDuration() / e._timeScale / n) > t + u ? 0 : o - t - u
                            };
                        a._init = function() {
                            var e, t, i, r, n, o = this.vars,
                                a = this._overwrittenProps,
                                s = this._duration,
                                l = !!o.immediateRender,
                                c = o.ease;
                            if (o.startAt) {
                                this._startAt && (this._startAt.render(-1, !0), this._startAt.kill()), n = {};
                                for (r in o.startAt) n[r] = o.startAt[r];
                                if (n.overwrite = !1, n.immediateRender = !0, n.lazy = l && o.lazy !== !1, n.startAt = n.delay = null, this._startAt = D.to(this.target, 0, n), l)
                                    if (this._time > 0) this._startAt = null;
                                    else if (0 !== s) return
                            } else if (o.runBackwards && 0 !== s)
                                if (this._startAt) this._startAt.render(-1, !0), this._startAt.kill(), this._startAt = null;
                                else {
                                    0 !== this._time && (l = !1), i = {};
                                    for (r in o) W[r] && "autoCSS" !== r || (i[r] = o[r]);
                                    if (i.overwrite = 0, i.data = "isFromStart", i.lazy = l && o.lazy !== !1, i.immediateRender = l, this._startAt = D.to(this.target, 0, i), l) {
                                        if (0 === this._time) return
                                    } else this._startAt._init(), this._startAt._enabled(!1), this.vars.immediateRender && (this._startAt = null)
                                }
                            if (this._ease = c = c ? c instanceof b ? c : "function" == typeof c ? new b(c, o.easeParams) : w[c] || D.defaultEase : D.defaultEase, o.easeParams instanceof Array && c.config && (this._ease = c.config.apply(c, o.easeParams)), this._easeType = this._ease._type, this._easePower = this._ease._power, this._firstPT = null, this._targets)
                                for (e = this._targets.length; --e > -1;) this._initProps(this._targets[e], this._propLookup[e] = {}, this._siblings[e], a ? a[e] : null) && (t = !0);
                            else t = this._initProps(this.target, this._propLookup, this._siblings, a);
                            if (t && D._onPluginEvent("_onInitAllProps", this), a && (this._firstPT || "function" != typeof this.target && this._enabled(!1, !1)), o.runBackwards)
                                for (i = this._firstPT; i;) i.s += i.c, i.c = -i.c, i = i._next;
                            this._onUpdate = o.onUpdate, this._initted = !0
                        }, a._initProps = function(t, i, r, n) {
                            var o, a, s, l, c, h;
                            if (null == t) return !1;
                            N[t._gsTweenID] && Q(), this.vars.css || t.style && t !== e && t.nodeType && G.css && this.vars.autoCSS !== !1 && I(this.vars, t);
                            for (o in this.vars)
                                if (h = this.vars[o], W[o]) h && (h instanceof Array || h.push && d(h)) && -1 !== h.join("").indexOf("{self}") && (this.vars[o] = h = this._swapSelfInParams(h, this));
                                else if (G[o] && (l = new G[o])._onInitTween(t, this.vars[o], this)) {
                                for (this._firstPT = c = {
                                        _next: this._firstPT,
                                        t: l,
                                        p: "setRatio",
                                        s: 0,
                                        c: 1,
                                        f: 1,
                                        n: o,
                                        pg: 1,
                                        pr: l._priority
                                    }, a = l._overwriteProps.length; --a > -1;) i[l._overwriteProps[a]] = this._firstPT;
                                (l._priority || l._onInitAllProps) && (s = !0), (l._onDisable || l._onEnable) && (this._notifyPluginsOfEnabled = !0), c._next && (c._next._prev = c)
                            } else i[o] = V.call(this, t, o, "get", h, o, 0, null, this.vars.stringFilter);
                            return n && this._kill(n, t) ? this._initProps(t, i, r, n) : this._overwrite > 1 && this._firstPT && r.length > 1 && J(t, this, i, this._overwrite, r) ? (this._kill(i, t), this._initProps(t, i, r, n)) : (this._firstPT && (this.vars.lazy !== !1 && this._duration || this.vars.lazy && !this._duration) && (N[t._gsTweenID] = !0), s)
                        }, a.render = function(e, t, i) {
                            var r, n, o, a, s = this._time,
                                l = this._duration,
                                c = this._rawPrevTime;
                            if (e >= l - 1e-7) this._totalTime = this._time = l, this.ratio = this._ease._calcEnd ? this._ease.getRatio(1) : 1, this._reversed || (r = !0, n = "onComplete", i = i || this._timeline.autoRemoveChildren), 0 === l && (this._initted || !this.vars.lazy || i) && (this._startTime === this._timeline._duration && (e = 0), (0 > c || 0 >= e && e >= -1e-7 || c === u && "isPause" !== this.data) && c !== e && (i = !0, c > u && (n = "onReverseComplete")), this._rawPrevTime = a = !t || e || c === e ? e : u);
                            else if (1e-7 > e) this._totalTime = this._time = 0, this.ratio = this._ease._calcEnd ? this._ease.getRatio(0) : 0, (0 !== s || 0 === l && c > 0) && (n = "onReverseComplete", r = this._reversed), 0 > e && (this._active = !1, 0 === l && (this._initted || !this.vars.lazy || i) && (c >= 0 && (c !== u || "isPause" !== this.data) && (i = !0), this._rawPrevTime = a = !t || e || c === e ? e : u)), this._initted || (i = !0);
                            else if (this._totalTime = this._time = e, this._easeType) {
                                var h = e / l,
                                    p = this._easeType,
                                    f = this._easePower;
                                (1 === p || 3 === p && h >= .5) && (h = 1 - h), 3 === p && (h *= 2), 1 === f ? h *= h : 2 === f ? h *= h * h : 3 === f ? h *= h * h * h : 4 === f && (h *= h * h * h * h), 1 === p ? this.ratio = 1 - h : 2 === p ? this.ratio = h : .5 > e / l ? this.ratio = h / 2 : this.ratio = 1 - h / 2
                            } else this.ratio = this._ease.getRatio(e / l);
                            if (this._time !== s || i) {
                                if (!this._initted) {
                                    if (this._init(), !this._initted || this._gc) return;
                                    if (!i && this._firstPT && (this.vars.lazy !== !1 && this._duration || this.vars.lazy && !this._duration)) return this._time = this._totalTime = s, this._rawPrevTime = c, F.push(this), void(this._lazy = [e, t]);
                                    this._time && !r ? this.ratio = this._ease.getRatio(this._time / l) : r && this._ease._calcEnd && (this.ratio = this._ease.getRatio(0 === this._time ? 0 : 1))
                                }
                                for (this._lazy !== !1 && (this._lazy = !1), this._active || !this._paused && this._time !== s && e >= 0 && (this._active = !0), 0 === s && (this._startAt && (e >= 0 ? this._startAt.render(e, t, i) : n || (n = "_dummyGS")), this.vars.onStart && (0 === this._time && 0 !== l || t || this._callback("onStart"))), o = this._firstPT; o;) o.f ? o.t[o.p](o.c * this.ratio + o.s) : o.t[o.p] = o.c * this.ratio + o.s, o = o._next;
                                this._onUpdate && (0 > e && this._startAt && e !== -1e-4 && this._startAt.render(e, t, i), t || (this._time !== s || r) && this._callback("onUpdate")), n && (this._gc && !i || (0 > e && this._startAt && !this._onUpdate && e !== -1e-4 && this._startAt.render(e, t, i), r && (this._timeline.autoRemoveChildren && this._enabled(!1, !1), this._active = !1), !t && this.vars[n] && this._callback(n), 0 === l && this._rawPrevTime === u && a !== u && (this._rawPrevTime = 0)))
                            }
                        }, a._kill = function(e, t, i) {
                            if ("all" === e && (e = null), null == e && (null == t || t === this.target)) return this._lazy = !1, this._enabled(!1, !1);
                            t = "string" != typeof t ? t || this._targets || this.target : D.selector(t) || t;
                            var r, n, o, a, s, l, c, h, u, p = i && this._time && i._startTime === this._startTime && this._timeline === i._timeline;
                            if ((d(t) || O(t)) && "number" != typeof t[0])
                                for (r = t.length; --r > -1;) this._kill(e, t[r], i) && (l = !0);
                            else {
                                if (this._targets) {
                                    for (r = this._targets.length; --r > -1;)
                                        if (t === this._targets[r]) {
                                            s = this._propLookup[r] || {}, this._overwrittenProps = this._overwrittenProps || [], n = this._overwrittenProps[r] = e ? this._overwrittenProps[r] || {} : "all";
                                            break
                                        }
                                } else {
                                    if (t !== this.target) return !1;
                                    s = this._propLookup, n = this._overwrittenProps = e ? this._overwrittenProps || {} : "all"
                                }
                                if (s) {
                                    if (c = e || s, h = e !== n && "all" !== n && e !== s && ("object" != typeof e || !e._tempKill), i && (D.onOverwrite || this.vars.onOverwrite)) {
                                        for (o in c) s[o] && (u || (u = []), u.push(o));
                                        if ((u || !e) && !$(this, i, t, u)) return !1
                                    }
                                    for (o in c)(a = s[o]) && (p && (a.f ? a.t[a.p](a.s) : a.t[a.p] = a.s, l = !0), a.pg && a.t._kill(c) && (l = !0), a.pg && 0 !== a.t._overwriteProps.length || (a._prev ? a._prev._next = a._next : a === this._firstPT && (this._firstPT = a._next), a._next && (a._next._prev = a._prev), a._next = a._prev = null), delete s[o]), h && (n[o] = 1);
                                    !this._firstPT && this._initted && this._enabled(!1, !1)
                                }
                            }
                            return l
                        }, a.invalidate = function() {
                            return this._notifyPluginsOfEnabled && D._onPluginEvent("_onDisable", this), this._firstPT = this._overwrittenProps = this._startAt = this._onUpdate = null, this._notifyPluginsOfEnabled = this._active = this._lazy = !1, this._propLookup = this._targets ? {} : [], L.prototype.invalidate.call(this), this.vars.immediateRender && (this._time = -u, this.render(-this._delay)), this
                        }, a._enabled = function(e, t) {
                            if (l || s.wake(), e && this._gc) {
                                var i, r = this._targets;
                                if (r)
                                    for (i = r.length; --i > -1;) this._siblings[i] = K(r[i], this, !0);
                                else this._siblings = K(this.target, this, !0)
                            }
                            return L.prototype._enabled.call(this, e, t), this._notifyPluginsOfEnabled && this._firstPT ? D._onPluginEvent(e ? "_onEnable" : "_onDisable", this) : !1
                        }, D.to = function(e, t, i) {
                            return new D(e, t, i)
                        }, D.from = function(e, t, i) {
                            return i.runBackwards = !0, i.immediateRender = 0 != i.immediateRender, new D(e, t, i)
                        }, D.fromTo = function(e, t, i, r) {
                            return r.startAt = i, r.immediateRender = 0 != r.immediateRender && 0 != i.immediateRender, new D(e, t, r)
                        }, D.delayedCall = function(e, t, i, r, n) {
                            return new D(t, 0, {
                                delay: e,
                                onComplete: t,
                                onCompleteParams: i,
                                callbackScope: r,
                                onReverseComplete: t,
                                onReverseCompleteParams: i,
                                immediateRender: !1,
                                lazy: !1,
                                useFrames: n,
                                overwrite: 0
                            })
                        }, D.set = function(e, t) {
                            return new D(e, 0, t)
                        }, D.getTweensOf = function(e, t) {
                            if (null == e) return [];
                            e = "string" != typeof e ? e : D.selector(e) || e;
                            var i, r, n, o;
                            if ((d(e) || O(e)) && "number" != typeof e[0]) {
                                for (i = e.length, r = []; --i > -1;) r = r.concat(D.getTweensOf(e[i], t));
                                for (i = r.length; --i > -1;)
                                    for (o = r[i], n = i; --n > -1;) o === r[n] && r.splice(i, 1)
                            } else
                                for (r = K(e).concat(), i = r.length; --i > -1;)(r[i]._gc || t && !r[i].isActive()) && r.splice(i, 1);
                            return r
                        }, D.killTweensOf = D.killDelayedCallsTo = function(e, t, i) {
                            "object" == typeof t && (i = t, t = !1);
                            for (var r = D.getTweensOf(e, t), n = r.length; --n > -1;) r[n]._kill(i, e)
                        };
                        var te = y("plugins.TweenPlugin", function(e, t) {
                            this._overwriteProps = (e || "").split(","), this._propName = this._overwriteProps[0], this._priority = t || 0, this._super = te.prototype
                        }, !0);
                        if (a = te.prototype, te.version = "1.18.0", te.API = 2, a._firstPT = null, a._addTween = V, a.setRatio = k, a._kill = function(e) {
                                var t, i = this._overwriteProps,
                                    r = this._firstPT;
                                if (null != e[this._propName]) this._overwriteProps = [];
                                else
                                    for (t = i.length; --t > -1;) null != e[i[t]] && i.splice(t, 1);
                                for (; r;) null != e[r.n] && (r._next && (r._next._prev = r._prev), r._prev ? (r._prev._next = r._next, r._prev = null) : this._firstPT === r && (this._firstPT = r._next)), r = r._next;
                                return !1
                            }, a._roundProps = function(e, t) {
                                for (var i = this._firstPT; i;)(e[this._propName] || null != i.n && e[i.n.split(this._propName + "_").join("")]) && (i.r = t), i = i._next
                            }, D._onPluginEvent = function(e, t) {
                                var i, r, n, o, a, s = t._firstPT;
                                if ("_onInitAllProps" === e) {
                                    for (; s;) {
                                        for (a = s._next, r = n; r && r.pr > s.pr;) r = r._next;
                                        (s._prev = r ? r._prev : o) ? s._prev._next = s: n = s, (s._next = r) ? r._prev = s : o = s, s = a
                                    }
                                    s = t._firstPT = n
                                }
                                for (; s;) s.pg && "function" == typeof s.t[e] && s.t[e]() && (i = !0), s = s._next;
                                return i
                            }, te.activate = function(e) {
                                for (var t = e.length; --t > -1;) e[t].API === te.API && (G[(new e[t])._propName] = e[t]);
                                return !0
                            }, v.plugin = function(e) {
                                if (!(e && e.propName && e.init && e.API)) throw "illegal plugin definition.";
                                var t, i = e.propName,
                                    r = e.priority || 0,
                                    n = e.overwriteProps,
                                    o = {
                                        init: "_onInitTween",
                                        set: "setRatio",
                                        kill: "_kill",
                                        round: "_roundProps",
                                        initAll: "_onInitAllProps"
                                    },
                                    a = y("plugins." + i.charAt(0).toUpperCase() + i.substr(1) + "Plugin", function() {
                                        te.call(this, i, r), this._overwriteProps = n || []
                                    }, e.global === !0),
                                    s = a.prototype = new te(i);
                                s.constructor = a, a.API = e.API;
                                for (t in o) "function" == typeof e[t] && (s[o[t]] = e[t]);
                                return a.version = e.version, te.activate([a]), a
                            }, n = e._gsQueue) {
                            for (o = 0; o < n.length; o++) n[o]();
                            for (a in m) m[a].func || e.console.log("GSAP encountered missing dependency: com.greensock." + a)
                        }
                        l = !1
                    }
                }("undefined" != typeof t && t.exports && "undefined" != typeof e ? e : this || window, "TweenMax")
        }).call(this, "undefined" != typeof global ? global : "undefined" != typeof self ? self : "undefined" != typeof window ? window : {})
    }, {}],
    2: [function(e, t, i) {
        (function(e) {
            var i = "undefined" != typeof t && t.exports && "undefined" != typeof e ? e : this || window;
            (i._gsQueue || (i._gsQueue = [])).push(function() {
                "use strict";
                i._gsDefine.plugin({
                    propName: "attr",
                    API: 2,
                    version: "0.5.0",
                    init: function(e, t, i) {
                        var r;
                        if ("function" != typeof e.setAttribute) return !1;
                        for (r in t) this._addTween(e, "setAttribute", e.getAttribute(r) + "", t[r] + "", r, !1, r), this._overwriteProps.push(r);
                        return !0
                    }
                })
            }), i._gsDefine && i._gsQueue.pop()()
        }).call(this, "undefined" != typeof global ? global : "undefined" != typeof self ? self : "undefined" != typeof window ? window : {})
    }, {}],
    3: [function(e, t, i) {
        ! function(e, i, r, n) {
            "use strict";

            function o(e, t, i) {
                return setTimeout(h(e, i), t)
            }

            function a(e, t, i) {
                return Array.isArray(e) ? (s(e, i[t], i), !0) : !1
            }

            function s(e, t, i) {
                var r;
                if (e)
                    if (e.forEach) e.forEach(t, i);
                    else if (e.length !== n)
                    for (r = 0; r < e.length;) t.call(i, e[r], r, e), r++;
                else
                    for (r in e) e.hasOwnProperty(r) && t.call(i, e[r], r, e)
            }

            function l(t, i, r) {
                var n = "DEPRECATED METHOD: " + i + "\n" + r + " AT \n";
                return function() {
                    var i = new Error("get-stack-trace"),
                        r = i && i.stack ? i.stack.replace(/^[^\(]+?[\n$]/gm, "").replace(/^\s+at\s+/gm, "").replace(/^Object.<anonymous>\s*\(/gm, "{anonymous}()@") : "Unknown Stack Trace",
                        o = e.console && (e.console.warn || e.console.log);
                    return o && o.call(e.console, n, r), t.apply(this, arguments)
                }
            }

            function c(e, t, i) {
                var r, n = t.prototype;
                r = e.prototype = Object.create(n), r.constructor = e, r._super = n, i && le(r, i)
            }

            function h(e, t) {
                return function() {
                    return e.apply(t, arguments)
                }
            }

            function u(e, t) {
                return typeof e == ue ? e.apply(t ? t[0] || n : n, t) : e
            }

            function p(e, t) {
                return e === n ? t : e
            }

            function f(e, t, i) {
                s(v(t), function(t) {
                    e.addEventListener(t, i, !1)
                })
            }

            function d(e, t, i) {
                s(v(t), function(t) {
                    e.removeEventListener(t, i, !1)
                })
            }

            function m(e, t) {
                for (; e;) {
                    if (e == t) return !0;
                    e = e.parentNode
                }
                return !1
            }

            function g(e, t) {
                return e.indexOf(t) > -1
            }

            function v(e) {
                return e.trim().split(/\s+/g)
            }

            function y(e, t, i) {
                if (e.indexOf && !i) return e.indexOf(t);
                for (var r = 0; r < e.length;) {
                    if (i && e[r][i] == t || !i && e[r] === t) return r;
                    r++
                }
                return -1
            }

            function _(e) {
                return Array.prototype.slice.call(e, 0)
            }

            function x(e, t, i) {
                for (var r = [], n = [], o = 0; o < e.length;) {
                    var a = t ? e[o][t] : e[o];
                    y(n, a) < 0 && r.push(e[o]), n[o] = a, o++
                }
                return i && (r = t ? r.sort(function(e, i) {
                    return e[t] > i[t]
                }) : r.sort()), r
            }

            function b(e, t) {
                for (var i, r, o = t[0].toUpperCase() + t.slice(1), a = 0; a < ce.length;) {
                    if (i = ce[a], r = i ? i + o : t, r in e) return r;
                    a++
                }
                return n
            }

            function w() {
                return ve++
            }

            function T(t) {
                var i = t.ownerDocument || t;
                return i.defaultView || i.parentWindow || e
            }

            function M(e, t) {
                var i = this;
                this.manager = e, this.callback = t, this.element = e.element, this.target = e.options.inputTarget, this.domHandler = function(t) {
                    u(e.options.enable, [e]) && i.handler(t)
                }, this.init()
            }

            function S(e) {
                var t, i = e.options.inputClass;
                return new(t = i ? i : xe ? U : be ? G : _e ? j : k)(e, E)
            }

            function E(e, t, i) {
                var r = i.pointers.length,
                    n = i.changedPointers.length,
                    o = t & Ae && r - n === 0,
                    a = t & (Le | Pe) && r - n === 0;
                i.isFirst = !!o, i.isFinal = !!a, o && (e.session = {}), i.eventType = t, A(e, i), e.emit("hammer.input", i), e.recognize(i), e.session.prevInput = i
            }

            function A(e, t) {
                var i = e.session,
                    r = t.pointers,
                    n = r.length;
                i.firstInput || (i.firstInput = P(t)), n > 1 && !i.firstMultiple ? i.firstMultiple = P(t) : 1 === n && (i.firstMultiple = !1);
                var o = i.firstInput,
                    a = i.firstMultiple,
                    s = a ? a.center : o.center,
                    l = t.center = R(r);
                t.timeStamp = de(), t.deltaTime = t.timeStamp - o.timeStamp, t.angle = F(s, l), t.distance = I(s, l), C(i, t), t.offsetDirection = O(t.deltaX, t.deltaY);
                var c = D(t.deltaTime, t.deltaX, t.deltaY);
                t.overallVelocityX = c.x, t.overallVelocityY = c.y, t.overallVelocity = fe(c.x) > fe(c.y) ? c.x : c.y, t.scale = a ? B(a.pointers, r) : 1, t.rotation = a ? N(a.pointers, r) : 0, t.maxPointers = i.prevInput ? t.pointers.length > i.prevInput.maxPointers ? t.pointers.length : i.prevInput.maxPointers : t.pointers.length, L(i, t);
                var h = e.element;
                m(t.srcEvent.target, h) && (h = t.srcEvent.target), t.target = h
            }

            function C(e, t) {
                var i = t.center,
                    r = e.offsetDelta || {},
                    n = e.prevDelta || {},
                    o = e.prevInput || {};
                t.eventType !== Ae && o.eventType !== Le || (n = e.prevDelta = {
                    x: o.deltaX || 0,
                    y: o.deltaY || 0
                }, r = e.offsetDelta = {
                    x: i.x,
                    y: i.y
                }), t.deltaX = n.x + (i.x - r.x), t.deltaY = n.y + (i.y - r.y)
            }

            function L(e, t) {
                var i, r, o, a, s = e.lastInterval || t,
                    l = t.timeStamp - s.timeStamp;
                if (t.eventType != Pe && (l > Ee || s.velocity === n)) {
                    var c = t.deltaX - s.deltaX,
                        h = t.deltaY - s.deltaY,
                        u = D(l, c, h);
                    r = u.x, o = u.y, i = fe(u.x) > fe(u.y) ? u.x : u.y, a = O(c, h), e.lastInterval = t
                } else i = s.velocity, r = s.velocityX, o = s.velocityY, a = s.direction;
                t.velocity = i, t.velocityX = r, t.velocityY = o, t.direction = a
            }

            function P(e) {
                for (var t = [], i = 0; i < e.pointers.length;) t[i] = {
                    clientX: pe(e.pointers[i].clientX),
                    clientY: pe(e.pointers[i].clientY)
                }, i++;
                return {
                    timeStamp: de(),
                    pointers: t,
                    center: R(t),
                    deltaX: e.deltaX,
                    deltaY: e.deltaY
                }
            }

            function R(e) {
                var t = e.length;
                if (1 === t) return {
                    x: pe(e[0].clientX),
                    y: pe(e[0].clientY)
                };
                for (var i = 0, r = 0, n = 0; t > n;) i += e[n].clientX, r += e[n].clientY, n++;
                return {
                    x: pe(i / t),
                    y: pe(r / t)
                }
            }

            function D(e, t, i) {
                return {
                    x: t / e || 0,
                    y: i / e || 0
                }
            }

            function O(e, t) {
                return e === t ? Re : fe(e) >= fe(t) ? 0 > e ? De : Oe : 0 > t ? Ie : Fe
            }

            function I(e, t, i) {
                i || (i = Ue);
                var r = t[i[0]] - e[i[0]],
                    n = t[i[1]] - e[i[1]];
                return Math.sqrt(r * r + n * n)
            }

            function F(e, t, i) {
                i || (i = Ue);
                var r = t[i[0]] - e[i[0]],
                    n = t[i[1]] - e[i[1]];
                return 180 * Math.atan2(n, r) / Math.PI
            }

            function N(e, t) {
                return F(t[1], t[0], Ve) + F(e[1], e[0], Ve)
            }

            function B(e, t) {
                return I(t[0], t[1], Ve) / I(e[0], e[1], Ve)
            }

            function k() {
                this.evEl = Ge, this.evWin = He, this.allow = !0, this.pressed = !1, M.apply(this, arguments)
            }

            function U() {
                this.evEl = Xe, this.evWin = qe, M.apply(this, arguments), this.store = this.manager.session.pointerEvents = []
            }

            function V() {
                this.evTarget = Ze, this.evWin = Qe, this.started = !1, M.apply(this, arguments)
            }

            function z(e, t) {
                var i = _(e.touches),
                    r = _(e.changedTouches);
                return t & (Le | Pe) && (i = x(i.concat(r), "identifier", !0)), [i, r]
            }

            function G() {
                this.evTarget = $e, this.targetIds = {}, M.apply(this, arguments)
            }

            function H(e, t) {
                var i = _(e.touches),
                    r = this.targetIds;
                if (t & (Ae | Ce) && 1 === i.length) return r[i[0].identifier] = !0, [i, i];
                var n, o, a = _(e.changedTouches),
                    s = [],
                    l = this.target;
                if (o = i.filter(function(e) {
                        return m(e.target, l)
                    }), t === Ae)
                    for (n = 0; n < o.length;) r[o[n].identifier] = !0, n++;
                for (n = 0; n < a.length;) r[a[n].identifier] && s.push(a[n]), t & (Le | Pe) && delete r[a[n].identifier], n++;
                return s.length ? [x(o.concat(s), "identifier", !0), s] : void 0
            }

            function j() {
                M.apply(this, arguments);
                var e = h(this.handler, this);
                this.touch = new G(this.manager, e), this.mouse = new k(this.manager, e)
            }

            function W(e, t) {
                this.manager = e, this.set(t)
            }

            function X(e) {
                if (g(e, nt)) return nt;
                var t = g(e, ot),
                    i = g(e, at);
                return t && i ? nt : t || i ? t ? ot : at : g(e, rt) ? rt : it
            }

            function q(e) {
                this.options = le({}, this.defaults, e || {}), this.id = w(), this.manager = null, this.options.enable = p(this.options.enable, !0), this.state = st, this.simultaneous = {}, this.requireFail = []
            }

            function Y(e) {
                return e & pt ? "cancel" : e & ht ? "end" : e & ct ? "move" : e & lt ? "start" : ""
            }

            function Z(e) {
                return e == Fe ? "down" : e == Ie ? "up" : e == De ? "left" : e == Oe ? "right" : ""
            }

            function Q(e, t) {
                var i = t.manager;
                return i ? i.get(e) : e
            }

            function K() {
                q.apply(this, arguments)
            }

            function $() {
                K.apply(this, arguments), this.pX = null, this.pY = null
            }

            function J() {
                K.apply(this, arguments)
            }

            function ee() {
                q.apply(this, arguments), this._timer = null, this._input = null
            }

            function te() {
                K.apply(this, arguments)
            }

            function ie() {
                K.apply(this, arguments)
            }

            function re() {
                q.apply(this, arguments), this.pTime = !1, this.pCenter = !1, this._timer = null, this._input = null, this.count = 0
            }

            function ne(e, t) {
                return t = t || {}, t.recognizers = p(t.recognizers, ne.defaults.preset), new oe(e, t)
            }

            function oe(e, t) {
                this.options = le({}, ne.defaults, t || {}), this.options.inputTarget = this.options.inputTarget || e, this.handlers = {}, this.session = {}, this.recognizers = [], this.element = e, this.input = S(this), this.touchAction = new W(this, this.options.touchAction), ae(this, !0), s(this.options.recognizers, function(e) {
                    var t = this.add(new e[0](e[1]));
                    e[2] && t.recognizeWith(e[2]), e[3] && t.requireFailure(e[3])
                }, this)
            }

            function ae(e, t) {
                var i = e.element;
                i.style && s(e.options.cssProps, function(e, r) {
                    i.style[b(i.style, r)] = t ? e : ""
                })
            }

            function se(e, t) {
                var r = i.createEvent("Event");
                r.initEvent(e, !0, !0), r.gesture = t, t.target.dispatchEvent(r)
            }
            var le, ce = ["", "webkit", "Moz", "MS", "ms", "o"],
                he = i.createElement("div"),
                ue = "function",
                pe = Math.round,
                fe = Math.abs,
                de = Date.now;
            le = "function" != typeof Object.assign ? function(e) {
                if (e === n || null === e) throw new TypeError("Cannot convert undefined or null to object");
                for (var t = Object(e), i = 1; i < arguments.length; i++) {
                    var r = arguments[i];
                    if (r !== n && null !== r)
                        for (var o in r) r.hasOwnProperty(o) && (t[o] = r[o])
                }
                return t
            } : Object.assign;
            var me = l(function(e, t, i) {
                    for (var r = Object.keys(t), o = 0; o < r.length;)(!i || i && e[r[o]] === n) && (e[r[o]] = t[r[o]]), o++;
                    return e
                }, "extend", "Use `assign`."),
                ge = l(function(e, t) {
                    return me(e, t, !0)
                }, "merge", "Use `assign`."),
                ve = 1,
                ye = /mobile|tablet|ip(ad|hone|od)|android/i,
                _e = "ontouchstart" in e,
                xe = b(e, "PointerEvent") !== n,
                be = _e && ye.test(navigator.userAgent),
                we = "touch",
                Te = "pen",
                Me = "mouse",
                Se = "kinect",
                Ee = 25,
                Ae = 1,
                Ce = 2,
                Le = 4,
                Pe = 8,
                Re = 1,
                De = 2,
                Oe = 4,
                Ie = 8,
                Fe = 16,
                Ne = De | Oe,
                Be = Ie | Fe,
                ke = Ne | Be,
                Ue = ["x", "y"],
                Ve = ["clientX", "clientY"];
            M.prototype = {
                handler: function() {},
                init: function() {
                    this.evEl && f(this.element, this.evEl, this.domHandler), this.evTarget && f(this.target, this.evTarget, this.domHandler), this.evWin && f(T(this.element), this.evWin, this.domHandler)
                },
                destroy: function() {
                    this.evEl && d(this.element, this.evEl, this.domHandler), this.evTarget && d(this.target, this.evTarget, this.domHandler), this.evWin && d(T(this.element), this.evWin, this.domHandler)
                }
            };
            var ze = {
                    mousedown: Ae,
                    mousemove: Ce,
                    mouseup: Le
                },
                Ge = "mousedown",
                He = "mousemove mouseup";
            c(k, M, {
                handler: function(e) {
                    var t = ze[e.type];
                    t & Ae && 0 === e.button && (this.pressed = !0), t & Ce && 1 !== e.which && (t = Le), this.pressed && this.allow && (t & Le && (this.pressed = !1), this.callback(this.manager, t, {
                        pointers: [e],
                        changedPointers: [e],
                        pointerType: Me,
                        srcEvent: e
                    }))
                }
            });
            var je = {
                    pointerdown: Ae,
                    pointermove: Ce,
                    pointerup: Le,
                    pointercancel: Pe,
                    pointerout: Pe
                },
                We = {
                    2: we,
                    3: Te,
                    4: Me,
                    5: Se
                },
                Xe = "pointerdown",
                qe = "pointermove pointerup pointercancel";
            e.MSPointerEvent && !e.PointerEvent && (Xe = "MSPointerDown", qe = "MSPointerMove MSPointerUp MSPointerCancel"), c(U, M, {
                handler: function(e) {
                    var t = this.store,
                        i = !1,
                        r = e.type.toLowerCase().replace("ms", ""),
                        n = je[r],
                        o = We[e.pointerType] || e.pointerType,
                        a = o == we,
                        s = y(t, e.pointerId, "pointerId");
                    n & Ae && (0 === e.button || a) ? 0 > s && (t.push(e), s = t.length - 1) : n & (Le | Pe) && (i = !0), 0 > s || (t[s] = e, this.callback(this.manager, n, {
                        pointers: t,
                        changedPointers: [e],
                        pointerType: o,
                        srcEvent: e
                    }), i && t.splice(s, 1))
                }
            });
            var Ye = {
                    touchstart: Ae,
                    touchmove: Ce,
                    touchend: Le,
                    touchcancel: Pe
                },
                Ze = "touchstart",
                Qe = "touchstart touchmove touchend touchcancel";
            c(V, M, {
                handler: function(e) {
                    var t = Ye[e.type];
                    if (t === Ae && (this.started = !0), this.started) {
                        var i = z.call(this, e, t);
                        t & (Le | Pe) && i[0].length - i[1].length === 0 && (this.started = !1), this.callback(this.manager, t, {
                            pointers: i[0],
                            changedPointers: i[1],
                            pointerType: we,
                            srcEvent: e
                        })
                    }
                }
            });
            var Ke = {
                    touchstart: Ae,
                    touchmove: Ce,
                    touchend: Le,
                    touchcancel: Pe
                },
                $e = "touchstart touchmove touchend touchcancel";
            c(G, M, {
                handler: function(e) {
                    var t = Ke[e.type],
                        i = H.call(this, e, t);
                    i && this.callback(this.manager, t, {
                        pointers: i[0],
                        changedPointers: i[1],
                        pointerType: we,
                        srcEvent: e
                    })
                }
            }), c(j, M, {
                handler: function(e, t, i) {
                    var r = i.pointerType == we,
                        n = i.pointerType == Me;
                    if (r) this.mouse.allow = !1;
                    else if (n && !this.mouse.allow) return;
                    t & (Le | Pe) && (this.mouse.allow = !0), this.callback(e, t, i)
                },
                destroy: function() {
                    this.touch.destroy(), this.mouse.destroy()
                }
            });
            var Je = b(he.style, "touchAction"),
                et = Je !== n,
                tt = "compute",
                it = "auto",
                rt = "manipulation",
                nt = "none",
                ot = "pan-x",
                at = "pan-y";
            W.prototype = {
                set: function(e) {
                    e == tt && (e = this.compute()), et && this.manager.element.style && (this.manager.element.style[Je] = e), this.actions = e.toLowerCase().trim()
                },
                update: function() {
                    this.set(this.manager.options.touchAction)
                },
                compute: function() {
                    var e = [];
                    return s(this.manager.recognizers, function(t) {
                        u(t.options.enable, [t]) && (e = e.concat(t.getTouchAction()))
                    }), X(e.join(" "))
                },
                preventDefaults: function(e) {
                    if (!et) {
                        var t = e.srcEvent,
                            i = e.offsetDirection;
                        if (this.manager.session.prevented) return void t.preventDefault();
                        var r = this.actions,
                            n = g(r, nt),
                            o = g(r, at),
                            a = g(r, ot);
                        if (n) {
                            var s = 1 === e.pointers.length,
                                l = e.distance < 2,
                                c = e.deltaTime < 250;
                            if (s && l && c) return
                        }
                        if (!a || !o) return n || o && i & Ne || a && i & Be ? this.preventSrc(t) : void 0
                    }
                },
                preventSrc: function(e) {
                    this.manager.session.prevented = !0, e.preventDefault()
                }
            };
            var st = 1,
                lt = 2,
                ct = 4,
                ht = 8,
                ut = ht,
                pt = 16,
                ft = 32;
            q.prototype = {
                defaults: {},
                set: function(e) {
                    return le(this.options, e), this.manager && this.manager.touchAction.update(), this
                },
                recognizeWith: function(e) {
                    if (a(e, "recognizeWith", this)) return this;
                    var t = this.simultaneous;
                    return e = Q(e, this), t[e.id] || (t[e.id] = e, e.recognizeWith(this)), this
                },
                dropRecognizeWith: function(e) {
                    return a(e, "dropRecognizeWith", this) ? this : (e = Q(e, this), delete this.simultaneous[e.id], this)
                },
                requireFailure: function(e) {
                    if (a(e, "requireFailure", this)) return this;
                    var t = this.requireFail;
                    return e = Q(e, this), -1 === y(t, e) && (t.push(e), e.requireFailure(this)), this
                },
                dropRequireFailure: function(e) {
                    if (a(e, "dropRequireFailure", this)) return this;
                    e = Q(e, this);
                    var t = y(this.requireFail, e);
                    return t > -1 && this.requireFail.splice(t, 1), this
                },
                hasRequireFailures: function() {
                    return this.requireFail.length > 0
                },
                canRecognizeWith: function(e) {
                    return !!this.simultaneous[e.id]
                },
                emit: function(e) {
                    function t(t) {
                        i.manager.emit(t, e)
                    }
                    var i = this,
                        r = this.state;
                    ht > r && t(i.options.event + Y(r)), t(i.options.event), e.additionalEvent && t(e.additionalEvent), r >= ht && t(i.options.event + Y(r))
                },
                tryEmit: function(e) {
                    return this.canEmit() ? this.emit(e) : void(this.state = ft)
                },
                canEmit: function() {
                    for (var e = 0; e < this.requireFail.length;) {
                        if (!(this.requireFail[e].state & (ft | st))) return !1;
                        e++
                    }
                    return !0
                },
                recognize: function(e) {
                    var t = le({}, e);
                    return u(this.options.enable, [this, t]) ? (this.state & (ut | pt | ft) && (this.state = st), this.state = this.process(t), void(this.state & (lt | ct | ht | pt) && this.tryEmit(t))) : (this.reset(), void(this.state = ft))
                },
                process: function(e) {},
                getTouchAction: function() {},
                reset: function() {}
            }, c(K, q, {
                defaults: {
                    pointers: 1
                },
                attrTest: function(e) {
                    var t = this.options.pointers;
                    return 0 === t || e.pointers.length === t
                },
                process: function(e) {
                    var t = this.state,
                        i = e.eventType,
                        r = t & (lt | ct),
                        n = this.attrTest(e);
                    return r && (i & Pe || !n) ? t | pt : r || n ? i & Le ? t | ht : t & lt ? t | ct : lt : ft
                }
            }), c($, K, {
                defaults: {
                    event: "pan",
                    threshold: 10,
                    pointers: 1,
                    direction: ke
                },
                getTouchAction: function() {
                    var e = this.options.direction,
                        t = [];
                    return e & Ne && t.push(at), e & Be && t.push(ot), t
                },
                directionTest: function(e) {
                    var t = this.options,
                        i = !0,
                        r = e.distance,
                        n = e.direction,
                        o = e.deltaX,
                        a = e.deltaY;
                    return n & t.direction || (t.direction & Ne ? (n = 0 === o ? Re : 0 > o ? De : Oe, i = o != this.pX, r = Math.abs(e.deltaX)) : (n = 0 === a ? Re : 0 > a ? Ie : Fe, i = a != this.pY, r = Math.abs(e.deltaY))), e.direction = n, i && r > t.threshold && n & t.direction
                },
                attrTest: function(e) {
                    return K.prototype.attrTest.call(this, e) && (this.state & lt || !(this.state & lt) && this.directionTest(e))
                },
                emit: function(e) {
                    this.pX = e.deltaX, this.pY = e.deltaY;
                    var t = Z(e.direction);
                    t && (e.additionalEvent = this.options.event + t), this._super.emit.call(this, e)
                }
            }), c(J, K, {
                defaults: {
                    event: "pinch",
                    threshold: 0,
                    pointers: 2
                },
                getTouchAction: function() {
                    return [nt]
                },
                attrTest: function(e) {
                    return this._super.attrTest.call(this, e) && (Math.abs(e.scale - 1) > this.options.threshold || this.state & lt)
                },
                emit: function(e) {
                    if (1 !== e.scale) {
                        var t = e.scale < 1 ? "in" : "out";
                        e.additionalEvent = this.options.event + t
                    }
                    this._super.emit.call(this, e)
                }
            }), c(ee, q, {
                defaults: {
                    event: "press",
                    pointers: 1,
                    time: 251,
                    threshold: 9
                },
                getTouchAction: function() {
                    return [it]
                },
                process: function(e) {
                    var t = this.options,
                        i = e.pointers.length === t.pointers,
                        r = e.distance < t.threshold,
                        n = e.deltaTime > t.time;
                    if (this._input = e, !r || !i || e.eventType & (Le | Pe) && !n) this.reset();
                    else if (e.eventType & Ae) this.reset(), this._timer = o(function() {
                        this.state = ut, this.tryEmit()
                    }, t.time, this);
                    else if (e.eventType & Le) return ut;
                    return ft
                },
                reset: function() {
                    clearTimeout(this._timer)
                },
                emit: function(e) {
                    this.state === ut && (e && e.eventType & Le ? this.manager.emit(this.options.event + "up", e) : (this._input.timeStamp = de(), this.manager.emit(this.options.event, this._input)))
                }
            }), c(te, K, {
                defaults: {
                    event: "rotate",
                    threshold: 0,
                    pointers: 2
                },
                getTouchAction: function() {
                    return [nt]
                },
                attrTest: function(e) {
                    return this._super.attrTest.call(this, e) && (Math.abs(e.rotation) > this.options.threshold || this.state & lt)
                }
            }), c(ie, K, {
                defaults: {
                    event: "swipe",
                    threshold: 10,
                    velocity: .3,
                    direction: Ne | Be,
                    pointers: 1
                },
                getTouchAction: function() {
                    return $.prototype.getTouchAction.call(this)
                },
                attrTest: function(e) {
                    var t, i = this.options.direction;
                    return i & (Ne | Be) ? t = e.overallVelocity : i & Ne ? t = e.overallVelocityX : i & Be && (t = e.overallVelocityY), this._super.attrTest.call(this, e) && i & e.offsetDirection && e.distance > this.options.threshold && e.maxPointers == this.options.pointers && fe(t) > this.options.velocity && e.eventType & Le
                },
                emit: function(e) {
                    var t = Z(e.offsetDirection);
                    t && this.manager.emit(this.options.event + t, e), this.manager.emit(this.options.event, e)
                }
            }), c(re, q, {
                defaults: {
                    event: "tap",
                    pointers: 1,
                    taps: 1,
                    interval: 300,
                    time: 250,
                    threshold: 9,
                    posThreshold: 10
                },
                getTouchAction: function() {
                    return [rt]
                },
                process: function(e) {
                    var t = this.options,
                        i = e.pointers.length === t.pointers,
                        r = e.distance < t.threshold,
                        n = e.deltaTime < t.time;
                    if (this.reset(), e.eventType & Ae && 0 === this.count) return this.failTimeout();
                    if (r && n && i) {
                        if (e.eventType != Le) return this.failTimeout();
                        var a = this.pTime ? e.timeStamp - this.pTime < t.interval : !0,
                            s = !this.pCenter || I(this.pCenter, e.center) < t.posThreshold;
                        this.pTime = e.timeStamp, this.pCenter = e.center, s && a ? this.count += 1 : this.count = 1, this._input = e;
                        var l = this.count % t.taps;
                        if (0 === l) return this.hasRequireFailures() ? (this._timer = o(function() {
                            this.state = ut, this.tryEmit()
                        }, t.interval, this), lt) : ut
                    }
                    return ft
                },
                failTimeout: function() {
                    return this._timer = o(function() {
                        this.state = ft
                    }, this.options.interval, this), ft
                },
                reset: function() {
                    clearTimeout(this._timer)
                },
                emit: function() {
                    this.state == ut && (this._input.tapCount = this.count, this.manager.emit(this.options.event, this._input))
                }
            }), ne.VERSION = "2.0.6", ne.defaults = {
                domEvents: !1,
                touchAction: tt,
                enable: !0,
                inputTarget: null,
                inputClass: null,
                preset: [
                    [te, {
                        enable: !1
                    }],
                    [J, {
                            enable: !1
                        },
                        ["rotate"]
                    ],
                    [ie, {
                        direction: Ne
                    }],
                    [$, {
                            direction: Ne
                        },
                        ["swipe"]
                    ],
                    [re],
                    [re, {
                            event: "doubletap",
                            taps: 2
                        },
                        ["tap"]
                    ],
                    [ee]
                ],
                cssProps: {
                    userSelect: "none",
                    touchSelect: "none",
                    touchCallout: "none",
                    contentZooming: "none",
                    userDrag: "none",
                    tapHighlightColor: "rgba(0,0,0,0)"
                }
            };
            var dt = 1,
                mt = 2;
            oe.prototype = {
                set: function(e) {
                    return le(this.options, e), e.touchAction && this.touchAction.update(), e.inputTarget && (this.input.destroy(), this.input.target = e.inputTarget, this.input.init()), this
                },
                stop: function(e) {
                    this.session.stopped = e ? mt : dt
                },
                recognize: function(e) {
                    var t = this.session;
                    if (!t.stopped) {
                        this.touchAction.preventDefaults(e);
                        var i, r = this.recognizers,
                            n = t.curRecognizer;
                        (!n || n && n.state & ut) && (n = t.curRecognizer = null);
                        for (var o = 0; o < r.length;) i = r[o], t.stopped === mt || n && i != n && !i.canRecognizeWith(n) ? i.reset() : i.recognize(e), !n && i.state & (lt | ct | ht) && (n = t.curRecognizer = i), o++
                    }
                },
                get: function(e) {
                    if (e instanceof q) return e;
                    for (var t = this.recognizers, i = 0; i < t.length; i++)
                        if (t[i].options.event == e) return t[i];
                    return null
                },
                add: function(e) {
                    if (a(e, "add", this)) return this;
                    var t = this.get(e.options.event);
                    return t && this.remove(t), this.recognizers.push(e), e.manager = this, this.touchAction.update(), e
                },
                remove: function(e) {
                    if (a(e, "remove", this)) return this;
                    if (e = this.get(e)) {
                        var t = this.recognizers,
                            i = y(t, e); - 1 !== i && (t.splice(i, 1), this.touchAction.update())
                    }
                    return this
                },
                on: function(e, t) {
                    var i = this.handlers;
                    return s(v(e), function(e) {
                        i[e] = i[e] || [], i[e].push(t)
                    }), this
                },
                off: function(e, t) {
                    var i = this.handlers;
                    return s(v(e), function(e) {
                        t ? i[e] && i[e].splice(y(i[e], t), 1) : delete i[e]
                    }), this
                },
                emit: function(e, t) {
                    this.options.domEvents && se(e, t);
                    var i = this.handlers[e] && this.handlers[e].slice();
                    if (i && i.length) {
                        t.type = e, t.preventDefault = function() {
                            t.srcEvent.preventDefault()
                        };
                        for (var r = 0; r < i.length;) i[r](t), r++
                    }
                },
                destroy: function() {
                    this.element && ae(this, !1), this.handlers = {}, this.session = {}, this.input.destroy(), this.element = null
                }
            }, le(ne, {
                INPUT_START: Ae,
                INPUT_MOVE: Ce,
                INPUT_END: Le,
                INPUT_CANCEL: Pe,
                STATE_POSSIBLE: st,
                STATE_BEGAN: lt,
                STATE_CHANGED: ct,
                STATE_ENDED: ht,
                STATE_RECOGNIZED: ut,
                STATE_CANCELLED: pt,
                STATE_FAILED: ft,
                DIRECTION_NONE: Re,
                DIRECTION_LEFT: De,
                DIRECTION_RIGHT: Oe,
                DIRECTION_UP: Ie,
                DIRECTION_DOWN: Fe,
                DIRECTION_HORIZONTAL: Ne,
                DIRECTION_VERTICAL: Be,
                DIRECTION_ALL: ke,
                Manager: oe,
                Input: M,
                TouchAction: W,
                TouchInput: G,
                MouseInput: k,
                PointerEventInput: U,
                TouchMouseInput: j,
                SingleTouchInput: V,
                Recognizer: q,
                AttrRecognizer: K,
                Tap: re,
                Pan: $,
                Swipe: ie,
                Pinch: J,
                Rotate: te,
                Press: ee,
                on: f,
                off: d,
                each: s,
                merge: ge,
                extend: me,
                assign: le,
                inherit: c,
                bindFn: h,
                prefixed: b
            });
            var gt = "undefined" != typeof e ? e : "undefined" != typeof self ? self : {};
            gt.Hammer = ne, "function" == typeof define && define.amd ? define(function() {
                return ne
            }) : "undefined" != typeof t && t.exports ? t.exports = ne : e[r] = ne
        }(window, document, "Hammer")
    }, {}],
    4: [function(e, t, i) {
        ! function(e, i) {
            "object" == typeof t && "object" == typeof t.exports ? t.exports = e.document ? i(e, !0) : function(e) {
                if (!e.document) throw new Error("jQuery requires a window with a document");
                return i(e)
            } : i(e)
        }("undefined" != typeof window ? window : this, function(e, t) {
            function i(e) {
                var t = !!e && "length" in e && e.length,
                    i = oe.type(e);
                return "function" === i || oe.isWindow(e) ? !1 : "array" === i || 0 === t || "number" == typeof t && t > 0 && t - 1 in e
            }

            function r(e, t, i) {
                if (oe.isFunction(t)) return oe.grep(e, function(e, r) {
                    return !!t.call(e, r, e) !== i
                });
                if (t.nodeType) return oe.grep(e, function(e) {
                    return e === t !== i
                });
                if ("string" == typeof t) {
                    if (me.test(t)) return oe.filter(t, e, i);
                    t = oe.filter(t, e)
                }
                return oe.grep(e, function(e) {
                    return J.call(t, e) > -1 !== i
                })
            }

            function n(e, t) {
                for (;
                    (e = e[t]) && 1 !== e.nodeType;);
                return e
            }

            function o(e) {
                var t = {};
                return oe.each(e.match(be) || [], function(e, i) {
                    t[i] = !0
                }), t
            }

            function a() {
                Z.removeEventListener("DOMContentLoaded", a), e.removeEventListener("load", a), oe.ready()
            }

            function s() {
                this.expando = oe.expando + s.uid++
            }

            function l(e, t, i) {
                var r;
                if (void 0 === i && 1 === e.nodeType)
                    if (r = "data-" + t.replace(Ce, "-$&").toLowerCase(), i = e.getAttribute(r), "string" == typeof i) {
                        try {
                            i = "true" === i ? !0 : "false" === i ? !1 : "null" === i ? null : +i + "" === i ? +i : Ae.test(i) ? oe.parseJSON(i) : i
                        } catch (n) {}
                        Ee.set(e, t, i)
                    } else i = void 0;
                return i
            }

            function c(e, t, i, r) {
                var n, o = 1,
                    a = 20,
                    s = r ? function() {
                        return r.cur()
                    } : function() {
                        return oe.css(e, t, "")
                    },
                    l = s(),
                    c = i && i[3] || (oe.cssNumber[t] ? "" : "px"),
                    h = (oe.cssNumber[t] || "px" !== c && +l) && Pe.exec(oe.css(e, t));
                if (h && h[3] !== c) {
                    c = c || h[3], i = i || [], h = +l || 1;
                    do o = o || ".5", h /= o, oe.style(e, t, h + c); while (o !== (o = s() / l) && 1 !== o && --a)
                }
                return i && (h = +h || +l || 0, n = i[1] ? h + (i[1] + 1) * i[2] : +i[2], r && (r.unit = c, r.start = h, r.end = n)), n
            }

            function h(e, t) {
                var i = "undefined" != typeof e.getElementsByTagName ? e.getElementsByTagName(t || "*") : "undefined" != typeof e.querySelectorAll ? e.querySelectorAll(t || "*") : [];
                return void 0 === t || t && oe.nodeName(e, t) ? oe.merge([e], i) : i
            }

            function u(e, t) {
                for (var i = 0, r = e.length; r > i; i++) Se.set(e[i], "globalEval", !t || Se.get(t[i], "globalEval"))
            }

            function p(e, t, i, r, n) {
                for (var o, a, s, l, c, p, f = t.createDocumentFragment(), d = [], m = 0, g = e.length; g > m; m++)
                    if (o = e[m], o || 0 === o)
                        if ("object" === oe.type(o)) oe.merge(d, o.nodeType ? [o] : o);
                        else if (Be.test(o)) {
                    for (a = a || f.appendChild(t.createElement("div")), s = (Ie.exec(o) || ["", ""])[1].toLowerCase(), l = Ne[s] || Ne._default, a.innerHTML = l[1] + oe.htmlPrefilter(o) + l[2], p = l[0]; p--;) a = a.lastChild;
                    oe.merge(d, a.childNodes), a = f.firstChild, a.textContent = ""
                } else d.push(t.createTextNode(o));
                for (f.textContent = "", m = 0; o = d[m++];)
                    if (r && oe.inArray(o, r) > -1) n && n.push(o);
                    else if (c = oe.contains(o.ownerDocument, o), a = h(f.appendChild(o), "script"), c && u(a), i)
                    for (p = 0; o = a[p++];) Fe.test(o.type || "") && i.push(o);
                return f
            }

            function f() {
                return !0
            }

            function d() {
                return !1
            }

            function m() {
                try {
                    return Z.activeElement
                } catch (e) {}
            }

            function g(e, t, i, r, n, o) {
                var a, s;
                if ("object" == typeof t) {
                    "string" != typeof i && (r = r || i, i = void 0);
                    for (s in t) g(e, s, i, r, t[s], o);
                    return e
                }
                if (null == r && null == n ? (n = i, r = i = void 0) : null == n && ("string" == typeof i ? (n = r, r = void 0) : (n = r, r = i, i = void 0)), n === !1) n = d;
                else if (!n) return e;
                return 1 === o && (a = n, n = function(e) {
                    return oe().off(e), a.apply(this, arguments)
                }, n.guid = a.guid || (a.guid = oe.guid++)), e.each(function() {
                    oe.event.add(this, t, n, r, i)
                })
            }

            function v(e, t) {
                return oe.nodeName(e, "table") && oe.nodeName(11 !== t.nodeType ? t : t.firstChild, "tr") ? e.getElementsByTagName("tbody")[0] || e.appendChild(e.ownerDocument.createElement("tbody")) : e
            }

            function y(e) {
                return e.type = (null !== e.getAttribute("type")) + "/" + e.type, e
            }

            function _(e) {
                var t = je.exec(e.type);
                return t ? e.type = t[1] : e.removeAttribute("type"), e
            }

            function x(e, t) {
                var i, r, n, o, a, s, l, c;
                if (1 === t.nodeType) {
                    if (Se.hasData(e) && (o = Se.access(e), a = Se.set(t, o), c = o.events)) {
                        delete a.handle, a.events = {};
                        for (n in c)
                            for (i = 0, r = c[n].length; r > i; i++) oe.event.add(t, n, c[n][i])
                    }
                    Ee.hasData(e) && (s = Ee.access(e), l = oe.extend({}, s), Ee.set(t, l))
                }
            }

            function b(e, t) {
                var i = t.nodeName.toLowerCase();
                "input" === i && Oe.test(e.type) ? t.checked = e.checked : "input" !== i && "textarea" !== i || (t.defaultValue = e.defaultValue)
            }

            function w(e, t, i, r) {
                t = K.apply([], t);
                var n, o, a, s, l, c, u = 0,
                    f = e.length,
                    d = f - 1,
                    m = t[0],
                    g = oe.isFunction(m);
                if (g || f > 1 && "string" == typeof m && !re.checkClone && He.test(m)) return e.each(function(n) {
                    var o = e.eq(n);
                    g && (t[0] = m.call(this, n, o.html())), w(o, t, i, r)
                });
                if (f && (n = p(t, e[0].ownerDocument, !1, e, r), o = n.firstChild, 1 === n.childNodes.length && (n = o), o || r)) {
                    for (a = oe.map(h(n, "script"), y), s = a.length; f > u; u++) l = n, u !== d && (l = oe.clone(l, !0, !0), s && oe.merge(a, h(l, "script"))), i.call(e[u], l, u);
                    if (s)
                        for (c = a[a.length - 1].ownerDocument, oe.map(a, _), u = 0; s > u; u++) l = a[u], Fe.test(l.type || "") && !Se.access(l, "globalEval") && oe.contains(c, l) && (l.src ? oe._evalUrl && oe._evalUrl(l.src) : oe.globalEval(l.textContent.replace(We, "")))
                }
                return e
            }

            function T(e, t, i) {
                for (var r, n = t ? oe.filter(t, e) : e, o = 0; null != (r = n[o]); o++) i || 1 !== r.nodeType || oe.cleanData(h(r)), r.parentNode && (i && oe.contains(r.ownerDocument, r) && u(h(r, "script")), r.parentNode.removeChild(r));
                return e
            }

            function M(e, t) {
                var i = oe(t.createElement(e)).appendTo(t.body),
                    r = oe.css(i[0], "display");
                return i.detach(), r
            }

            function S(e) {
                var t = Z,
                    i = qe[e];
                return i || (i = M(e, t), "none" !== i && i || (Xe = (Xe || oe("<iframe frameborder='0' width='0' height='0'/>")).appendTo(t.documentElement), t = Xe[0].contentDocument, t.write(), t.close(), i = M(e, t), Xe.detach()), qe[e] = i), i
            }

            function E(e, t, i) {
                var r, n, o, a, s = e.style;
                return i = i || Qe(e), a = i ? i.getPropertyValue(t) || i[t] : void 0, "" !== a && void 0 !== a || oe.contains(e.ownerDocument, e) || (a = oe.style(e, t)), i && !re.pixelMarginRight() && Ze.test(a) && Ye.test(t) && (r = s.width, n = s.minWidth, o = s.maxWidth, s.minWidth = s.maxWidth = s.width = a, a = i.width, s.width = r, s.minWidth = n, s.maxWidth = o), void 0 !== a ? a + "" : a
            }

            function A(e, t) {
                return {
                    get: function() {
                        return e() ? void delete this.get : (this.get = t).apply(this, arguments)
                    }
                }
            }

            function C(e) {
                if (e in rt) return e;
                for (var t = e[0].toUpperCase() + e.slice(1), i = it.length; i--;)
                    if (e = it[i] + t, e in rt) return e
            }

            function L(e, t, i) {
                var r = Pe.exec(t);
                return r ? Math.max(0, r[2] - (i || 0)) + (r[3] || "px") : t
            }

            function P(e, t, i, r, n) {
                for (var o = i === (r ? "border" : "content") ? 4 : "width" === t ? 1 : 0, a = 0; 4 > o; o += 2) "margin" === i && (a += oe.css(e, i + Re[o], !0, n)), r ? ("content" === i && (a -= oe.css(e, "padding" + Re[o], !0, n)), "margin" !== i && (a -= oe.css(e, "border" + Re[o] + "Width", !0, n))) : (a += oe.css(e, "padding" + Re[o], !0, n), "padding" !== i && (a += oe.css(e, "border" + Re[o] + "Width", !0, n)));
                return a
            }

            function R(t, i, r) {
                var n = !0,
                    o = "width" === i ? t.offsetWidth : t.offsetHeight,
                    a = Qe(t),
                    s = "border-box" === oe.css(t, "boxSizing", !1, a);
                if (Z.msFullscreenElement && e.top !== e && t.getClientRects().length && (o = Math.round(100 * t.getBoundingClientRect()[i])), 0 >= o || null == o) {
                    if (o = E(t, i, a), (0 > o || null == o) && (o = t.style[i]), Ze.test(o)) return o;
                    n = s && (re.boxSizingReliable() || o === t.style[i]), o = parseFloat(o) || 0
                }
                return o + P(t, i, r || (s ? "border" : "content"), n, a) + "px"
            }

            function D(e, t) {
                for (var i, r, n, o = [], a = 0, s = e.length; s > a; a++) r = e[a], r.style && (o[a] = Se.get(r, "olddisplay"), i = r.style.display, t ? (o[a] || "none" !== i || (r.style.display = ""), "" === r.style.display && De(r) && (o[a] = Se.access(r, "olddisplay", S(r.nodeName)))) : (n = De(r), "none" === i && n || Se.set(r, "olddisplay", n ? i : oe.css(r, "display"))));
                for (a = 0; s > a; a++) r = e[a], r.style && (t && "none" !== r.style.display && "" !== r.style.display || (r.style.display = t ? o[a] || "" : "none"));
                return e
            }

            function O(e, t, i, r, n) {
                return new O.prototype.init(e, t, i, r, n)
            }

            function I() {
                return e.setTimeout(function() {
                    nt = void 0
                }), nt = oe.now()
            }

            function F(e, t) {
                var i, r = 0,
                    n = {
                        height: e
                    };
                for (t = t ? 1 : 0; 4 > r; r += 2 - t) i = Re[r], n["margin" + i] = n["padding" + i] = e;
                return t && (n.opacity = n.width = e), n
            }

            function N(e, t, i) {
                for (var r, n = (U.tweeners[t] || []).concat(U.tweeners["*"]), o = 0, a = n.length; a > o; o++)
                    if (r = n[o].call(i, t, e)) return r
            }

            function B(e, t, i) {
                var r, n, o, a, s, l, c, h, u = this,
                    p = {},
                    f = e.style,
                    d = e.nodeType && De(e),
                    m = Se.get(e, "fxshow");
                i.queue || (s = oe._queueHooks(e, "fx"), null == s.unqueued && (s.unqueued = 0, l = s.empty.fire, s.empty.fire = function() {
                    s.unqueued || l()
                }), s.unqueued++, u.always(function() {
                    u.always(function() {
                        s.unqueued--, oe.queue(e, "fx").length || s.empty.fire()
                    })
                })), 1 === e.nodeType && ("height" in t || "width" in t) && (i.overflow = [f.overflow, f.overflowX, f.overflowY], c = oe.css(e, "display"), h = "none" === c ? Se.get(e, "olddisplay") || S(e.nodeName) : c, "inline" === h && "none" === oe.css(e, "float") && (f.display = "inline-block")), i.overflow && (f.overflow = "hidden", u.always(function() {
                    f.overflow = i.overflow[0], f.overflowX = i.overflow[1], f.overflowY = i.overflow[2]
                }));
                for (r in t)
                    if (n = t[r], at.exec(n)) {
                        if (delete t[r], o = o || "toggle" === n, n === (d ? "hide" : "show")) {
                            if ("show" !== n || !m || void 0 === m[r]) continue;
                            d = !0
                        }
                        p[r] = m && m[r] || oe.style(e, r)
                    } else c = void 0;
                if (oe.isEmptyObject(p)) "inline" === ("none" === c ? S(e.nodeName) : c) && (f.display = c);
                else {
                    m ? "hidden" in m && (d = m.hidden) : m = Se.access(e, "fxshow", {}), o && (m.hidden = !d), d ? oe(e).show() : u.done(function() {
                        oe(e).hide()
                    }), u.done(function() {
                        var t;
                        Se.remove(e, "fxshow");
                        for (t in p) oe.style(e, t, p[t])
                    });
                    for (r in p) a = N(d ? m[r] : 0, r, u), r in m || (m[r] = a.start, d && (a.end = a.start, a.start = "width" === r || "height" === r ? 1 : 0))
                }
            }

            function k(e, t) {
                var i, r, n, o, a;
                for (i in e)
                    if (r = oe.camelCase(i), n = t[r], o = e[i], oe.isArray(o) && (n = o[1], o = e[i] = o[0]), i !== r && (e[r] = o, delete e[i]), a = oe.cssHooks[r], a && "expand" in a) {
                        o = a.expand(o), delete e[r];
                        for (i in o) i in e || (e[i] = o[i], t[i] = n)
                    } else t[r] = n
            }

            function U(e, t, i) {
                var r, n, o = 0,
                    a = U.prefilters.length,
                    s = oe.Deferred().always(function() {
                        delete l.elem
                    }),
                    l = function() {
                        if (n) return !1;
                        for (var t = nt || I(), i = Math.max(0, c.startTime + c.duration - t), r = i / c.duration || 0, o = 1 - r, a = 0, l = c.tweens.length; l > a; a++) c.tweens[a].run(o);
                        return s.notifyWith(e, [c, o, i]), 1 > o && l ? i : (s.resolveWith(e, [c]), !1)
                    },
                    c = s.promise({
                        elem: e,
                        props: oe.extend({}, t),
                        opts: oe.extend(!0, {
                            specialEasing: {},
                            easing: oe.easing._default
                        }, i),
                        originalProperties: t,
                        originalOptions: i,
                        startTime: nt || I(),
                        duration: i.duration,
                        tweens: [],
                        createTween: function(t, i) {
                            var r = oe.Tween(e, c.opts, t, i, c.opts.specialEasing[t] || c.opts.easing);
                            return c.tweens.push(r), r
                        },
                        stop: function(t) {
                            var i = 0,
                                r = t ? c.tweens.length : 0;
                            if (n) return this;
                            for (n = !0; r > i; i++) c.tweens[i].run(1);
                            return t ? (s.notifyWith(e, [c, 1, 0]), s.resolveWith(e, [c, t])) : s.rejectWith(e, [c, t]), this
                        }
                    }),
                    h = c.props;
                for (k(h, c.opts.specialEasing); a > o; o++)
                    if (r = U.prefilters[o].call(c, e, h, c.opts)) return oe.isFunction(r.stop) && (oe._queueHooks(c.elem, c.opts.queue).stop = oe.proxy(r.stop, r)), r;
                return oe.map(h, N, c), oe.isFunction(c.opts.start) && c.opts.start.call(e, c), oe.fx.timer(oe.extend(l, {
                    elem: e,
                    anim: c,
                    queue: c.opts.queue
                })), c.progress(c.opts.progress).done(c.opts.done, c.opts.complete).fail(c.opts.fail).always(c.opts.always)
            }

            function V(e) {
                return e.getAttribute && e.getAttribute("class") || ""
            }

            function z(e) {
                return function(t, i) {
                    "string" != typeof t && (i = t, t = "*");
                    var r, n = 0,
                        o = t.toLowerCase().match(be) || [];
                    if (oe.isFunction(i))
                        for (; r = o[n++];) "+" === r[0] ? (r = r.slice(1) || "*", (e[r] = e[r] || []).unshift(i)) : (e[r] = e[r] || []).push(i)
                }
            }

            function G(e, t, i, r) {
                function n(s) {
                    var l;
                    return o[s] = !0, oe.each(e[s] || [], function(e, s) {
                        var c = s(t, i, r);
                        return "string" != typeof c || a || o[c] ? a ? !(l = c) : void 0 : (t.dataTypes.unshift(c), n(c), !1)
                    }), l
                }
                var o = {},
                    a = e === Et;
                return n(t.dataTypes[0]) || !o["*"] && n("*")
            }

            function H(e, t) {
                var i, r, n = oe.ajaxSettings.flatOptions || {};
                for (i in t) void 0 !== t[i] && ((n[i] ? e : r || (r = {}))[i] = t[i]);
                return r && oe.extend(!0, e, r), e
            }

            function j(e, t, i) {
                for (var r, n, o, a, s = e.contents, l = e.dataTypes;
                    "*" === l[0];) l.shift(), void 0 === r && (r = e.mimeType || t.getResponseHeader("Content-Type"));
                if (r)
                    for (n in s)
                        if (s[n] && s[n].test(r)) {
                            l.unshift(n);
                            break
                        }
                if (l[0] in i) o = l[0];
                else {
                    for (n in i) {
                        if (!l[0] || e.converters[n + " " + l[0]]) {
                            o = n;
                            break
                        }
                        a || (a = n)
                    }
                    o = o || a
                }
                return o ? (o !== l[0] && l.unshift(o), i[o]) : void 0
            }

            function W(e, t, i, r) {
                var n, o, a, s, l, c = {},
                    h = e.dataTypes.slice();
                if (h[1])
                    for (a in e.converters) c[a.toLowerCase()] = e.converters[a];
                for (o = h.shift(); o;)
                    if (e.responseFields[o] && (i[e.responseFields[o]] = t), !l && r && e.dataFilter && (t = e.dataFilter(t, e.dataType)), l = o, o = h.shift())
                        if ("*" === o) o = l;
                        else if ("*" !== l && l !== o) {
                    if (a = c[l + " " + o] || c["* " + o], !a)
                        for (n in c)
                            if (s = n.split(" "), s[1] === o && (a = c[l + " " + s[0]] || c["* " + s[0]])) {
                                a === !0 ? a = c[n] : c[n] !== !0 && (o = s[0], h.unshift(s[1]));
                                break
                            }
                    if (a !== !0)
                        if (a && e["throws"]) t = a(t);
                        else try {
                            t = a(t)
                        } catch (u) {
                            return {
                                state: "parsererror",
                                error: a ? u : "No conversion from " + l + " to " + o
                            }
                        }
                }
                return {
                    state: "success",
                    data: t
                }
            }

            function X(e, t, i, r) {
                var n;
                if (oe.isArray(t)) oe.each(t, function(t, n) {
                    i || Pt.test(e) ? r(e, n) : X(e + "[" + ("object" == typeof n && null != n ? t : "") + "]", n, i, r)
                });
                else if (i || "object" !== oe.type(t)) r(e, t);
                else
                    for (n in t) X(e + "[" + n + "]", t[n], i, r)
            }

            function q(e) {
                return oe.isWindow(e) ? e : 9 === e.nodeType && e.defaultView
            }
            var Y = [],
                Z = e.document,
                Q = Y.slice,
                K = Y.concat,
                $ = Y.push,
                J = Y.indexOf,
                ee = {},
                te = ee.toString,
                ie = ee.hasOwnProperty,
                re = {},
                ne = "2.2.2",
                oe = function(e, t) {
                    return new oe.fn.init(e, t)
                },
                ae = /^[\s\uFEFF\xA0]+|[\s\uFEFF\xA0]+$/g,
                se = /^-ms-/,
                le = /-([\da-z])/gi,
                ce = function(e, t) {
                    return t.toUpperCase()
                };
            oe.fn = oe.prototype = {
                jquery: ne,
                constructor: oe,
                selector: "",
                length: 0,
                toArray: function() {
                    return Q.call(this)
                },
                get: function(e) {
                    return null != e ? 0 > e ? this[e + this.length] : this[e] : Q.call(this)
                },
                pushStack: function(e) {
                    var t = oe.merge(this.constructor(), e);
                    return t.prevObject = this, t.context = this.context, t
                },
                each: function(e) {
                    return oe.each(this, e)
                },
                map: function(e) {
                    return this.pushStack(oe.map(this, function(t, i) {
                        return e.call(t, i, t)
                    }))
                },
                slice: function() {
                    return this.pushStack(Q.apply(this, arguments))
                },
                first: function() {
                    return this.eq(0)
                },
                last: function() {
                    return this.eq(-1)
                },
                eq: function(e) {
                    var t = this.length,
                        i = +e + (0 > e ? t : 0);
                    return this.pushStack(i >= 0 && t > i ? [this[i]] : [])
                },
                end: function() {
                    return this.prevObject || this.constructor()
                },
                push: $,
                sort: Y.sort,
                splice: Y.splice
            }, oe.extend = oe.fn.extend = function() {
                var e, t, i, r, n, o, a = arguments[0] || {},
                    s = 1,
                    l = arguments.length,
                    c = !1;
                for ("boolean" == typeof a && (c = a, a = arguments[s] || {}, s++), "object" == typeof a || oe.isFunction(a) || (a = {}), s === l && (a = this, s--); l > s; s++)
                    if (null != (e = arguments[s]))
                        for (t in e) i = a[t], r = e[t], a !== r && (c && r && (oe.isPlainObject(r) || (n = oe.isArray(r))) ? (n ? (n = !1, o = i && oe.isArray(i) ? i : []) : o = i && oe.isPlainObject(i) ? i : {}, a[t] = oe.extend(c, o, r)) : void 0 !== r && (a[t] = r));
                return a
            }, oe.extend({
                expando: "jQuery" + (ne + Math.random()).replace(/\D/g, ""),
                isReady: !0,
                error: function(e) {
                    throw new Error(e)
                },
                noop: function() {},
                isFunction: function(e) {
                    return "function" === oe.type(e)
                },
                isArray: Array.isArray,
                isWindow: function(e) {
                    return null != e && e === e.window
                },
                isNumeric: function(e) {
                    var t = e && e.toString();
                    return !oe.isArray(e) && t - parseFloat(t) + 1 >= 0
                },
                isPlainObject: function(e) {
                    var t;
                    if ("object" !== oe.type(e) || e.nodeType || oe.isWindow(e)) return !1;
                    if (e.constructor && !ie.call(e, "constructor") && !ie.call(e.constructor.prototype || {}, "isPrototypeOf")) return !1;
                    for (t in e);
                    return void 0 === t || ie.call(e, t)
                },
                isEmptyObject: function(e) {
                    var t;
                    for (t in e) return !1;
                    return !0
                },
                type: function(e) {
                    return null == e ? e + "" : "object" == typeof e || "function" == typeof e ? ee[te.call(e)] || "object" : typeof e
                },
                globalEval: function(e) {
                    var t, i = eval;
                    e = oe.trim(e), e && (1 === e.indexOf("use strict") ? (t = Z.createElement("script"), t.text = e, Z.head.appendChild(t).parentNode.removeChild(t)) : i(e))
                },
                camelCase: function(e) {
                    return e.replace(se, "ms-").replace(le, ce)
                },
                nodeName: function(e, t) {
                    return e.nodeName && e.nodeName.toLowerCase() === t.toLowerCase()
                },
                each: function(e, t) {
                    var r, n = 0;
                    if (i(e))
                        for (r = e.length; r > n && t.call(e[n], n, e[n]) !== !1; n++);
                    else
                        for (n in e)
                            if (t.call(e[n], n, e[n]) === !1) break; return e
                },
                trim: function(e) {
                    return null == e ? "" : (e + "").replace(ae, "")
                },
                makeArray: function(e, t) {
                    var r = t || [];
                    return null != e && (i(Object(e)) ? oe.merge(r, "string" == typeof e ? [e] : e) : $.call(r, e)), r
                },
                inArray: function(e, t, i) {
                    return null == t ? -1 : J.call(t, e, i)
                },
                merge: function(e, t) {
                    for (var i = +t.length, r = 0, n = e.length; i > r; r++) e[n++] = t[r];
                    return e.length = n, e
                },
                grep: function(e, t, i) {
                    for (var r, n = [], o = 0, a = e.length, s = !i; a > o; o++) r = !t(e[o], o), r !== s && n.push(e[o]);
                    return n
                },
                map: function(e, t, r) {
                    var n, o, a = 0,
                        s = [];
                    if (i(e))
                        for (n = e.length; n > a; a++) o = t(e[a], a, r), null != o && s.push(o);
                    else
                        for (a in e) o = t(e[a], a, r), null != o && s.push(o);
                    return K.apply([], s)
                },
                guid: 1,
                proxy: function(e, t) {
                    var i, r, n;
                    return "string" == typeof t && (i = e[t], t = e, e = i), oe.isFunction(e) ? (r = Q.call(arguments, 2), n = function() {
                        return e.apply(t || this, r.concat(Q.call(arguments)))
                    }, n.guid = e.guid = e.guid || oe.guid++, n) : void 0
                },
                now: Date.now,
                support: re
            }), "function" == typeof Symbol && (oe.fn[Symbol.iterator] = Y[Symbol.iterator]), oe.each("Boolean Number String Function Array Date RegExp Object Error Symbol".split(" "), function(e, t) {
                ee["[object " + t + "]"] = t.toLowerCase()
            });
            var he = function(e) {
                function t(e, t, i, r) {
                    var n, o, a, s, l, c, u, f, d = t && t.ownerDocument,
                        m = t ? t.nodeType : 9;
                    if (i = i || [], "string" != typeof e || !e || 1 !== m && 9 !== m && 11 !== m) return i;
                    if (!r && ((t ? t.ownerDocument || t : V) !== D && R(t), t = t || D, I)) {
                        if (11 !== m && (c = ve.exec(e)))
                            if (n = c[1]) {
                                if (9 === m) {
                                    if (!(a = t.getElementById(n))) return i;
                                    if (a.id === n) return i.push(a), i
                                } else if (d && (a = d.getElementById(n)) && k(t, a) && a.id === n) return i.push(a), i
                            } else {
                                if (c[2]) return $.apply(i, t.getElementsByTagName(e)), i;
                                if ((n = c[3]) && b.getElementsByClassName && t.getElementsByClassName) return $.apply(i, t.getElementsByClassName(n)), i
                            }
                        if (b.qsa && !W[e + " "] && (!F || !F.test(e))) {
                            if (1 !== m) d = t, f = e;
                            else if ("object" !== t.nodeName.toLowerCase()) {
                                for ((s = t.getAttribute("id")) ? s = s.replace(_e, "\\$&") : t.setAttribute("id", s = U), u = S(e), o = u.length, l = pe.test(s) ? "#" + s : "[id='" + s + "']"; o--;) u[o] = l + " " + p(u[o]);
                                f = u.join(","), d = ye.test(e) && h(t.parentNode) || t
                            }
                            if (f) try {
                                return $.apply(i, d.querySelectorAll(f)), i
                            } catch (g) {} finally {
                                s === U && t.removeAttribute("id")
                            }
                        }
                    }
                    return A(e.replace(se, "$1"), t, i, r)
                }

                function i() {
                    function e(i, r) {
                        return t.push(i + " ") > w.cacheLength && delete e[t.shift()], e[i + " "] = r
                    }
                    var t = [];
                    return e
                }

                function r(e) {
                    return e[U] = !0, e
                }

                function n(e) {
                    var t = D.createElement("div");
                    try {
                        return !!e(t)
                    } catch (i) {
                        return !1
                    } finally {
                        t.parentNode && t.parentNode.removeChild(t), t = null
                    }
                }

                function o(e, t) {
                    for (var i = e.split("|"), r = i.length; r--;) w.attrHandle[i[r]] = t
                }

                function a(e, t) {
                    var i = t && e,
                        r = i && 1 === e.nodeType && 1 === t.nodeType && (~t.sourceIndex || q) - (~e.sourceIndex || q);
                    if (r) return r;
                    if (i)
                        for (; i = i.nextSibling;)
                            if (i === t) return -1;
                    return e ? 1 : -1
                }

                function s(e) {
                    return function(t) {
                        var i = t.nodeName.toLowerCase();
                        return "input" === i && t.type === e
                    }
                }

                function l(e) {
                    return function(t) {
                        var i = t.nodeName.toLowerCase();
                        return ("input" === i || "button" === i) && t.type === e
                    }
                }

                function c(e) {
                    return r(function(t) {
                        return t = +t, r(function(i, r) {
                            for (var n, o = e([], i.length, t), a = o.length; a--;) i[n = o[a]] && (i[n] = !(r[n] = i[n]))
                        })
                    })
                }

                function h(e) {
                    return e && "undefined" != typeof e.getElementsByTagName && e
                }

                function u() {}

                function p(e) {
                    for (var t = 0, i = e.length, r = ""; i > t; t++) r += e[t].value;
                    return r
                }

                function f(e, t, i) {
                    var r = t.dir,
                        n = i && "parentNode" === r,
                        o = G++;
                    return t.first ? function(t, i, o) {
                        for (; t = t[r];)
                            if (1 === t.nodeType || n) return e(t, i, o)
                    } : function(t, i, a) {
                        var s, l, c, h = [z, o];
                        if (a) {
                            for (; t = t[r];)
                                if ((1 === t.nodeType || n) && e(t, i, a)) return !0
                        } else
                            for (; t = t[r];)
                                if (1 === t.nodeType || n) {
                                    if (c = t[U] || (t[U] = {}), l = c[t.uniqueID] || (c[t.uniqueID] = {}), (s = l[r]) && s[0] === z && s[1] === o) return h[2] = s[2];
                                    if (l[r] = h, h[2] = e(t, i, a)) return !0
                                }
                    }
                }

                function d(e) {
                    return e.length > 1 ? function(t, i, r) {
                        for (var n = e.length; n--;)
                            if (!e[n](t, i, r)) return !1;
                        return !0
                    } : e[0]
                }

                function m(e, i, r) {
                    for (var n = 0, o = i.length; o > n; n++) t(e, i[n], r);
                    return r
                }

                function g(e, t, i, r, n) {
                    for (var o, a = [], s = 0, l = e.length, c = null != t; l > s; s++)(o = e[s]) && (i && !i(o, r, n) || (a.push(o), c && t.push(s)));
                    return a
                }

                function v(e, t, i, n, o, a) {
                    return n && !n[U] && (n = v(n)), o && !o[U] && (o = v(o, a)), r(function(r, a, s, l) {
                        var c, h, u, p = [],
                            f = [],
                            d = a.length,
                            v = r || m(t || "*", s.nodeType ? [s] : s, []),
                            y = !e || !r && t ? v : g(v, p, e, s, l),
                            _ = i ? o || (r ? e : d || n) ? [] : a : y;
                        if (i && i(y, _, s, l), n)
                            for (c = g(_, f), n(c, [], s, l), h = c.length; h--;)(u = c[h]) && (_[f[h]] = !(y[f[h]] = u));
                        if (r) {
                            if (o || e) {
                                if (o) {
                                    for (c = [], h = _.length; h--;)(u = _[h]) && c.push(y[h] = u);
                                    o(null, _ = [], c, l)
                                }
                                for (h = _.length; h--;)(u = _[h]) && (c = o ? ee(r, u) : p[h]) > -1 && (r[c] = !(a[c] = u))
                            }
                        } else _ = g(_ === a ? _.splice(d, _.length) : _), o ? o(null, a, _, l) : $.apply(a, _)
                    })
                }

                function y(e) {
                    for (var t, i, r, n = e.length, o = w.relative[e[0].type], a = o || w.relative[" "], s = o ? 1 : 0, l = f(function(e) {
                            return e === t
                        }, a, !0), c = f(function(e) {
                            return ee(t, e) > -1
                        }, a, !0), h = [function(e, i, r) {
                            var n = !o && (r || i !== C) || ((t = i).nodeType ? l(e, i, r) : c(e, i, r));
                            return t = null, n
                        }]; n > s; s++)
                        if (i = w.relative[e[s].type]) h = [f(d(h), i)];
                        else {
                            if (i = w.filter[e[s].type].apply(null, e[s].matches), i[U]) {
                                for (r = ++s; n > r && !w.relative[e[r].type]; r++);
                                return v(s > 1 && d(h), s > 1 && p(e.slice(0, s - 1).concat({
                                    value: " " === e[s - 2].type ? "*" : ""
                                })).replace(se, "$1"), i, r > s && y(e.slice(s, r)), n > r && y(e = e.slice(r)), n > r && p(e))
                            }
                            h.push(i)
                        }
                    return d(h)
                }

                function _(e, i) {
                    var n = i.length > 0,
                        o = e.length > 0,
                        a = function(r, a, s, l, c) {
                            var h, u, p, f = 0,
                                d = "0",
                                m = r && [],
                                v = [],
                                y = C,
                                _ = r || o && w.find.TAG("*", c),
                                x = z += null == y ? 1 : Math.random() || .1,
                                b = _.length;
                            for (c && (C = a === D || a || c); d !== b && null != (h = _[d]); d++) {
                                if (o && h) {
                                    for (u = 0, a || h.ownerDocument === D || (R(h), s = !I); p = e[u++];)
                                        if (p(h, a || D, s)) {
                                            l.push(h);
                                            break
                                        }
                                    c && (z = x)
                                }
                                n && ((h = !p && h) && f--, r && m.push(h))
                            }
                            if (f += d, n && d !== f) {
                                for (u = 0; p = i[u++];) p(m, v, a, s);
                                if (r) {
                                    if (f > 0)
                                        for (; d--;) m[d] || v[d] || (v[d] = Q.call(l));
                                    v = g(v)
                                }
                                $.apply(l, v), c && !r && v.length > 0 && f + i.length > 1 && t.uniqueSort(l)
                            }
                            return c && (z = x, C = y), m
                        };
                    return n ? r(a) : a
                }
                var x, b, w, T, M, S, E, A, C, L, P, R, D, O, I, F, N, B, k, U = "sizzle" + 1 * new Date,
                    V = e.document,
                    z = 0,
                    G = 0,
                    H = i(),
                    j = i(),
                    W = i(),
                    X = function(e, t) {
                        return e === t && (P = !0), 0
                    },
                    q = 1 << 31,
                    Y = {}.hasOwnProperty,
                    Z = [],
                    Q = Z.pop,
                    K = Z.push,
                    $ = Z.push,
                    J = Z.slice,
                    ee = function(e, t) {
                        for (var i = 0, r = e.length; r > i; i++)
                            if (e[i] === t) return i;
                        return -1
                    },
                    te = "checked|selected|async|autofocus|autoplay|controls|defer|disabled|hidden|ismap|loop|multiple|open|readonly|required|scoped",
                    ie = "[\\x20\\t\\r\\n\\f]",
                    re = "(?:\\\\.|[\\w-]|[^\\x00-\\xa0])+",
                    ne = "\\[" + ie + "*(" + re + ")(?:" + ie + "*([*^$|!~]?=)" + ie + "*(?:'((?:\\\\.|[^\\\\'])*)'|\"((?:\\\\.|[^\\\\\"])*)\"|(" + re + "))|)" + ie + "*\\]",
                    oe = ":(" + re + ")(?:\\((('((?:\\\\.|[^\\\\'])*)'|\"((?:\\\\.|[^\\\\\"])*)\")|((?:\\\\.|[^\\\\()[\\]]|" + ne + ")*)|.*)\\)|)",
                    ae = new RegExp(ie + "+", "g"),
                    se = new RegExp("^" + ie + "+|((?:^|[^\\\\])(?:\\\\.)*)" + ie + "+$", "g"),
                    le = new RegExp("^" + ie + "*," + ie + "*"),
                    ce = new RegExp("^" + ie + "*([>+~]|" + ie + ")" + ie + "*"),
                    he = new RegExp("=" + ie + "*([^\\]'\"]*?)" + ie + "*\\]", "g"),
                    ue = new RegExp(oe),
                    pe = new RegExp("^" + re + "$"),
                    fe = {
                        ID: new RegExp("^#(" + re + ")"),
                        CLASS: new RegExp("^\\.(" + re + ")"),
                        TAG: new RegExp("^(" + re + "|[*])"),
                        ATTR: new RegExp("^" + ne),
                        PSEUDO: new RegExp("^" + oe),
                        CHILD: new RegExp("^:(only|first|last|nth|nth-last)-(child|of-type)(?:\\(" + ie + "*(even|odd|(([+-]|)(\\d*)n|)" + ie + "*(?:([+-]|)" + ie + "*(\\d+)|))" + ie + "*\\)|)", "i"),
                        bool: new RegExp("^(?:" + te + ")$", "i"),
                        needsContext: new RegExp("^" + ie + "*[>+~]|:(even|odd|eq|gt|lt|nth|first|last)(?:\\(" + ie + "*((?:-\\d)?\\d*)" + ie + "*\\)|)(?=[^-]|$)", "i")
                    },
                    de = /^(?:input|select|textarea|button)$/i,
                    me = /^h\d$/i,
                    ge = /^[^{]+\{\s*\[native \w/,
                    ve = /^(?:#([\w-]+)|(\w+)|\.([\w-]+))$/,
                    ye = /[+~]/,
                    _e = /'|\\/g,
                    xe = new RegExp("\\\\([\\da-f]{1,6}" + ie + "?|(" + ie + ")|.)", "ig"),
                    be = function(e, t, i) {
                        var r = "0x" + t - 65536;
                        return r !== r || i ? t : 0 > r ? String.fromCharCode(r + 65536) : String.fromCharCode(r >> 10 | 55296, 1023 & r | 56320)
                    },
                    we = function() {
                        R()
                    };
                try {
                    $.apply(Z = J.call(V.childNodes), V.childNodes), Z[V.childNodes.length].nodeType
                } catch (Te) {
                    $ = {
                        apply: Z.length ? function(e, t) {
                            K.apply(e, J.call(t))
                        } : function(e, t) {
                            for (var i = e.length, r = 0; e[i++] = t[r++];);
                            e.length = i - 1
                        }
                    }
                }
                b = t.support = {}, M = t.isXML = function(e) {
                    var t = e && (e.ownerDocument || e).documentElement;
                    return t ? "HTML" !== t.nodeName : !1
                }, R = t.setDocument = function(e) {
                    var t, i, r = e ? e.ownerDocument || e : V;
                    return r !== D && 9 === r.nodeType && r.documentElement ? (D = r, O = D.documentElement, I = !M(D), (i = D.defaultView) && i.top !== i && (i.addEventListener ? i.addEventListener("unload", we, !1) : i.attachEvent && i.attachEvent("onunload", we)), b.attributes = n(function(e) {
                        return e.className = "i", !e.getAttribute("className")
                    }), b.getElementsByTagName = n(function(e) {
                        return e.appendChild(D.createComment("")), !e.getElementsByTagName("*").length
                    }), b.getElementsByClassName = ge.test(D.getElementsByClassName), b.getById = n(function(e) {
                        return O.appendChild(e).id = U, !D.getElementsByName || !D.getElementsByName(U).length
                    }), b.getById ? (w.find.ID = function(e, t) {
                        if ("undefined" != typeof t.getElementById && I) {
                            var i = t.getElementById(e);
                            return i ? [i] : []
                        }
                    }, w.filter.ID = function(e) {
                        var t = e.replace(xe, be);
                        return function(e) {
                            return e.getAttribute("id") === t
                        }
                    }) : (delete w.find.ID, w.filter.ID = function(e) {
                        var t = e.replace(xe, be);
                        return function(e) {
                            var i = "undefined" != typeof e.getAttributeNode && e.getAttributeNode("id");
                            return i && i.value === t
                        }
                    }), w.find.TAG = b.getElementsByTagName ? function(e, t) {
                        return "undefined" != typeof t.getElementsByTagName ? t.getElementsByTagName(e) : b.qsa ? t.querySelectorAll(e) : void 0
                    } : function(e, t) {
                        var i, r = [],
                            n = 0,
                            o = t.getElementsByTagName(e);
                        if ("*" === e) {
                            for (; i = o[n++];) 1 === i.nodeType && r.push(i);
                            return r
                        }
                        return o
                    }, w.find.CLASS = b.getElementsByClassName && function(e, t) {
                        return "undefined" != typeof t.getElementsByClassName && I ? t.getElementsByClassName(e) : void 0
                    }, N = [], F = [], (b.qsa = ge.test(D.querySelectorAll)) && (n(function(e) {
                        O.appendChild(e).innerHTML = "<a id='" + U + "'></a><select id='" + U + "-\r\\' msallowcapture=''><option selected=''></option></select>", e.querySelectorAll("[msallowcapture^='']").length && F.push("[*^$]=" + ie + "*(?:''|\"\")"), e.querySelectorAll("[selected]").length || F.push("\\[" + ie + "*(?:value|" + te + ")"), e.querySelectorAll("[id~=" + U + "-]").length || F.push("~="), e.querySelectorAll(":checked").length || F.push(":checked"), e.querySelectorAll("a#" + U + "+*").length || F.push(".#.+[+~]")
                    }), n(function(e) {
                        var t = D.createElement("input");
                        t.setAttribute("type", "hidden"), e.appendChild(t).setAttribute("name", "D"), e.querySelectorAll("[name=d]").length && F.push("name" + ie + "*[*^$|!~]?="), e.querySelectorAll(":enabled").length || F.push(":enabled", ":disabled"), e.querySelectorAll("*,:x"), F.push(",.*:")
                    })), (b.matchesSelector = ge.test(B = O.matches || O.webkitMatchesSelector || O.mozMatchesSelector || O.oMatchesSelector || O.msMatchesSelector)) && n(function(e) {
                        b.disconnectedMatch = B.call(e, "div"), B.call(e, "[s!='']:x"), N.push("!=", oe)
                    }), F = F.length && new RegExp(F.join("|")), N = N.length && new RegExp(N.join("|")), t = ge.test(O.compareDocumentPosition), k = t || ge.test(O.contains) ? function(e, t) {
                        var i = 9 === e.nodeType ? e.documentElement : e,
                            r = t && t.parentNode;
                        return e === r || !(!r || 1 !== r.nodeType || !(i.contains ? i.contains(r) : e.compareDocumentPosition && 16 & e.compareDocumentPosition(r)))
                    } : function(e, t) {
                        if (t)
                            for (; t = t.parentNode;)
                                if (t === e) return !0;
                        return !1
                    }, X = t ? function(e, t) {
                        if (e === t) return P = !0, 0;
                        var i = !e.compareDocumentPosition - !t.compareDocumentPosition;
                        return i ? i : (i = (e.ownerDocument || e) === (t.ownerDocument || t) ? e.compareDocumentPosition(t) : 1, 1 & i || !b.sortDetached && t.compareDocumentPosition(e) === i ? e === D || e.ownerDocument === V && k(V, e) ? -1 : t === D || t.ownerDocument === V && k(V, t) ? 1 : L ? ee(L, e) - ee(L, t) : 0 : 4 & i ? -1 : 1)
                    } : function(e, t) {
                        if (e === t) return P = !0, 0;
                        var i, r = 0,
                            n = e.parentNode,
                            o = t.parentNode,
                            s = [e],
                            l = [t];
                        if (!n || !o) return e === D ? -1 : t === D ? 1 : n ? -1 : o ? 1 : L ? ee(L, e) - ee(L, t) : 0;
                        if (n === o) return a(e, t);
                        for (i = e; i = i.parentNode;) s.unshift(i);
                        for (i = t; i = i.parentNode;) l.unshift(i);
                        for (; s[r] === l[r];) r++;
                        return r ? a(s[r], l[r]) : s[r] === V ? -1 : l[r] === V ? 1 : 0
                    }, D) : D
                }, t.matches = function(e, i) {
                    return t(e, null, null, i)
                }, t.matchesSelector = function(e, i) {
                    if ((e.ownerDocument || e) !== D && R(e), i = i.replace(he, "='$1']"), b.matchesSelector && I && !W[i + " "] && (!N || !N.test(i)) && (!F || !F.test(i))) try {
                        var r = B.call(e, i);
                        if (r || b.disconnectedMatch || e.document && 11 !== e.document.nodeType) return r
                    } catch (n) {}
                    return t(i, D, null, [e]).length > 0
                }, t.contains = function(e, t) {
                    return (e.ownerDocument || e) !== D && R(e), k(e, t)
                }, t.attr = function(e, t) {
                    (e.ownerDocument || e) !== D && R(e);
                    var i = w.attrHandle[t.toLowerCase()],
                        r = i && Y.call(w.attrHandle, t.toLowerCase()) ? i(e, t, !I) : void 0;
                    return void 0 !== r ? r : b.attributes || !I ? e.getAttribute(t) : (r = e.getAttributeNode(t)) && r.specified ? r.value : null
                }, t.error = function(e) {
                    throw new Error("Syntax error, unrecognized expression: " + e)
                }, t.uniqueSort = function(e) {
                    var t, i = [],
                        r = 0,
                        n = 0;
                    if (P = !b.detectDuplicates, L = !b.sortStable && e.slice(0), e.sort(X), P) {
                        for (; t = e[n++];) t === e[n] && (r = i.push(n));
                        for (; r--;) e.splice(i[r], 1)
                    }
                    return L = null, e
                }, T = t.getText = function(e) {
                    var t, i = "",
                        r = 0,
                        n = e.nodeType;
                    if (n) {
                        if (1 === n || 9 === n || 11 === n) {
                            if ("string" == typeof e.textContent) return e.textContent;
                            for (e = e.firstChild; e; e = e.nextSibling) i += T(e)
                        } else if (3 === n || 4 === n) return e.nodeValue
                    } else
                        for (; t = e[r++];) i += T(t);
                    return i
                }, w = t.selectors = {
                    cacheLength: 50,
                    createPseudo: r,
                    match: fe,
                    attrHandle: {},
                    find: {},
                    relative: {
                        ">": {
                            dir: "parentNode",
                            first: !0
                        },
                        " ": {
                            dir: "parentNode"
                        },
                        "+": {
                            dir: "previousSibling",
                            first: !0
                        },
                        "~": {
                            dir: "previousSibling"
                        }
                    },
                    preFilter: {
                        ATTR: function(e) {
                            return e[1] = e[1].replace(xe, be), e[3] = (e[3] || e[4] || e[5] || "").replace(xe, be), "~=" === e[2] && (e[3] = " " + e[3] + " "), e.slice(0, 4)
                        },
                        CHILD: function(e) {
                            return e[1] = e[1].toLowerCase(), "nth" === e[1].slice(0, 3) ? (e[3] || t.error(e[0]), e[4] = +(e[4] ? e[5] + (e[6] || 1) : 2 * ("even" === e[3] || "odd" === e[3])), e[5] = +(e[7] + e[8] || "odd" === e[3])) : e[3] && t.error(e[0]), e
                        },
                        PSEUDO: function(e) {
                            var t, i = !e[6] && e[2];
                            return fe.CHILD.test(e[0]) ? null : (e[3] ? e[2] = e[4] || e[5] || "" : i && ue.test(i) && (t = S(i, !0)) && (t = i.indexOf(")", i.length - t) - i.length) && (e[0] = e[0].slice(0, t), e[2] = i.slice(0, t)), e.slice(0, 3))
                        }
                    },
                    filter: {
                        TAG: function(e) {
                            var t = e.replace(xe, be).toLowerCase();
                            return "*" === e ? function() {
                                return !0
                            } : function(e) {
                                return e.nodeName && e.nodeName.toLowerCase() === t
                            }
                        },
                        CLASS: function(e) {
                            var t = H[e + " "];
                            return t || (t = new RegExp("(^|" + ie + ")" + e + "(" + ie + "|$)")) && H(e, function(e) {
                                return t.test("string" == typeof e.className && e.className || "undefined" != typeof e.getAttribute && e.getAttribute("class") || "")
                            })
                        },
                        ATTR: function(e, i, r) {
                            return function(n) {
                                var o = t.attr(n, e);
                                return null == o ? "!=" === i : i ? (o += "", "=" === i ? o === r : "!=" === i ? o !== r : "^=" === i ? r && 0 === o.indexOf(r) : "*=" === i ? r && o.indexOf(r) > -1 : "$=" === i ? r && o.slice(-r.length) === r : "~=" === i ? (" " + o.replace(ae, " ") + " ").indexOf(r) > -1 : "|=" === i ? o === r || o.slice(0, r.length + 1) === r + "-" : !1) : !0
                            }
                        },
                        CHILD: function(e, t, i, r, n) {
                            var o = "nth" !== e.slice(0, 3),
                                a = "last" !== e.slice(-4),
                                s = "of-type" === t;
                            return 1 === r && 0 === n ? function(e) {
                                return !!e.parentNode
                            } : function(t, i, l) {
                                var c, h, u, p, f, d, m = o !== a ? "nextSibling" : "previousSibling",
                                    g = t.parentNode,
                                    v = s && t.nodeName.toLowerCase(),
                                    y = !l && !s,
                                    _ = !1;
                                if (g) {
                                    if (o) {
                                        for (; m;) {
                                            for (p = t; p = p[m];)
                                                if (s ? p.nodeName.toLowerCase() === v : 1 === p.nodeType) return !1;
                                            d = m = "only" === e && !d && "nextSibling"
                                        }
                                        return !0
                                    }
                                    if (d = [a ? g.firstChild : g.lastChild], a && y) {
                                        for (p = g, u = p[U] || (p[U] = {}), h = u[p.uniqueID] || (u[p.uniqueID] = {}), c = h[e] || [], f = c[0] === z && c[1], _ = f && c[2], p = f && g.childNodes[f]; p = ++f && p && p[m] || (_ = f = 0) || d.pop();)
                                            if (1 === p.nodeType && ++_ && p === t) {
                                                h[e] = [z, f, _];
                                                break
                                            }
                                    } else if (y && (p = t, u = p[U] || (p[U] = {}), h = u[p.uniqueID] || (u[p.uniqueID] = {}), c = h[e] || [], f = c[0] === z && c[1], _ = f), _ === !1)
                                        for (;
                                            (p = ++f && p && p[m] || (_ = f = 0) || d.pop()) && ((s ? p.nodeName.toLowerCase() !== v : 1 !== p.nodeType) || !++_ || (y && (u = p[U] || (p[U] = {}), h = u[p.uniqueID] || (u[p.uniqueID] = {}), h[e] = [z, _]), p !== t)););
                                    return _ -= n, _ === r || _ % r === 0 && _ / r >= 0
                                }
                            }
                        },
                        PSEUDO: function(e, i) {
                            var n, o = w.pseudos[e] || w.setFilters[e.toLowerCase()] || t.error("unsupported pseudo: " + e);
                            return o[U] ? o(i) : o.length > 1 ? (n = [e, e, "", i], w.setFilters.hasOwnProperty(e.toLowerCase()) ? r(function(e, t) {
                                for (var r, n = o(e, i), a = n.length; a--;) r = ee(e, n[a]), e[r] = !(t[r] = n[a])
                            }) : function(e) {
                                return o(e, 0, n)
                            }) : o
                        }
                    },
                    pseudos: {
                        not: r(function(e) {
                            var t = [],
                                i = [],
                                n = E(e.replace(se, "$1"));
                            return n[U] ? r(function(e, t, i, r) {
                                for (var o, a = n(e, null, r, []), s = e.length; s--;)(o = a[s]) && (e[s] = !(t[s] = o))
                            }) : function(e, r, o) {
                                return t[0] = e, n(t, null, o, i), t[0] = null, !i.pop()
                            }
                        }),
                        has: r(function(e) {
                            return function(i) {
                                return t(e, i).length > 0
                            }
                        }),
                        contains: r(function(e) {
                            return e = e.replace(xe, be),
                                function(t) {
                                    return (t.textContent || t.innerText || T(t)).indexOf(e) > -1
                                }
                        }),
                        lang: r(function(e) {
                            return pe.test(e || "") || t.error("unsupported lang: " + e), e = e.replace(xe, be).toLowerCase(),
                                function(t) {
                                    var i;
                                    do
                                        if (i = I ? t.lang : t.getAttribute("xml:lang") || t.getAttribute("lang")) return i = i.toLowerCase(), i === e || 0 === i.indexOf(e + "-");
                                    while ((t = t.parentNode) && 1 === t.nodeType);
                                    return !1
                                }
                        }),
                        target: function(t) {
                            var i = e.location && e.location.hash;
                            return i && i.slice(1) === t.id
                        },
                        root: function(e) {
                            return e === O
                        },
                        focus: function(e) {
                            return e === D.activeElement && (!D.hasFocus || D.hasFocus()) && !!(e.type || e.href || ~e.tabIndex)
                        },
                        enabled: function(e) {
                            return e.disabled === !1
                        },
                        disabled: function(e) {
                            return e.disabled === !0
                        },
                        checked: function(e) {
                            var t = e.nodeName.toLowerCase();
                            return "input" === t && !!e.checked || "option" === t && !!e.selected
                        },
                        selected: function(e) {
                            return e.parentNode && e.parentNode.selectedIndex, e.selected === !0
                        },
                        empty: function(e) {
                            for (e = e.firstChild; e; e = e.nextSibling)
                                if (e.nodeType < 6) return !1;
                            return !0
                        },
                        parent: function(e) {
                            return !w.pseudos.empty(e)
                        },
                        header: function(e) {
                            return me.test(e.nodeName);
                        },
                        input: function(e) {
                            return de.test(e.nodeName)
                        },
                        button: function(e) {
                            var t = e.nodeName.toLowerCase();
                            return "input" === t && "button" === e.type || "button" === t
                        },
                        text: function(e) {
                            var t;
                            return "input" === e.nodeName.toLowerCase() && "text" === e.type && (null == (t = e.getAttribute("type")) || "text" === t.toLowerCase())
                        },
                        first: c(function() {
                            return [0]
                        }),
                        last: c(function(e, t) {
                            return [t - 1]
                        }),
                        eq: c(function(e, t, i) {
                            return [0 > i ? i + t : i]
                        }),
                        even: c(function(e, t) {
                            for (var i = 0; t > i; i += 2) e.push(i);
                            return e
                        }),
                        odd: c(function(e, t) {
                            for (var i = 1; t > i; i += 2) e.push(i);
                            return e
                        }),
                        lt: c(function(e, t, i) {
                            for (var r = 0 > i ? i + t : i; --r >= 0;) e.push(r);
                            return e
                        }),
                        gt: c(function(e, t, i) {
                            for (var r = 0 > i ? i + t : i; ++r < t;) e.push(r);
                            return e
                        })
                    }
                }, w.pseudos.nth = w.pseudos.eq;
                for (x in {
                        radio: !0,
                        checkbox: !0,
                        file: !0,
                        password: !0,
                        image: !0
                    }) w.pseudos[x] = s(x);
                for (x in {
                        submit: !0,
                        reset: !0
                    }) w.pseudos[x] = l(x);
                return u.prototype = w.filters = w.pseudos, w.setFilters = new u, S = t.tokenize = function(e, i) {
                    var r, n, o, a, s, l, c, h = j[e + " "];
                    if (h) return i ? 0 : h.slice(0);
                    for (s = e, l = [], c = w.preFilter; s;) {
                        r && !(n = le.exec(s)) || (n && (s = s.slice(n[0].length) || s), l.push(o = [])), r = !1, (n = ce.exec(s)) && (r = n.shift(), o.push({
                            value: r,
                            type: n[0].replace(se, " ")
                        }), s = s.slice(r.length));
                        for (a in w.filter) !(n = fe[a].exec(s)) || c[a] && !(n = c[a](n)) || (r = n.shift(), o.push({
                            value: r,
                            type: a,
                            matches: n
                        }), s = s.slice(r.length));
                        if (!r) break
                    }
                    return i ? s.length : s ? t.error(e) : j(e, l).slice(0)
                }, E = t.compile = function(e, t) {
                    var i, r = [],
                        n = [],
                        o = W[e + " "];
                    if (!o) {
                        for (t || (t = S(e)), i = t.length; i--;) o = y(t[i]), o[U] ? r.push(o) : n.push(o);
                        o = W(e, _(n, r)), o.selector = e
                    }
                    return o
                }, A = t.select = function(e, t, i, r) {
                    var n, o, a, s, l, c = "function" == typeof e && e,
                        u = !r && S(e = c.selector || e);
                    if (i = i || [], 1 === u.length) {
                        if (o = u[0] = u[0].slice(0), o.length > 2 && "ID" === (a = o[0]).type && b.getById && 9 === t.nodeType && I && w.relative[o[1].type]) {
                            if (t = (w.find.ID(a.matches[0].replace(xe, be), t) || [])[0], !t) return i;
                            c && (t = t.parentNode), e = e.slice(o.shift().value.length)
                        }
                        for (n = fe.needsContext.test(e) ? 0 : o.length; n-- && (a = o[n], !w.relative[s = a.type]);)
                            if ((l = w.find[s]) && (r = l(a.matches[0].replace(xe, be), ye.test(o[0].type) && h(t.parentNode) || t))) {
                                if (o.splice(n, 1), e = r.length && p(o), !e) return $.apply(i, r), i;
                                break
                            }
                    }
                    return (c || E(e, u))(r, t, !I, i, !t || ye.test(e) && h(t.parentNode) || t), i
                }, b.sortStable = U.split("").sort(X).join("") === U, b.detectDuplicates = !!P, R(), b.sortDetached = n(function(e) {
                    return 1 & e.compareDocumentPosition(D.createElement("div"))
                }), n(function(e) {
                    return e.innerHTML = "<a href='#'></a>", "#" === e.firstChild.getAttribute("href")
                }) || o("type|href|height|width", function(e, t, i) {
                    return i ? void 0 : e.getAttribute(t, "type" === t.toLowerCase() ? 1 : 2)
                }), b.attributes && n(function(e) {
                    return e.innerHTML = "<input/>", e.firstChild.setAttribute("value", ""), "" === e.firstChild.getAttribute("value")
                }) || o("value", function(e, t, i) {
                    return i || "input" !== e.nodeName.toLowerCase() ? void 0 : e.defaultValue
                }), n(function(e) {
                    return null == e.getAttribute("disabled")
                }) || o(te, function(e, t, i) {
                    var r;
                    return i ? void 0 : e[t] === !0 ? t.toLowerCase() : (r = e.getAttributeNode(t)) && r.specified ? r.value : null
                }), t
            }(e);
            oe.find = he, oe.expr = he.selectors, oe.expr[":"] = oe.expr.pseudos, oe.uniqueSort = oe.unique = he.uniqueSort, oe.text = he.getText, oe.isXMLDoc = he.isXML, oe.contains = he.contains;
            var ue = function(e, t, i) {
                    for (var r = [], n = void 0 !== i;
                        (e = e[t]) && 9 !== e.nodeType;)
                        if (1 === e.nodeType) {
                            if (n && oe(e).is(i)) break;
                            r.push(e)
                        }
                    return r
                },
                pe = function(e, t) {
                    for (var i = []; e; e = e.nextSibling) 1 === e.nodeType && e !== t && i.push(e);
                    return i
                },
                fe = oe.expr.match.needsContext,
                de = /^<([\w-]+)\s*\/?>(?:<\/\1>|)$/,
                me = /^.[^:#\[\.,]*$/;
            oe.filter = function(e, t, i) {
                var r = t[0];
                return i && (e = ":not(" + e + ")"), 1 === t.length && 1 === r.nodeType ? oe.find.matchesSelector(r, e) ? [r] : [] : oe.find.matches(e, oe.grep(t, function(e) {
                    return 1 === e.nodeType
                }))
            }, oe.fn.extend({
                find: function(e) {
                    var t, i = this.length,
                        r = [],
                        n = this;
                    if ("string" != typeof e) return this.pushStack(oe(e).filter(function() {
                        for (t = 0; i > t; t++)
                            if (oe.contains(n[t], this)) return !0
                    }));
                    for (t = 0; i > t; t++) oe.find(e, n[t], r);
                    return r = this.pushStack(i > 1 ? oe.unique(r) : r), r.selector = this.selector ? this.selector + " " + e : e, r
                },
                filter: function(e) {
                    return this.pushStack(r(this, e || [], !1))
                },
                not: function(e) {
                    return this.pushStack(r(this, e || [], !0))
                },
                is: function(e) {
                    return !!r(this, "string" == typeof e && fe.test(e) ? oe(e) : e || [], !1).length
                }
            });
            var ge, ve = /^(?:\s*(<[\w\W]+>)[^>]*|#([\w-]*))$/,
                ye = oe.fn.init = function(e, t, i) {
                    var r, n;
                    if (!e) return this;
                    if (i = i || ge, "string" == typeof e) {
                        if (r = "<" === e[0] && ">" === e[e.length - 1] && e.length >= 3 ? [null, e, null] : ve.exec(e), !r || !r[1] && t) return !t || t.jquery ? (t || i).find(e) : this.constructor(t).find(e);
                        if (r[1]) {
                            if (t = t instanceof oe ? t[0] : t, oe.merge(this, oe.parseHTML(r[1], t && t.nodeType ? t.ownerDocument || t : Z, !0)), de.test(r[1]) && oe.isPlainObject(t))
                                for (r in t) oe.isFunction(this[r]) ? this[r](t[r]) : this.attr(r, t[r]);
                            return this
                        }
                        return n = Z.getElementById(r[2]), n && n.parentNode && (this.length = 1, this[0] = n), this.context = Z, this.selector = e, this
                    }
                    return e.nodeType ? (this.context = this[0] = e, this.length = 1, this) : oe.isFunction(e) ? void 0 !== i.ready ? i.ready(e) : e(oe) : (void 0 !== e.selector && (this.selector = e.selector, this.context = e.context), oe.makeArray(e, this))
                };
            ye.prototype = oe.fn, ge = oe(Z);
            var _e = /^(?:parents|prev(?:Until|All))/,
                xe = {
                    children: !0,
                    contents: !0,
                    next: !0,
                    prev: !0
                };
            oe.fn.extend({
                has: function(e) {
                    var t = oe(e, this),
                        i = t.length;
                    return this.filter(function() {
                        for (var e = 0; i > e; e++)
                            if (oe.contains(this, t[e])) return !0
                    })
                },
                closest: function(e, t) {
                    for (var i, r = 0, n = this.length, o = [], a = fe.test(e) || "string" != typeof e ? oe(e, t || this.context) : 0; n > r; r++)
                        for (i = this[r]; i && i !== t; i = i.parentNode)
                            if (i.nodeType < 11 && (a ? a.index(i) > -1 : 1 === i.nodeType && oe.find.matchesSelector(i, e))) {
                                o.push(i);
                                break
                            }
                    return this.pushStack(o.length > 1 ? oe.uniqueSort(o) : o)
                },
                index: function(e) {
                    return e ? "string" == typeof e ? J.call(oe(e), this[0]) : J.call(this, e.jquery ? e[0] : e) : this[0] && this[0].parentNode ? this.first().prevAll().length : -1
                },
                add: function(e, t) {
                    return this.pushStack(oe.uniqueSort(oe.merge(this.get(), oe(e, t))))
                },
                addBack: function(e) {
                    return this.add(null == e ? this.prevObject : this.prevObject.filter(e))
                }
            }), oe.each({
                parent: function(e) {
                    var t = e.parentNode;
                    return t && 11 !== t.nodeType ? t : null
                },
                parents: function(e) {
                    return ue(e, "parentNode")
                },
                parentsUntil: function(e, t, i) {
                    return ue(e, "parentNode", i)
                },
                next: function(e) {
                    return n(e, "nextSibling")
                },
                prev: function(e) {
                    return n(e, "previousSibling")
                },
                nextAll: function(e) {
                    return ue(e, "nextSibling")
                },
                prevAll: function(e) {
                    return ue(e, "previousSibling")
                },
                nextUntil: function(e, t, i) {
                    return ue(e, "nextSibling", i)
                },
                prevUntil: function(e, t, i) {
                    return ue(e, "previousSibling", i)
                },
                siblings: function(e) {
                    return pe((e.parentNode || {}).firstChild, e)
                },
                children: function(e) {
                    return pe(e.firstChild)
                },
                contents: function(e) {
                    return e.contentDocument || oe.merge([], e.childNodes)
                }
            }, function(e, t) {
                oe.fn[e] = function(i, r) {
                    var n = oe.map(this, t, i);
                    return "Until" !== e.slice(-5) && (r = i), r && "string" == typeof r && (n = oe.filter(r, n)), this.length > 1 && (xe[e] || oe.uniqueSort(n), _e.test(e) && n.reverse()), this.pushStack(n)
                }
            });
            var be = /\S+/g;
            oe.Callbacks = function(e) {
                e = "string" == typeof e ? o(e) : oe.extend({}, e);
                var t, i, r, n, a = [],
                    s = [],
                    l = -1,
                    c = function() {
                        for (n = e.once, r = t = !0; s.length; l = -1)
                            for (i = s.shift(); ++l < a.length;) a[l].apply(i[0], i[1]) === !1 && e.stopOnFalse && (l = a.length, i = !1);
                        e.memory || (i = !1), t = !1, n && (a = i ? [] : "")
                    },
                    h = {
                        add: function() {
                            return a && (i && !t && (l = a.length - 1, s.push(i)), function r(t) {
                                oe.each(t, function(t, i) {
                                    oe.isFunction(i) ? e.unique && h.has(i) || a.push(i) : i && i.length && "string" !== oe.type(i) && r(i)
                                })
                            }(arguments), i && !t && c()), this
                        },
                        remove: function() {
                            return oe.each(arguments, function(e, t) {
                                for (var i;
                                    (i = oe.inArray(t, a, i)) > -1;) a.splice(i, 1), l >= i && l--
                            }), this
                        },
                        has: function(e) {
                            return e ? oe.inArray(e, a) > -1 : a.length > 0
                        },
                        empty: function() {
                            return a && (a = []), this
                        },
                        disable: function() {
                            return n = s = [], a = i = "", this
                        },
                        disabled: function() {
                            return !a
                        },
                        lock: function() {
                            return n = s = [], i || (a = i = ""), this
                        },
                        locked: function() {
                            return !!n
                        },
                        fireWith: function(e, i) {
                            return n || (i = i || [], i = [e, i.slice ? i.slice() : i], s.push(i), t || c()), this
                        },
                        fire: function() {
                            return h.fireWith(this, arguments), this
                        },
                        fired: function() {
                            return !!r
                        }
                    };
                return h
            }, oe.extend({
                Deferred: function(e) {
                    var t = [
                            ["resolve", "done", oe.Callbacks("once memory"), "resolved"],
                            ["reject", "fail", oe.Callbacks("once memory"), "rejected"],
                            ["notify", "progress", oe.Callbacks("memory")]
                        ],
                        i = "pending",
                        r = {
                            state: function() {
                                return i
                            },
                            always: function() {
                                return n.done(arguments).fail(arguments), this
                            },
                            then: function() {
                                var e = arguments;
                                return oe.Deferred(function(i) {
                                    oe.each(t, function(t, o) {
                                        var a = oe.isFunction(e[t]) && e[t];
                                        n[o[1]](function() {
                                            var e = a && a.apply(this, arguments);
                                            e && oe.isFunction(e.promise) ? e.promise().progress(i.notify).done(i.resolve).fail(i.reject) : i[o[0] + "With"](this === r ? i.promise() : this, a ? [e] : arguments)
                                        })
                                    }), e = null
                                }).promise()
                            },
                            promise: function(e) {
                                return null != e ? oe.extend(e, r) : r
                            }
                        },
                        n = {};
                    return r.pipe = r.then, oe.each(t, function(e, o) {
                        var a = o[2],
                            s = o[3];
                        r[o[1]] = a.add, s && a.add(function() {
                            i = s
                        }, t[1 ^ e][2].disable, t[2][2].lock), n[o[0]] = function() {
                            return n[o[0] + "With"](this === n ? r : this, arguments), this
                        }, n[o[0] + "With"] = a.fireWith
                    }), r.promise(n), e && e.call(n, n), n
                },
                when: function(e) {
                    var t, i, r, n = 0,
                        o = Q.call(arguments),
                        a = o.length,
                        s = 1 !== a || e && oe.isFunction(e.promise) ? a : 0,
                        l = 1 === s ? e : oe.Deferred(),
                        c = function(e, i, r) {
                            return function(n) {
                                i[e] = this, r[e] = arguments.length > 1 ? Q.call(arguments) : n, r === t ? l.notifyWith(i, r) : --s || l.resolveWith(i, r)
                            }
                        };
                    if (a > 1)
                        for (t = new Array(a), i = new Array(a), r = new Array(a); a > n; n++) o[n] && oe.isFunction(o[n].promise) ? o[n].promise().progress(c(n, i, t)).done(c(n, r, o)).fail(l.reject) : --s;
                    return s || l.resolveWith(r, o), l.promise()
                }
            });
            var we;
            oe.fn.ready = function(e) {
                return oe.ready.promise().done(e), this
            }, oe.extend({
                isReady: !1,
                readyWait: 1,
                holdReady: function(e) {
                    e ? oe.readyWait++ : oe.ready(!0)
                },
                ready: function(e) {
                    (e === !0 ? --oe.readyWait : oe.isReady) || (oe.isReady = !0, e !== !0 && --oe.readyWait > 0 || (we.resolveWith(Z, [oe]), oe.fn.triggerHandler && (oe(Z).triggerHandler("ready"), oe(Z).off("ready"))))
                }
            }), oe.ready.promise = function(t) {
                return we || (we = oe.Deferred(), "complete" === Z.readyState || "loading" !== Z.readyState && !Z.documentElement.doScroll ? e.setTimeout(oe.ready) : (Z.addEventListener("DOMContentLoaded", a), e.addEventListener("load", a))), we.promise(t)
            }, oe.ready.promise();
            var Te = function(e, t, i, r, n, o, a) {
                    var s = 0,
                        l = e.length,
                        c = null == i;
                    if ("object" === oe.type(i)) {
                        n = !0;
                        for (s in i) Te(e, t, s, i[s], !0, o, a)
                    } else if (void 0 !== r && (n = !0, oe.isFunction(r) || (a = !0), c && (a ? (t.call(e, r), t = null) : (c = t, t = function(e, t, i) {
                            return c.call(oe(e), i)
                        })), t))
                        for (; l > s; s++) t(e[s], i, a ? r : r.call(e[s], s, t(e[s], i)));
                    return n ? e : c ? t.call(e) : l ? t(e[0], i) : o
                },
                Me = function(e) {
                    return 1 === e.nodeType || 9 === e.nodeType || !+e.nodeType
                };
            s.uid = 1, s.prototype = {
                register: function(e, t) {
                    var i = t || {};
                    return e.nodeType ? e[this.expando] = i : Object.defineProperty(e, this.expando, {
                        value: i,
                        writable: !0,
                        configurable: !0
                    }), e[this.expando]
                },
                cache: function(e) {
                    if (!Me(e)) return {};
                    var t = e[this.expando];
                    return t || (t = {}, Me(e) && (e.nodeType ? e[this.expando] = t : Object.defineProperty(e, this.expando, {
                        value: t,
                        configurable: !0
                    }))), t
                },
                set: function(e, t, i) {
                    var r, n = this.cache(e);
                    if ("string" == typeof t) n[t] = i;
                    else
                        for (r in t) n[r] = t[r];
                    return n
                },
                get: function(e, t) {
                    return void 0 === t ? this.cache(e) : e[this.expando] && e[this.expando][t]
                },
                access: function(e, t, i) {
                    var r;
                    return void 0 === t || t && "string" == typeof t && void 0 === i ? (r = this.get(e, t), void 0 !== r ? r : this.get(e, oe.camelCase(t))) : (this.set(e, t, i), void 0 !== i ? i : t)
                },
                remove: function(e, t) {
                    var i, r, n, o = e[this.expando];
                    if (void 0 !== o) {
                        if (void 0 === t) this.register(e);
                        else {
                            oe.isArray(t) ? r = t.concat(t.map(oe.camelCase)) : (n = oe.camelCase(t), t in o ? r = [t, n] : (r = n, r = r in o ? [r] : r.match(be) || [])), i = r.length;
                            for (; i--;) delete o[r[i]]
                        }(void 0 === t || oe.isEmptyObject(o)) && (e.nodeType ? e[this.expando] = void 0 : delete e[this.expando])
                    }
                },
                hasData: function(e) {
                    var t = e[this.expando];
                    return void 0 !== t && !oe.isEmptyObject(t)
                }
            };
            var Se = new s,
                Ee = new s,
                Ae = /^(?:\{[\w\W]*\}|\[[\w\W]*\])$/,
                Ce = /[A-Z]/g;
            oe.extend({
                hasData: function(e) {
                    return Ee.hasData(e) || Se.hasData(e)
                },
                data: function(e, t, i) {
                    return Ee.access(e, t, i)
                },
                removeData: function(e, t) {
                    Ee.remove(e, t)
                },
                _data: function(e, t, i) {
                    return Se.access(e, t, i)
                },
                _removeData: function(e, t) {
                    Se.remove(e, t)
                }
            }), oe.fn.extend({
                data: function(e, t) {
                    var i, r, n, o = this[0],
                        a = o && o.attributes;
                    if (void 0 === e) {
                        if (this.length && (n = Ee.get(o), 1 === o.nodeType && !Se.get(o, "hasDataAttrs"))) {
                            for (i = a.length; i--;) a[i] && (r = a[i].name, 0 === r.indexOf("data-") && (r = oe.camelCase(r.slice(5)), l(o, r, n[r])));
                            Se.set(o, "hasDataAttrs", !0)
                        }
                        return n
                    }
                    return "object" == typeof e ? this.each(function() {
                        Ee.set(this, e)
                    }) : Te(this, function(t) {
                        var i, r;
                        if (o && void 0 === t) {
                            if (i = Ee.get(o, e) || Ee.get(o, e.replace(Ce, "-$&").toLowerCase()), void 0 !== i) return i;
                            if (r = oe.camelCase(e), i = Ee.get(o, r), void 0 !== i) return i;
                            if (i = l(o, r, void 0), void 0 !== i) return i
                        } else r = oe.camelCase(e), this.each(function() {
                            var i = Ee.get(this, r);
                            Ee.set(this, r, t), e.indexOf("-") > -1 && void 0 !== i && Ee.set(this, e, t)
                        })
                    }, null, t, arguments.length > 1, null, !0)
                },
                removeData: function(e) {
                    return this.each(function() {
                        Ee.remove(this, e)
                    })
                }
            }), oe.extend({
                queue: function(e, t, i) {
                    var r;
                    return e ? (t = (t || "fx") + "queue", r = Se.get(e, t), i && (!r || oe.isArray(i) ? r = Se.access(e, t, oe.makeArray(i)) : r.push(i)), r || []) : void 0
                },
                dequeue: function(e, t) {
                    t = t || "fx";
                    var i = oe.queue(e, t),
                        r = i.length,
                        n = i.shift(),
                        o = oe._queueHooks(e, t),
                        a = function() {
                            oe.dequeue(e, t)
                        };
                    "inprogress" === n && (n = i.shift(), r--), n && ("fx" === t && i.unshift("inprogress"), delete o.stop, n.call(e, a, o)), !r && o && o.empty.fire()
                },
                _queueHooks: function(e, t) {
                    var i = t + "queueHooks";
                    return Se.get(e, i) || Se.access(e, i, {
                        empty: oe.Callbacks("once memory").add(function() {
                            Se.remove(e, [t + "queue", i])
                        })
                    })
                }
            }), oe.fn.extend({
                queue: function(e, t) {
                    var i = 2;
                    return "string" != typeof e && (t = e, e = "fx", i--), arguments.length < i ? oe.queue(this[0], e) : void 0 === t ? this : this.each(function() {
                        var i = oe.queue(this, e, t);
                        oe._queueHooks(this, e), "fx" === e && "inprogress" !== i[0] && oe.dequeue(this, e)
                    })
                },
                dequeue: function(e) {
                    return this.each(function() {
                        oe.dequeue(this, e)
                    })
                },
                clearQueue: function(e) {
                    return this.queue(e || "fx", [])
                },
                promise: function(e, t) {
                    var i, r = 1,
                        n = oe.Deferred(),
                        o = this,
                        a = this.length,
                        s = function() {
                            --r || n.resolveWith(o, [o])
                        };
                    for ("string" != typeof e && (t = e, e = void 0), e = e || "fx"; a--;) i = Se.get(o[a], e + "queueHooks"), i && i.empty && (r++, i.empty.add(s));
                    return s(), n.promise(t)
                }
            });
            var Le = /[+-]?(?:\d*\.|)\d+(?:[eE][+-]?\d+|)/.source,
                Pe = new RegExp("^(?:([+-])=|)(" + Le + ")([a-z%]*)$", "i"),
                Re = ["Top", "Right", "Bottom", "Left"],
                De = function(e, t) {
                    return e = t || e, "none" === oe.css(e, "display") || !oe.contains(e.ownerDocument, e)
                },
                Oe = /^(?:checkbox|radio)$/i,
                Ie = /<([\w:-]+)/,
                Fe = /^$|\/(?:java|ecma)script/i,
                Ne = {
                    option: [1, "<select multiple='multiple'>", "</select>"],
                    thead: [1, "<table>", "</table>"],
                    col: [2, "<table><colgroup>", "</colgroup></table>"],
                    tr: [2, "<table><tbody>", "</tbody></table>"],
                    td: [3, "<table><tbody><tr>", "</tr></tbody></table>"],
                    _default: [0, "", ""]
                };
            Ne.optgroup = Ne.option, Ne.tbody = Ne.tfoot = Ne.colgroup = Ne.caption = Ne.thead, Ne.th = Ne.td;
            var Be = /<|&#?\w+;/;
            ! function() {
                var e = Z.createDocumentFragment(),
                    t = e.appendChild(Z.createElement("div")),
                    i = Z.createElement("input");
                i.setAttribute("type", "radio"), i.setAttribute("checked", "checked"), i.setAttribute("name", "t"), t.appendChild(i), re.checkClone = t.cloneNode(!0).cloneNode(!0).lastChild.checked, t.innerHTML = "<textarea>x</textarea>", re.noCloneChecked = !!t.cloneNode(!0).lastChild.defaultValue
            }();
            var ke = /^key/,
                Ue = /^(?:mouse|pointer|contextmenu|drag|drop)|click/,
                Ve = /^([^.]*)(?:\.(.+)|)/;
            oe.event = {
                global: {},
                add: function(e, t, i, r, n) {
                    var o, a, s, l, c, h, u, p, f, d, m, g = Se.get(e);
                    if (g)
                        for (i.handler && (o = i, i = o.handler, n = o.selector), i.guid || (i.guid = oe.guid++), (l = g.events) || (l = g.events = {}), (a = g.handle) || (a = g.handle = function(t) {
                                return "undefined" != typeof oe && oe.event.triggered !== t.type ? oe.event.dispatch.apply(e, arguments) : void 0
                            }), t = (t || "").match(be) || [""], c = t.length; c--;) s = Ve.exec(t[c]) || [], f = m = s[1], d = (s[2] || "").split(".").sort(), f && (u = oe.event.special[f] || {}, f = (n ? u.delegateType : u.bindType) || f, u = oe.event.special[f] || {}, h = oe.extend({
                            type: f,
                            origType: m,
                            data: r,
                            handler: i,
                            guid: i.guid,
                            selector: n,
                            needsContext: n && oe.expr.match.needsContext.test(n),
                            namespace: d.join(".")
                        }, o), (p = l[f]) || (p = l[f] = [], p.delegateCount = 0, u.setup && u.setup.call(e, r, d, a) !== !1 || e.addEventListener && e.addEventListener(f, a)), u.add && (u.add.call(e, h), h.handler.guid || (h.handler.guid = i.guid)), n ? p.splice(p.delegateCount++, 0, h) : p.push(h), oe.event.global[f] = !0)
                },
                remove: function(e, t, i, r, n) {
                    var o, a, s, l, c, h, u, p, f, d, m, g = Se.hasData(e) && Se.get(e);
                    if (g && (l = g.events)) {
                        for (t = (t || "").match(be) || [""], c = t.length; c--;)
                            if (s = Ve.exec(t[c]) || [], f = m = s[1], d = (s[2] || "").split(".").sort(), f) {
                                for (u = oe.event.special[f] || {}, f = (r ? u.delegateType : u.bindType) || f, p = l[f] || [], s = s[2] && new RegExp("(^|\\.)" + d.join("\\.(?:.*\\.|)") + "(\\.|$)"), a = o = p.length; o--;) h = p[o], !n && m !== h.origType || i && i.guid !== h.guid || s && !s.test(h.namespace) || r && r !== h.selector && ("**" !== r || !h.selector) || (p.splice(o, 1), h.selector && p.delegateCount--, u.remove && u.remove.call(e, h));
                                a && !p.length && (u.teardown && u.teardown.call(e, d, g.handle) !== !1 || oe.removeEvent(e, f, g.handle), delete l[f])
                            } else
                                for (f in l) oe.event.remove(e, f + t[c], i, r, !0);
                        oe.isEmptyObject(l) && Se.remove(e, "handle events")
                    }
                },
                dispatch: function(e) {
                    e = oe.event.fix(e);
                    var t, i, r, n, o, a = [],
                        s = Q.call(arguments),
                        l = (Se.get(this, "events") || {})[e.type] || [],
                        c = oe.event.special[e.type] || {};
                    if (s[0] = e, e.delegateTarget = this, !c.preDispatch || c.preDispatch.call(this, e) !== !1) {
                        for (a = oe.event.handlers.call(this, e, l), t = 0;
                            (n = a[t++]) && !e.isPropagationStopped();)
                            for (e.currentTarget = n.elem, i = 0;
                                (o = n.handlers[i++]) && !e.isImmediatePropagationStopped();) e.rnamespace && !e.rnamespace.test(o.namespace) || (e.handleObj = o, e.data = o.data, r = ((oe.event.special[o.origType] || {}).handle || o.handler).apply(n.elem, s), void 0 !== r && (e.result = r) === !1 && (e.preventDefault(), e.stopPropagation()));
                        return c.postDispatch && c.postDispatch.call(this, e), e.result
                    }
                },
                handlers: function(e, t) {
                    var i, r, n, o, a = [],
                        s = t.delegateCount,
                        l = e.target;
                    if (s && l.nodeType && ("click" !== e.type || isNaN(e.button) || e.button < 1))
                        for (; l !== this; l = l.parentNode || this)
                            if (1 === l.nodeType && (l.disabled !== !0 || "click" !== e.type)) {
                                for (r = [], i = 0; s > i; i++) o = t[i], n = o.selector + " ", void 0 === r[n] && (r[n] = o.needsContext ? oe(n, this).index(l) > -1 : oe.find(n, this, null, [l]).length), r[n] && r.push(o);
                                r.length && a.push({
                                    elem: l,
                                    handlers: r
                                })
                            }
                    return s < t.length && a.push({
                        elem: this,
                        handlers: t.slice(s)
                    }), a
                },
                props: "altKey bubbles cancelable ctrlKey currentTarget detail eventPhase metaKey relatedTarget shiftKey target timeStamp view which".split(" "),
                fixHooks: {},
                keyHooks: {
                    props: "char charCode key keyCode".split(" "),
                    filter: function(e, t) {
                        return null == e.which && (e.which = null != t.charCode ? t.charCode : t.keyCode), e
                    }
                },
                mouseHooks: {
                    props: "button buttons clientX clientY offsetX offsetY pageX pageY screenX screenY toElement".split(" "),
                    filter: function(e, t) {
                        var i, r, n, o = t.button;
                        return null == e.pageX && null != t.clientX && (i = e.target.ownerDocument || Z, r = i.documentElement, n = i.body, e.pageX = t.clientX + (r && r.scrollLeft || n && n.scrollLeft || 0) - (r && r.clientLeft || n && n.clientLeft || 0), e.pageY = t.clientY + (r && r.scrollTop || n && n.scrollTop || 0) - (r && r.clientTop || n && n.clientTop || 0)), e.which || void 0 === o || (e.which = 1 & o ? 1 : 2 & o ? 3 : 4 & o ? 2 : 0), e
                    }
                },
                fix: function(e) {
                    if (e[oe.expando]) return e;
                    var t, i, r, n = e.type,
                        o = e,
                        a = this.fixHooks[n];
                    for (a || (this.fixHooks[n] = a = Ue.test(n) ? this.mouseHooks : ke.test(n) ? this.keyHooks : {}), r = a.props ? this.props.concat(a.props) : this.props, e = new oe.Event(o), t = r.length; t--;) i = r[t], e[i] = o[i];
                    return e.target || (e.target = Z), 3 === e.target.nodeType && (e.target = e.target.parentNode), a.filter ? a.filter(e, o) : e
                },
                special: {
                    load: {
                        noBubble: !0
                    },
                    focus: {
                        trigger: function() {
                            return this !== m() && this.focus ? (this.focus(), !1) : void 0
                        },
                        delegateType: "focusin"
                    },
                    blur: {
                        trigger: function() {
                            return this === m() && this.blur ? (this.blur(), !1) : void 0
                        },
                        delegateType: "focusout"
                    },
                    click: {
                        trigger: function() {
                            return "checkbox" === this.type && this.click && oe.nodeName(this, "input") ? (this.click(), !1) : void 0
                        },
                        _default: function(e) {
                            return oe.nodeName(e.target, "a")
                        }
                    },
                    beforeunload: {
                        postDispatch: function(e) {
                            void 0 !== e.result && e.originalEvent && (e.originalEvent.returnValue = e.result)
                        }
                    }
                }
            }, oe.removeEvent = function(e, t, i) {
                e.removeEventListener && e.removeEventListener(t, i)
            }, oe.Event = function(e, t) {
                return this instanceof oe.Event ? (e && e.type ? (this.originalEvent = e, this.type = e.type, this.isDefaultPrevented = e.defaultPrevented || void 0 === e.defaultPrevented && e.returnValue === !1 ? f : d) : this.type = e, t && oe.extend(this, t), this.timeStamp = e && e.timeStamp || oe.now(), void(this[oe.expando] = !0)) : new oe.Event(e, t)
            }, oe.Event.prototype = {
                constructor: oe.Event,
                isDefaultPrevented: d,
                isPropagationStopped: d,
                isImmediatePropagationStopped: d,
                preventDefault: function() {
                    var e = this.originalEvent;
                    this.isDefaultPrevented = f, e && e.preventDefault()
                },
                stopPropagation: function() {
                    var e = this.originalEvent;
                    this.isPropagationStopped = f, e && e.stopPropagation()
                },
                stopImmediatePropagation: function() {
                    var e = this.originalEvent;
                    this.isImmediatePropagationStopped = f, e && e.stopImmediatePropagation(), this.stopPropagation()
                }
            }, oe.each({
                mouseenter: "mouseover",
                mouseleave: "mouseout",
                pointerenter: "pointerover",
                pointerleave: "pointerout"
            }, function(e, t) {
                oe.event.special[e] = {
                    delegateType: t,
                    bindType: t,
                    handle: function(e) {
                        var i, r = this,
                            n = e.relatedTarget,
                            o = e.handleObj;
                        return n && (n === r || oe.contains(r, n)) || (e.type = o.origType, i = o.handler.apply(this, arguments), e.type = t), i
                    }
                }
            }), oe.fn.extend({
                on: function(e, t, i, r) {
                    return g(this, e, t, i, r)
                },
                one: function(e, t, i, r) {
                    return g(this, e, t, i, r, 1)
                },
                off: function(e, t, i) {
                    var r, n;
                    if (e && e.preventDefault && e.handleObj) return r = e.handleObj, oe(e.delegateTarget).off(r.namespace ? r.origType + "." + r.namespace : r.origType, r.selector, r.handler), this;
                    if ("object" == typeof e) {
                        for (n in e) this.off(n, t, e[n]);
                        return this
                    }
                    return t !== !1 && "function" != typeof t || (i = t, t = void 0), i === !1 && (i = d), this.each(function() {
                        oe.event.remove(this, e, i, t)
                    })
                }
            });
            var ze = /<(?!area|br|col|embed|hr|img|input|link|meta|param)(([\w:-]+)[^>]*)\/>/gi,
                Ge = /<script|<style|<link/i,
                He = /checked\s*(?:[^=]|=\s*.checked.)/i,
                je = /^true\/(.*)/,
                We = /^\s*<!(?:\[CDATA\[|--)|(?:\]\]|--)>\s*$/g;
            oe.extend({
                htmlPrefilter: function(e) {
                    return e.replace(ze, "<$1></$2>")
                },
                clone: function(e, t, i) {
                    var r, n, o, a, s = e.cloneNode(!0),
                        l = oe.contains(e.ownerDocument, e);
                    if (!(re.noCloneChecked || 1 !== e.nodeType && 11 !== e.nodeType || oe.isXMLDoc(e)))
                        for (a = h(s), o = h(e), r = 0, n = o.length; n > r; r++) b(o[r], a[r]);
                    if (t)
                        if (i)
                            for (o = o || h(e), a = a || h(s), r = 0, n = o.length; n > r; r++) x(o[r], a[r]);
                        else x(e, s);
                    return a = h(s, "script"), a.length > 0 && u(a, !l && h(e, "script")), s
                },
                cleanData: function(e) {
                    for (var t, i, r, n = oe.event.special, o = 0; void 0 !== (i = e[o]); o++)
                        if (Me(i)) {
                            if (t = i[Se.expando]) {
                                if (t.events)
                                    for (r in t.events) n[r] ? oe.event.remove(i, r) : oe.removeEvent(i, r, t.handle);
                                i[Se.expando] = void 0
                            }
                            i[Ee.expando] && (i[Ee.expando] = void 0)
                        }
                }
            }), oe.fn.extend({
                domManip: w,
                detach: function(e) {
                    return T(this, e, !0)
                },
                remove: function(e) {
                    return T(this, e)
                },
                text: function(e) {
                    return Te(this, function(e) {
                        return void 0 === e ? oe.text(this) : this.empty().each(function() {
                            1 !== this.nodeType && 11 !== this.nodeType && 9 !== this.nodeType || (this.textContent = e)
                        })
                    }, null, e, arguments.length)
                },
                append: function() {
                    return w(this, arguments, function(e) {
                        if (1 === this.nodeType || 11 === this.nodeType || 9 === this.nodeType) {
                            var t = v(this, e);
                            t.appendChild(e)
                        }
                    })
                },
                prepend: function() {
                    return w(this, arguments, function(e) {
                        if (1 === this.nodeType || 11 === this.nodeType || 9 === this.nodeType) {
                            var t = v(this, e);
                            t.insertBefore(e, t.firstChild)
                        }
                    })
                },
                before: function() {
                    return w(this, arguments, function(e) {
                        this.parentNode && this.parentNode.insertBefore(e, this)
                    })
                },
                after: function() {
                    return w(this, arguments, function(e) {
                        this.parentNode && this.parentNode.insertBefore(e, this.nextSibling)
                    })
                },
                empty: function() {
                    for (var e, t = 0; null != (e = this[t]); t++) 1 === e.nodeType && (oe.cleanData(h(e, !1)), e.textContent = "");
                    return this
                },
                clone: function(e, t) {
                    return e = null == e ? !1 : e, t = null == t ? e : t, this.map(function() {
                        return oe.clone(this, e, t)
                    })
                },
                html: function(e) {
                    return Te(this, function(e) {
                        var t = this[0] || {},
                            i = 0,
                            r = this.length;
                        if (void 0 === e && 1 === t.nodeType) return t.innerHTML;
                        if ("string" == typeof e && !Ge.test(e) && !Ne[(Ie.exec(e) || ["", ""])[1].toLowerCase()]) {
                            e = oe.htmlPrefilter(e);
                            try {
                                for (; r > i; i++) t = this[i] || {}, 1 === t.nodeType && (oe.cleanData(h(t, !1)), t.innerHTML = e);
                                t = 0
                            } catch (n) {}
                        }
                        t && this.empty().append(e)
                    }, null, e, arguments.length)
                },
                replaceWith: function() {
                    var e = [];
                    return w(this, arguments, function(t) {
                        var i = this.parentNode;
                        oe.inArray(this, e) < 0 && (oe.cleanData(h(this)), i && i.replaceChild(t, this))
                    }, e)
                }
            }), oe.each({
                appendTo: "append",
                prependTo: "prepend",
                insertBefore: "before",
                insertAfter: "after",
                replaceAll: "replaceWith"
            }, function(e, t) {
                oe.fn[e] = function(e) {
                    for (var i, r = [], n = oe(e), o = n.length - 1, a = 0; o >= a; a++) i = a === o ? this : this.clone(!0), oe(n[a])[t](i), $.apply(r, i.get());
                    return this.pushStack(r)
                }
            });
            var Xe, qe = {
                    HTML: "block",
                    BODY: "block"
                },
                Ye = /^margin/,
                Ze = new RegExp("^(" + Le + ")(?!px)[a-z%]+$", "i"),
                Qe = function(t) {
                    var i = t.ownerDocument.defaultView;
                    return i && i.opener || (i = e), i.getComputedStyle(t)
                },
                Ke = function(e, t, i, r) {
                    var n, o, a = {};
                    for (o in t) a[o] = e.style[o], e.style[o] = t[o];
                    n = i.apply(e, r || []);
                    for (o in t) e.style[o] = a[o];
                    return n
                },
                $e = Z.documentElement;
            ! function() {
                function t() {
                    s.style.cssText = "-webkit-box-sizing:border-box;-moz-box-sizing:border-box;box-sizing:border-box;position:relative;display:block;margin:auto;border:1px;padding:1px;top:1%;width:50%", s.innerHTML = "", $e.appendChild(a);
                    var t = e.getComputedStyle(s);
                    i = "1%" !== t.top, o = "2px" === t.marginLeft, r = "4px" === t.width, s.style.marginRight = "50%", n = "4px" === t.marginRight, $e.removeChild(a)
                }
                var i, r, n, o, a = Z.createElement("div"),
                    s = Z.createElement("div");
                s.style && (s.style.backgroundClip = "content-box", s.cloneNode(!0).style.backgroundClip = "", re.clearCloneStyle = "content-box" === s.style.backgroundClip, a.style.cssText = "border:0;width:8px;height:0;top:0;left:-9999px;padding:0;margin-top:1px;position:absolute", a.appendChild(s), oe.extend(re, {
                    pixelPosition: function() {
                        return t(), i
                    },
                    boxSizingReliable: function() {
                        return null == r && t(), r
                    },
                    pixelMarginRight: function() {
                        return null == r && t(), n
                    },
                    reliableMarginLeft: function() {
                        return null == r && t(), o
                    },
                    reliableMarginRight: function() {
                        var t, i = s.appendChild(Z.createElement("div"));
                        return i.style.cssText = s.style.cssText = "-webkit-box-sizing:content-box;box-sizing:content-box;display:block;margin:0;border:0;padding:0", i.style.marginRight = i.style.width = "0", s.style.width = "1px", $e.appendChild(a), t = !parseFloat(e.getComputedStyle(i).marginRight), $e.removeChild(a), s.removeChild(i), t
                    }
                }))
            }();
            var Je = /^(none|table(?!-c[ea]).+)/,
                et = {
                    position: "absolute",
                    visibility: "hidden",
                    display: "block"
                },
                tt = {
                    letterSpacing: "0",
                    fontWeight: "400"
                },
                it = ["Webkit", "O", "Moz", "ms"],
                rt = Z.createElement("div").style;
            oe.extend({
                cssHooks: {
                    opacity: {
                        get: function(e, t) {
                            if (t) {
                                var i = E(e, "opacity");
                                return "" === i ? "1" : i
                            }
                        }
                    }
                },
                cssNumber: {
                    animationIterationCount: !0,
                    columnCount: !0,
                    fillOpacity: !0,
                    flexGrow: !0,
                    flexShrink: !0,
                    fontWeight: !0,
                    lineHeight: !0,
                    opacity: !0,
                    order: !0,
                    orphans: !0,
                    widows: !0,
                    zIndex: !0,
                    zoom: !0
                },
                cssProps: {
                    "float": "cssFloat"
                },
                style: function(e, t, i, r) {
                    if (e && 3 !== e.nodeType && 8 !== e.nodeType && e.style) {
                        var n, o, a, s = oe.camelCase(t),
                            l = e.style;
                        return t = oe.cssProps[s] || (oe.cssProps[s] = C(s) || s), a = oe.cssHooks[t] || oe.cssHooks[s], void 0 === i ? a && "get" in a && void 0 !== (n = a.get(e, !1, r)) ? n : l[t] : (o = typeof i, "string" === o && (n = Pe.exec(i)) && n[1] && (i = c(e, t, n), o = "number"), null != i && i === i && ("number" === o && (i += n && n[3] || (oe.cssNumber[s] ? "" : "px")), re.clearCloneStyle || "" !== i || 0 !== t.indexOf("background") || (l[t] = "inherit"), a && "set" in a && void 0 === (i = a.set(e, i, r)) || (l[t] = i)), void 0)
                    }
                },
                css: function(e, t, i, r) {
                    var n, o, a, s = oe.camelCase(t);
                    return t = oe.cssProps[s] || (oe.cssProps[s] = C(s) || s), a = oe.cssHooks[t] || oe.cssHooks[s], a && "get" in a && (n = a.get(e, !0, i)), void 0 === n && (n = E(e, t, r)), "normal" === n && t in tt && (n = tt[t]), "" === i || i ? (o = parseFloat(n), i === !0 || isFinite(o) ? o || 0 : n) : n
                }
            }), oe.each(["height", "width"], function(e, t) {
                oe.cssHooks[t] = {
                    get: function(e, i, r) {
                        return i ? Je.test(oe.css(e, "display")) && 0 === e.offsetWidth ? Ke(e, et, function() {
                            return R(e, t, r)
                        }) : R(e, t, r) : void 0
                    },
                    set: function(e, i, r) {
                        var n, o = r && Qe(e),
                            a = r && P(e, t, r, "border-box" === oe.css(e, "boxSizing", !1, o), o);
                        return a && (n = Pe.exec(i)) && "px" !== (n[3] || "px") && (e.style[t] = i, i = oe.css(e, t)), L(e, i, a)
                    }
                }
            }), oe.cssHooks.marginLeft = A(re.reliableMarginLeft, function(e, t) {
                return t ? (parseFloat(E(e, "marginLeft")) || e.getBoundingClientRect().left - Ke(e, {
                    marginLeft: 0
                }, function() {
                    return e.getBoundingClientRect().left
                })) + "px" : void 0
            }), oe.cssHooks.marginRight = A(re.reliableMarginRight, function(e, t) {
                return t ? Ke(e, {
                    display: "inline-block"
                }, E, [e, "marginRight"]) : void 0
            }), oe.each({
                margin: "",
                padding: "",
                border: "Width"
            }, function(e, t) {
                oe.cssHooks[e + t] = {
                    expand: function(i) {
                        for (var r = 0, n = {}, o = "string" == typeof i ? i.split(" ") : [i]; 4 > r; r++) n[e + Re[r] + t] = o[r] || o[r - 2] || o[0];
                        return n
                    }
                }, Ye.test(e) || (oe.cssHooks[e + t].set = L)
            }), oe.fn.extend({
                css: function(e, t) {
                    return Te(this, function(e, t, i) {
                        var r, n, o = {},
                            a = 0;
                        if (oe.isArray(t)) {
                            for (r = Qe(e), n = t.length; n > a; a++) o[t[a]] = oe.css(e, t[a], !1, r);
                            return o
                        }
                        return void 0 !== i ? oe.style(e, t, i) : oe.css(e, t)
                    }, e, t, arguments.length > 1)
                },
                show: function() {
                    return D(this, !0)
                },
                hide: function() {
                    return D(this)
                },
                toggle: function(e) {
                    return "boolean" == typeof e ? e ? this.show() : this.hide() : this.each(function() {
                        De(this) ? oe(this).show() : oe(this).hide()
                    })
                }
            }), oe.Tween = O, O.prototype = {
                constructor: O,
                init: function(e, t, i, r, n, o) {
                    this.elem = e, this.prop = i, this.easing = n || oe.easing._default, this.options = t, this.start = this.now = this.cur(), this.end = r, this.unit = o || (oe.cssNumber[i] ? "" : "px")
                },
                cur: function() {
                    var e = O.propHooks[this.prop];
                    return e && e.get ? e.get(this) : O.propHooks._default.get(this)
                },
                run: function(e) {
                    var t, i = O.propHooks[this.prop];
                    return this.options.duration ? this.pos = t = oe.easing[this.easing](e, this.options.duration * e, 0, 1, this.options.duration) : this.pos = t = e, this.now = (this.end - this.start) * t + this.start, this.options.step && this.options.step.call(this.elem, this.now, this), i && i.set ? i.set(this) : O.propHooks._default.set(this), this
                }
            }, O.prototype.init.prototype = O.prototype, O.propHooks = {
                _default: {
                    get: function(e) {
                        var t;
                        return 1 !== e.elem.nodeType || null != e.elem[e.prop] && null == e.elem.style[e.prop] ? e.elem[e.prop] : (t = oe.css(e.elem, e.prop, ""), t && "auto" !== t ? t : 0)
                    },
                    set: function(e) {
                        oe.fx.step[e.prop] ? oe.fx.step[e.prop](e) : 1 !== e.elem.nodeType || null == e.elem.style[oe.cssProps[e.prop]] && !oe.cssHooks[e.prop] ? e.elem[e.prop] = e.now : oe.style(e.elem, e.prop, e.now + e.unit)
                    }
                }
            }, O.propHooks.scrollTop = O.propHooks.scrollLeft = {
                set: function(e) {
                    e.elem.nodeType && e.elem.parentNode && (e.elem[e.prop] = e.now)
                }
            }, oe.easing = {
                linear: function(e) {
                    return e
                },
                swing: function(e) {
                    return .5 - Math.cos(e * Math.PI) / 2
                },
                _default: "swing"
            }, oe.fx = O.prototype.init, oe.fx.step = {};
            var nt, ot, at = /^(?:toggle|show|hide)$/,
                st = /queueHooks$/;
            oe.Animation = oe.extend(U, {
                    tweeners: {
                        "*": [function(e, t) {
                            var i = this.createTween(e, t);
                            return c(i.elem, e, Pe.exec(t), i), i
                        }]
                    },
                    tweener: function(e, t) {
                        oe.isFunction(e) ? (t = e, e = ["*"]) : e = e.match(be);
                        for (var i, r = 0, n = e.length; n > r; r++) i = e[r], U.tweeners[i] = U.tweeners[i] || [], U.tweeners[i].unshift(t)
                    },
                    prefilters: [B],
                    prefilter: function(e, t) {
                        t ? U.prefilters.unshift(e) : U.prefilters.push(e)
                    }
                }), oe.speed = function(e, t, i) {
                    var r = e && "object" == typeof e ? oe.extend({}, e) : {
                        complete: i || !i && t || oe.isFunction(e) && e,
                        duration: e,
                        easing: i && t || t && !oe.isFunction(t) && t
                    };
                    return r.duration = oe.fx.off ? 0 : "number" == typeof r.duration ? r.duration : r.duration in oe.fx.speeds ? oe.fx.speeds[r.duration] : oe.fx.speeds._default, null != r.queue && r.queue !== !0 || (r.queue = "fx"), r.old = r.complete, r.complete = function() {
                        oe.isFunction(r.old) && r.old.call(this), r.queue && oe.dequeue(this, r.queue)
                    }, r
                }, oe.fn.extend({
                    fadeTo: function(e, t, i, r) {
                        return this.filter(De).css("opacity", 0).show().end().animate({
                            opacity: t
                        }, e, i, r)
                    },
                    animate: function(e, t, i, r) {
                        var n = oe.isEmptyObject(e),
                            o = oe.speed(t, i, r),
                            a = function() {
                                var t = U(this, oe.extend({}, e), o);
                                (n || Se.get(this, "finish")) && t.stop(!0)
                            };
                        return a.finish = a, n || o.queue === !1 ? this.each(a) : this.queue(o.queue, a)
                    },
                    stop: function(e, t, i) {
                        var r = function(e) {
                            var t = e.stop;
                            delete e.stop, t(i)
                        };
                        return "string" != typeof e && (i = t, t = e, e = void 0), t && e !== !1 && this.queue(e || "fx", []), this.each(function() {
                            var t = !0,
                                n = null != e && e + "queueHooks",
                                o = oe.timers,
                                a = Se.get(this);
                            if (n) a[n] && a[n].stop && r(a[n]);
                            else
                                for (n in a) a[n] && a[n].stop && st.test(n) && r(a[n]);
                            for (n = o.length; n--;) o[n].elem !== this || null != e && o[n].queue !== e || (o[n].anim.stop(i), t = !1, o.splice(n, 1));
                            !t && i || oe.dequeue(this, e)
                        })
                    },
                    finish: function(e) {
                        return e !== !1 && (e = e || "fx"), this.each(function() {
                            var t, i = Se.get(this),
                                r = i[e + "queue"],
                                n = i[e + "queueHooks"],
                                o = oe.timers,
                                a = r ? r.length : 0;
                            for (i.finish = !0, oe.queue(this, e, []), n && n.stop && n.stop.call(this, !0), t = o.length; t--;) o[t].elem === this && o[t].queue === e && (o[t].anim.stop(!0), o.splice(t, 1));
                            for (t = 0; a > t; t++) r[t] && r[t].finish && r[t].finish.call(this);
                            delete i.finish
                        })
                    }
                }), oe.each(["toggle", "show", "hide"], function(e, t) {
                    var i = oe.fn[t];
                    oe.fn[t] = function(e, r, n) {
                        return null == e || "boolean" == typeof e ? i.apply(this, arguments) : this.animate(F(t, !0), e, r, n);
                    }
                }), oe.each({
                    slideDown: F("show"),
                    slideUp: F("hide"),
                    slideToggle: F("toggle"),
                    fadeIn: {
                        opacity: "show"
                    },
                    fadeOut: {
                        opacity: "hide"
                    },
                    fadeToggle: {
                        opacity: "toggle"
                    }
                }, function(e, t) {
                    oe.fn[e] = function(e, i, r) {
                        return this.animate(t, e, i, r)
                    }
                }), oe.timers = [], oe.fx.tick = function() {
                    var e, t = 0,
                        i = oe.timers;
                    for (nt = oe.now(); t < i.length; t++) e = i[t], e() || i[t] !== e || i.splice(t--, 1);
                    i.length || oe.fx.stop(), nt = void 0
                }, oe.fx.timer = function(e) {
                    oe.timers.push(e), e() ? oe.fx.start() : oe.timers.pop()
                }, oe.fx.interval = 13, oe.fx.start = function() {
                    ot || (ot = e.setInterval(oe.fx.tick, oe.fx.interval))
                }, oe.fx.stop = function() {
                    e.clearInterval(ot), ot = null
                }, oe.fx.speeds = {
                    slow: 600,
                    fast: 200,
                    _default: 400
                }, oe.fn.delay = function(t, i) {
                    return t = oe.fx ? oe.fx.speeds[t] || t : t, i = i || "fx", this.queue(i, function(i, r) {
                        var n = e.setTimeout(i, t);
                        r.stop = function() {
                            e.clearTimeout(n)
                        }
                    })
                },
                function() {
                    var e = Z.createElement("input"),
                        t = Z.createElement("select"),
                        i = t.appendChild(Z.createElement("option"));
                    e.type = "checkbox", re.checkOn = "" !== e.value, re.optSelected = i.selected, t.disabled = !0, re.optDisabled = !i.disabled, e = Z.createElement("input"), e.value = "t", e.type = "radio", re.radioValue = "t" === e.value
                }();
            var lt, ct = oe.expr.attrHandle;
            oe.fn.extend({
                attr: function(e, t) {
                    return Te(this, oe.attr, e, t, arguments.length > 1)
                },
                removeAttr: function(e) {
                    return this.each(function() {
                        oe.removeAttr(this, e)
                    })
                }
            }), oe.extend({
                attr: function(e, t, i) {
                    var r, n, o = e.nodeType;
                    if (3 !== o && 8 !== o && 2 !== o) return "undefined" == typeof e.getAttribute ? oe.prop(e, t, i) : (1 === o && oe.isXMLDoc(e) || (t = t.toLowerCase(), n = oe.attrHooks[t] || (oe.expr.match.bool.test(t) ? lt : void 0)), void 0 !== i ? null === i ? void oe.removeAttr(e, t) : n && "set" in n && void 0 !== (r = n.set(e, i, t)) ? r : (e.setAttribute(t, i + ""), i) : n && "get" in n && null !== (r = n.get(e, t)) ? r : (r = oe.find.attr(e, t), null == r ? void 0 : r))
                },
                attrHooks: {
                    type: {
                        set: function(e, t) {
                            if (!re.radioValue && "radio" === t && oe.nodeName(e, "input")) {
                                var i = e.value;
                                return e.setAttribute("type", t), i && (e.value = i), t
                            }
                        }
                    }
                },
                removeAttr: function(e, t) {
                    var i, r, n = 0,
                        o = t && t.match(be);
                    if (o && 1 === e.nodeType)
                        for (; i = o[n++];) r = oe.propFix[i] || i, oe.expr.match.bool.test(i) && (e[r] = !1), e.removeAttribute(i)
                }
            }), lt = {
                set: function(e, t, i) {
                    return t === !1 ? oe.removeAttr(e, i) : e.setAttribute(i, i), i
                }
            }, oe.each(oe.expr.match.bool.source.match(/\w+/g), function(e, t) {
                var i = ct[t] || oe.find.attr;
                ct[t] = function(e, t, r) {
                    var n, o;
                    return r || (o = ct[t], ct[t] = n, n = null != i(e, t, r) ? t.toLowerCase() : null, ct[t] = o), n
                }
            });
            var ht = /^(?:input|select|textarea|button)$/i,
                ut = /^(?:a|area)$/i;
            oe.fn.extend({
                prop: function(e, t) {
                    return Te(this, oe.prop, e, t, arguments.length > 1)
                },
                removeProp: function(e) {
                    return this.each(function() {
                        delete this[oe.propFix[e] || e]
                    })
                }
            }), oe.extend({
                prop: function(e, t, i) {
                    var r, n, o = e.nodeType;
                    if (3 !== o && 8 !== o && 2 !== o) return 1 === o && oe.isXMLDoc(e) || (t = oe.propFix[t] || t, n = oe.propHooks[t]), void 0 !== i ? n && "set" in n && void 0 !== (r = n.set(e, i, t)) ? r : e[t] = i : n && "get" in n && null !== (r = n.get(e, t)) ? r : e[t]
                },
                propHooks: {
                    tabIndex: {
                        get: function(e) {
                            var t = oe.find.attr(e, "tabindex");
                            return t ? parseInt(t, 10) : ht.test(e.nodeName) || ut.test(e.nodeName) && e.href ? 0 : -1
                        }
                    }
                },
                propFix: {
                    "for": "htmlFor",
                    "class": "className"
                }
            }), re.optSelected || (oe.propHooks.selected = {
                get: function(e) {
                    var t = e.parentNode;
                    return t && t.parentNode && t.parentNode.selectedIndex, null
                },
                set: function(e) {
                    var t = e.parentNode;
                    t && (t.selectedIndex, t.parentNode && t.parentNode.selectedIndex)
                }
            }), oe.each(["tabIndex", "readOnly", "maxLength", "cellSpacing", "cellPadding", "rowSpan", "colSpan", "useMap", "frameBorder", "contentEditable"], function() {
                oe.propFix[this.toLowerCase()] = this
            });
            var pt = /[\t\r\n\f]/g;
            oe.fn.extend({
                addClass: function(e) {
                    var t, i, r, n, o, a, s, l = 0;
                    if (oe.isFunction(e)) return this.each(function(t) {
                        oe(this).addClass(e.call(this, t, V(this)))
                    });
                    if ("string" == typeof e && e)
                        for (t = e.match(be) || []; i = this[l++];)
                            if (n = V(i), r = 1 === i.nodeType && (" " + n + " ").replace(pt, " ")) {
                                for (a = 0; o = t[a++];) r.indexOf(" " + o + " ") < 0 && (r += o + " ");
                                s = oe.trim(r), n !== s && i.setAttribute("class", s)
                            }
                    return this
                },
                removeClass: function(e) {
                    var t, i, r, n, o, a, s, l = 0;
                    if (oe.isFunction(e)) return this.each(function(t) {
                        oe(this).removeClass(e.call(this, t, V(this)))
                    });
                    if (!arguments.length) return this.attr("class", "");
                    if ("string" == typeof e && e)
                        for (t = e.match(be) || []; i = this[l++];)
                            if (n = V(i), r = 1 === i.nodeType && (" " + n + " ").replace(pt, " ")) {
                                for (a = 0; o = t[a++];)
                                    for (; r.indexOf(" " + o + " ") > -1;) r = r.replace(" " + o + " ", " ");
                                s = oe.trim(r), n !== s && i.setAttribute("class", s)
                            }
                    return this
                },
                toggleClass: function(e, t) {
                    var i = typeof e;
                    return "boolean" == typeof t && "string" === i ? t ? this.addClass(e) : this.removeClass(e) : oe.isFunction(e) ? this.each(function(i) {
                        oe(this).toggleClass(e.call(this, i, V(this), t), t)
                    }) : this.each(function() {
                        var t, r, n, o;
                        if ("string" === i)
                            for (r = 0, n = oe(this), o = e.match(be) || []; t = o[r++];) n.hasClass(t) ? n.removeClass(t) : n.addClass(t);
                        else void 0 !== e && "boolean" !== i || (t = V(this), t && Se.set(this, "__className__", t), this.setAttribute && this.setAttribute("class", t || e === !1 ? "" : Se.get(this, "__className__") || ""))
                    })
                },
                hasClass: function(e) {
                    var t, i, r = 0;
                    for (t = " " + e + " "; i = this[r++];)
                        if (1 === i.nodeType && (" " + V(i) + " ").replace(pt, " ").indexOf(t) > -1) return !0;
                    return !1
                }
            });
            var ft = /\r/g,
                dt = /[\x20\t\r\n\f]+/g;
            oe.fn.extend({
                val: function(e) {
                    var t, i, r, n = this[0]; {
                        if (arguments.length) return r = oe.isFunction(e), this.each(function(i) {
                            var n;
                            1 === this.nodeType && (n = r ? e.call(this, i, oe(this).val()) : e, null == n ? n = "" : "number" == typeof n ? n += "" : oe.isArray(n) && (n = oe.map(n, function(e) {
                                return null == e ? "" : e + ""
                            })), t = oe.valHooks[this.type] || oe.valHooks[this.nodeName.toLowerCase()], t && "set" in t && void 0 !== t.set(this, n, "value") || (this.value = n))
                        });
                        if (n) return t = oe.valHooks[n.type] || oe.valHooks[n.nodeName.toLowerCase()], t && "get" in t && void 0 !== (i = t.get(n, "value")) ? i : (i = n.value, "string" == typeof i ? i.replace(ft, "") : null == i ? "" : i)
                    }
                }
            }), oe.extend({
                valHooks: {
                    option: {
                        get: function(e) {
                            var t = oe.find.attr(e, "value");
                            return null != t ? t : oe.trim(oe.text(e)).replace(dt, " ")
                        }
                    },
                    select: {
                        get: function(e) {
                            for (var t, i, r = e.options, n = e.selectedIndex, o = "select-one" === e.type || 0 > n, a = o ? null : [], s = o ? n + 1 : r.length, l = 0 > n ? s : o ? n : 0; s > l; l++)
                                if (i = r[l], (i.selected || l === n) && (re.optDisabled ? !i.disabled : null === i.getAttribute("disabled")) && (!i.parentNode.disabled || !oe.nodeName(i.parentNode, "optgroup"))) {
                                    if (t = oe(i).val(), o) return t;
                                    a.push(t)
                                }
                            return a
                        },
                        set: function(e, t) {
                            for (var i, r, n = e.options, o = oe.makeArray(t), a = n.length; a--;) r = n[a], (r.selected = oe.inArray(oe.valHooks.option.get(r), o) > -1) && (i = !0);
                            return i || (e.selectedIndex = -1), o
                        }
                    }
                }
            }), oe.each(["radio", "checkbox"], function() {
                oe.valHooks[this] = {
                    set: function(e, t) {
                        return oe.isArray(t) ? e.checked = oe.inArray(oe(e).val(), t) > -1 : void 0
                    }
                }, re.checkOn || (oe.valHooks[this].get = function(e) {
                    return null === e.getAttribute("value") ? "on" : e.value
                })
            });
            var mt = /^(?:focusinfocus|focusoutblur)$/;
            oe.extend(oe.event, {
                trigger: function(t, i, r, n) {
                    var o, a, s, l, c, h, u, p = [r || Z],
                        f = ie.call(t, "type") ? t.type : t,
                        d = ie.call(t, "namespace") ? t.namespace.split(".") : [];
                    if (a = s = r = r || Z, 3 !== r.nodeType && 8 !== r.nodeType && !mt.test(f + oe.event.triggered) && (f.indexOf(".") > -1 && (d = f.split("."), f = d.shift(), d.sort()), c = f.indexOf(":") < 0 && "on" + f, t = t[oe.expando] ? t : new oe.Event(f, "object" == typeof t && t), t.isTrigger = n ? 2 : 3, t.namespace = d.join("."), t.rnamespace = t.namespace ? new RegExp("(^|\\.)" + d.join("\\.(?:.*\\.|)") + "(\\.|$)") : null, t.result = void 0, t.target || (t.target = r), i = null == i ? [t] : oe.makeArray(i, [t]), u = oe.event.special[f] || {}, n || !u.trigger || u.trigger.apply(r, i) !== !1)) {
                        if (!n && !u.noBubble && !oe.isWindow(r)) {
                            for (l = u.delegateType || f, mt.test(l + f) || (a = a.parentNode); a; a = a.parentNode) p.push(a), s = a;
                            s === (r.ownerDocument || Z) && p.push(s.defaultView || s.parentWindow || e)
                        }
                        for (o = 0;
                            (a = p[o++]) && !t.isPropagationStopped();) t.type = o > 1 ? l : u.bindType || f, h = (Se.get(a, "events") || {})[t.type] && Se.get(a, "handle"), h && h.apply(a, i), h = c && a[c], h && h.apply && Me(a) && (t.result = h.apply(a, i), t.result === !1 && t.preventDefault());
                        return t.type = f, n || t.isDefaultPrevented() || u._default && u._default.apply(p.pop(), i) !== !1 || !Me(r) || c && oe.isFunction(r[f]) && !oe.isWindow(r) && (s = r[c], s && (r[c] = null), oe.event.triggered = f, r[f](), oe.event.triggered = void 0, s && (r[c] = s)), t.result
                    }
                },
                simulate: function(e, t, i) {
                    var r = oe.extend(new oe.Event, i, {
                        type: e,
                        isSimulated: !0
                    });
                    oe.event.trigger(r, null, t), r.isDefaultPrevented() && i.preventDefault()
                }
            }), oe.fn.extend({
                trigger: function(e, t) {
                    return this.each(function() {
                        oe.event.trigger(e, t, this)
                    })
                },
                triggerHandler: function(e, t) {
                    var i = this[0];
                    return i ? oe.event.trigger(e, t, i, !0) : void 0
                }
            }), oe.each("blur focus focusin focusout load resize scroll unload click dblclick mousedown mouseup mousemove mouseover mouseout mouseenter mouseleave change select submit keydown keypress keyup error contextmenu".split(" "), function(e, t) {
                oe.fn[t] = function(e, i) {
                    return arguments.length > 0 ? this.on(t, null, e, i) : this.trigger(t)
                }
            }), oe.fn.extend({
                hover: function(e, t) {
                    return this.mouseenter(e).mouseleave(t || e)
                }
            }), re.focusin = "onfocusin" in e, re.focusin || oe.each({
                focus: "focusin",
                blur: "focusout"
            }, function(e, t) {
                var i = function(e) {
                    oe.event.simulate(t, e.target, oe.event.fix(e))
                };
                oe.event.special[t] = {
                    setup: function() {
                        var r = this.ownerDocument || this,
                            n = Se.access(r, t);
                        n || r.addEventListener(e, i, !0), Se.access(r, t, (n || 0) + 1)
                    },
                    teardown: function() {
                        var r = this.ownerDocument || this,
                            n = Se.access(r, t) - 1;
                        n ? Se.access(r, t, n) : (r.removeEventListener(e, i, !0), Se.remove(r, t))
                    }
                }
            });
            var gt = e.location,
                vt = oe.now(),
                yt = /\?/;
            oe.parseJSON = function(e) {
                return JSON.parse(e + "")
            }, oe.parseXML = function(t) {
                var i;
                if (!t || "string" != typeof t) return null;
                try {
                    i = (new e.DOMParser).parseFromString(t, "text/xml")
                } catch (r) {
                    i = void 0
                }
                return i && !i.getElementsByTagName("parsererror").length || oe.error("Invalid XML: " + t), i
            };
            var _t = /#.*$/,
                xt = /([?&])_=[^&]*/,
                bt = /^(.*?):[ \t]*([^\r\n]*)$/gm,
                wt = /^(?:about|app|app-storage|.+-extension|file|res|widget):$/,
                Tt = /^(?:GET|HEAD)$/,
                Mt = /^\/\//,
                St = {},
                Et = {},
                At = "*/".concat("*"),
                Ct = Z.createElement("a");
            Ct.href = gt.href, oe.extend({
                active: 0,
                lastModified: {},
                etag: {},
                ajaxSettings: {
                    url: gt.href,
                    type: "GET",
                    isLocal: wt.test(gt.protocol),
                    global: !0,
                    processData: !0,
                    async: !0,
                    contentType: "application/x-www-form-urlencoded; charset=UTF-8",
                    accepts: {
                        "*": At,
                        text: "text/plain",
                        html: "text/html",
                        xml: "application/xml, text/xml",
                        json: "application/json, text/javascript"
                    },
                    contents: {
                        xml: /\bxml\b/,
                        html: /\bhtml/,
                        json: /\bjson\b/
                    },
                    responseFields: {
                        xml: "responseXML",
                        text: "responseText",
                        json: "responseJSON"
                    },
                    converters: {
                        "* text": String,
                        "text html": !0,
                        "text json": oe.parseJSON,
                        "text xml": oe.parseXML
                    },
                    flatOptions: {
                        url: !0,
                        context: !0
                    }
                },
                ajaxSetup: function(e, t) {
                    return t ? H(H(e, oe.ajaxSettings), t) : H(oe.ajaxSettings, e)
                },
                ajaxPrefilter: z(St),
                ajaxTransport: z(Et),
                ajax: function(t, i) {
                    function r(t, i, r, s) {
                        var c, u, y, _, b, T = i;
                        2 !== x && (x = 2, l && e.clearTimeout(l), n = void 0, a = s || "", w.readyState = t > 0 ? 4 : 0, c = t >= 200 && 300 > t || 304 === t, r && (_ = j(p, w, r)), _ = W(p, _, w, c), c ? (p.ifModified && (b = w.getResponseHeader("Last-Modified"), b && (oe.lastModified[o] = b), b = w.getResponseHeader("etag"), b && (oe.etag[o] = b)), 204 === t || "HEAD" === p.type ? T = "nocontent" : 304 === t ? T = "notmodified" : (T = _.state, u = _.data, y = _.error, c = !y)) : (y = T, !t && T || (T = "error", 0 > t && (t = 0))), w.status = t, w.statusText = (i || T) + "", c ? m.resolveWith(f, [u, T, w]) : m.rejectWith(f, [w, T, y]), w.statusCode(v), v = void 0, h && d.trigger(c ? "ajaxSuccess" : "ajaxError", [w, p, c ? u : y]), g.fireWith(f, [w, T]), h && (d.trigger("ajaxComplete", [w, p]), --oe.active || oe.event.trigger("ajaxStop")))
                    }
                    "object" == typeof t && (i = t, t = void 0), i = i || {};
                    var n, o, a, s, l, c, h, u, p = oe.ajaxSetup({}, i),
                        f = p.context || p,
                        d = p.context && (f.nodeType || f.jquery) ? oe(f) : oe.event,
                        m = oe.Deferred(),
                        g = oe.Callbacks("once memory"),
                        v = p.statusCode || {},
                        y = {},
                        _ = {},
                        x = 0,
                        b = "canceled",
                        w = {
                            readyState: 0,
                            getResponseHeader: function(e) {
                                var t;
                                if (2 === x) {
                                    if (!s)
                                        for (s = {}; t = bt.exec(a);) s[t[1].toLowerCase()] = t[2];
                                    t = s[e.toLowerCase()]
                                }
                                return null == t ? null : t
                            },
                            getAllResponseHeaders: function() {
                                return 2 === x ? a : null
                            },
                            setRequestHeader: function(e, t) {
                                var i = e.toLowerCase();
                                return x || (e = _[i] = _[i] || e, y[e] = t), this
                            },
                            overrideMimeType: function(e) {
                                return x || (p.mimeType = e), this
                            },
                            statusCode: function(e) {
                                var t;
                                if (e)
                                    if (2 > x)
                                        for (t in e) v[t] = [v[t], e[t]];
                                    else w.always(e[w.status]);
                                return this
                            },
                            abort: function(e) {
                                var t = e || b;
                                return n && n.abort(t), r(0, t), this
                            }
                        };
                    if (m.promise(w).complete = g.add, w.success = w.done, w.error = w.fail, p.url = ((t || p.url || gt.href) + "").replace(_t, "").replace(Mt, gt.protocol + "//"), p.type = i.method || i.type || p.method || p.type, p.dataTypes = oe.trim(p.dataType || "*").toLowerCase().match(be) || [""], null == p.crossDomain) {
                        c = Z.createElement("a");
                        try {
                            c.href = p.url, c.href = c.href, p.crossDomain = Ct.protocol + "//" + Ct.host != c.protocol + "//" + c.host
                        } catch (T) {
                            p.crossDomain = !0
                        }
                    }
                    if (p.data && p.processData && "string" != typeof p.data && (p.data = oe.param(p.data, p.traditional)), G(St, p, i, w), 2 === x) return w;
                    h = oe.event && p.global, h && 0 === oe.active++ && oe.event.trigger("ajaxStart"), p.type = p.type.toUpperCase(), p.hasContent = !Tt.test(p.type), o = p.url, p.hasContent || (p.data && (o = p.url += (yt.test(o) ? "&" : "?") + p.data, delete p.data), p.cache === !1 && (p.url = xt.test(o) ? o.replace(xt, "$1_=" + vt++) : o + (yt.test(o) ? "&" : "?") + "_=" + vt++)), p.ifModified && (oe.lastModified[o] && w.setRequestHeader("If-Modified-Since", oe.lastModified[o]), oe.etag[o] && w.setRequestHeader("If-None-Match", oe.etag[o])), (p.data && p.hasContent && p.contentType !== !1 || i.contentType) && w.setRequestHeader("Content-Type", p.contentType), w.setRequestHeader("Accept", p.dataTypes[0] && p.accepts[p.dataTypes[0]] ? p.accepts[p.dataTypes[0]] + ("*" !== p.dataTypes[0] ? ", " + At + "; q=0.01" : "") : p.accepts["*"]);
                    for (u in p.headers) w.setRequestHeader(u, p.headers[u]);
                    if (p.beforeSend && (p.beforeSend.call(f, w, p) === !1 || 2 === x)) return w.abort();
                    b = "abort";
                    for (u in {
                            success: 1,
                            error: 1,
                            complete: 1
                        }) w[u](p[u]);
                    if (n = G(Et, p, i, w)) {
                        if (w.readyState = 1, h && d.trigger("ajaxSend", [w, p]), 2 === x) return w;
                        p.async && p.timeout > 0 && (l = e.setTimeout(function() {
                            w.abort("timeout")
                        }, p.timeout));
                        try {
                            x = 1, n.send(y, r)
                        } catch (T) {
                            if (!(2 > x)) throw T;
                            r(-1, T)
                        }
                    } else r(-1, "No Transport");
                    return w
                },
                getJSON: function(e, t, i) {
                    return oe.get(e, t, i, "json")
                },
                getScript: function(e, t) {
                    return oe.get(e, void 0, t, "script")
                }
            }), oe.each(["get", "post"], function(e, t) {
                oe[t] = function(e, i, r, n) {
                    return oe.isFunction(i) && (n = n || r, r = i, i = void 0), oe.ajax(oe.extend({
                        url: e,
                        type: t,
                        dataType: n,
                        data: i,
                        success: r
                    }, oe.isPlainObject(e) && e))
                }
            }), oe._evalUrl = function(e) {
                return oe.ajax({
                    url: e,
                    type: "GET",
                    dataType: "script",
                    async: !1,
                    global: !1,
                    "throws": !0
                })
            }, oe.fn.extend({
                wrapAll: function(e) {
                    var t;
                    return oe.isFunction(e) ? this.each(function(t) {
                        oe(this).wrapAll(e.call(this, t))
                    }) : (this[0] && (t = oe(e, this[0].ownerDocument).eq(0).clone(!0), this[0].parentNode && t.insertBefore(this[0]), t.map(function() {
                        for (var e = this; e.firstElementChild;) e = e.firstElementChild;
                        return e
                    }).append(this)), this)
                },
                wrapInner: function(e) {
                    return oe.isFunction(e) ? this.each(function(t) {
                        oe(this).wrapInner(e.call(this, t))
                    }) : this.each(function() {
                        var t = oe(this),
                            i = t.contents();
                        i.length ? i.wrapAll(e) : t.append(e)
                    })
                },
                wrap: function(e) {
                    var t = oe.isFunction(e);
                    return this.each(function(i) {
                        oe(this).wrapAll(t ? e.call(this, i) : e)
                    })
                },
                unwrap: function() {
                    return this.parent().each(function() {
                        oe.nodeName(this, "body") || oe(this).replaceWith(this.childNodes)
                    }).end()
                }
            }), oe.expr.filters.hidden = function(e) {
                return !oe.expr.filters.visible(e)
            }, oe.expr.filters.visible = function(e) {
                return e.offsetWidth > 0 || e.offsetHeight > 0 || e.getClientRects().length > 0
            };
            var Lt = /%20/g,
                Pt = /\[\]$/,
                Rt = /\r?\n/g,
                Dt = /^(?:submit|button|image|reset|file)$/i,
                Ot = /^(?:input|select|textarea|keygen)/i;
            oe.param = function(e, t) {
                var i, r = [],
                    n = function(e, t) {
                        t = oe.isFunction(t) ? t() : null == t ? "" : t, r[r.length] = encodeURIComponent(e) + "=" + encodeURIComponent(t)
                    };
                if (void 0 === t && (t = oe.ajaxSettings && oe.ajaxSettings.traditional), oe.isArray(e) || e.jquery && !oe.isPlainObject(e)) oe.each(e, function() {
                    n(this.name, this.value)
                });
                else
                    for (i in e) X(i, e[i], t, n);
                return r.join("&").replace(Lt, "+")
            }, oe.fn.extend({
                serialize: function() {
                    return oe.param(this.serializeArray())
                },
                serializeArray: function() {
                    return this.map(function() {
                        var e = oe.prop(this, "elements");
                        return e ? oe.makeArray(e) : this
                    }).filter(function() {
                        var e = this.type;
                        return this.name && !oe(this).is(":disabled") && Ot.test(this.nodeName) && !Dt.test(e) && (this.checked || !Oe.test(e))
                    }).map(function(e, t) {
                        var i = oe(this).val();
                        return null == i ? null : oe.isArray(i) ? oe.map(i, function(e) {
                            return {
                                name: t.name,
                                value: e.replace(Rt, "\r\n")
                            }
                        }) : {
                            name: t.name,
                            value: i.replace(Rt, "\r\n")
                        }
                    }).get()
                }
            }), oe.ajaxSettings.xhr = function() {
                try {
                    return new e.XMLHttpRequest
                } catch (t) {}
            };
            var It = {
                    0: 200,
                    1223: 204
                },
                Ft = oe.ajaxSettings.xhr();
            re.cors = !!Ft && "withCredentials" in Ft, re.ajax = Ft = !!Ft, oe.ajaxTransport(function(t) {
                var i, r;
                return re.cors || Ft && !t.crossDomain ? {
                    send: function(n, o) {
                        var a, s = t.xhr();
                        if (s.open(t.type, t.url, t.async, t.username, t.password), t.xhrFields)
                            for (a in t.xhrFields) s[a] = t.xhrFields[a];
                        t.mimeType && s.overrideMimeType && s.overrideMimeType(t.mimeType), t.crossDomain || n["X-Requested-With"] || (n["X-Requested-With"] = "XMLHttpRequest");
                        for (a in n) s.setRequestHeader(a, n[a]);
                        i = function(e) {
                            return function() {
                                i && (i = r = s.onload = s.onerror = s.onabort = s.onreadystatechange = null, "abort" === e ? s.abort() : "error" === e ? "number" != typeof s.status ? o(0, "error") : o(s.status, s.statusText) : o(It[s.status] || s.status, s.statusText, "text" !== (s.responseType || "text") || "string" != typeof s.responseText ? {
                                    binary: s.response
                                } : {
                                    text: s.responseText
                                }, s.getAllResponseHeaders()))
                            }
                        }, s.onload = i(), r = s.onerror = i("error"), void 0 !== s.onabort ? s.onabort = r : s.onreadystatechange = function() {
                            4 === s.readyState && e.setTimeout(function() {
                                i && r()
                            })
                        }, i = i("abort");
                        try {
                            s.send(t.hasContent && t.data || null)
                        } catch (l) {
                            if (i) throw l
                        }
                    },
                    abort: function() {
                        i && i()
                    }
                } : void 0
            }), oe.ajaxSetup({
                accepts: {
                    script: "text/javascript, application/javascript, application/ecmascript, application/x-ecmascript"
                },
                contents: {
                    script: /\b(?:java|ecma)script\b/
                },
                converters: {
                    "text script": function(e) {
                        return oe.globalEval(e), e
                    }
                }
            }), oe.ajaxPrefilter("script", function(e) {
                void 0 === e.cache && (e.cache = !1), e.crossDomain && (e.type = "GET")
            }), oe.ajaxTransport("script", function(e) {
                if (e.crossDomain) {
                    var t, i;
                    return {
                        send: function(r, n) {
                            t = oe("<script>").prop({
                                charset: e.scriptCharset,
                                src: e.url
                            }).on("load error", i = function(e) {
                                t.remove(), i = null, e && n("error" === e.type ? 404 : 200, e.type)
                            }), Z.head.appendChild(t[0])
                        },
                        abort: function() {
                            i && i()
                        }
                    }
                }
            });
            var Nt = [],
                Bt = /(=)\?(?=&|$)|\?\?/;
            oe.ajaxSetup({
                jsonp: "callback",
                jsonpCallback: function() {
                    var e = Nt.pop() || oe.expando + "_" + vt++;
                    return this[e] = !0, e
                }
            }), oe.ajaxPrefilter("json jsonp", function(t, i, r) {
                var n, o, a, s = t.jsonp !== !1 && (Bt.test(t.url) ? "url" : "string" == typeof t.data && 0 === (t.contentType || "").indexOf("application/x-www-form-urlencoded") && Bt.test(t.data) && "data");
                return s || "jsonp" === t.dataTypes[0] ? (n = t.jsonpCallback = oe.isFunction(t.jsonpCallback) ? t.jsonpCallback() : t.jsonpCallback, s ? t[s] = t[s].replace(Bt, "$1" + n) : t.jsonp !== !1 && (t.url += (yt.test(t.url) ? "&" : "?") + t.jsonp + "=" + n), t.converters["script json"] = function() {
                    return a || oe.error(n + " was not called"), a[0]
                }, t.dataTypes[0] = "json", o = e[n], e[n] = function() {
                    a = arguments
                }, r.always(function() {
                    void 0 === o ? oe(e).removeProp(n) : e[n] = o, t[n] && (t.jsonpCallback = i.jsonpCallback, Nt.push(n)), a && oe.isFunction(o) && o(a[0]), a = o = void 0
                }), "script") : void 0
            }), oe.parseHTML = function(e, t, i) {
                if (!e || "string" != typeof e) return null;
                "boolean" == typeof t && (i = t, t = !1), t = t || Z;
                var r = de.exec(e),
                    n = !i && [];
                return r ? [t.createElement(r[1])] : (r = p([e], t, n), n && n.length && oe(n).remove(), oe.merge([], r.childNodes))
            };
            var kt = oe.fn.load;
            oe.fn.load = function(e, t, i) {
                if ("string" != typeof e && kt) return kt.apply(this, arguments);
                var r, n, o, a = this,
                    s = e.indexOf(" ");
                return s > -1 && (r = oe.trim(e.slice(s)), e = e.slice(0, s)), oe.isFunction(t) ? (i = t, t = void 0) : t && "object" == typeof t && (n = "POST"), a.length > 0 && oe.ajax({
                    url: e,
                    type: n || "GET",
                    dataType: "html",
                    data: t
                }).done(function(e) {
                    o = arguments, a.html(r ? oe("<div>").append(oe.parseHTML(e)).find(r) : e)
                }).always(i && function(e, t) {
                    a.each(function() {
                        i.apply(a, o || [e.responseText, t, e])
                    })
                }), this
            }, oe.each(["ajaxStart", "ajaxStop", "ajaxComplete", "ajaxError", "ajaxSuccess", "ajaxSend"], function(e, t) {
                oe.fn[t] = function(e) {
                    return this.on(t, e)
                }
            }), oe.expr.filters.animated = function(e) {
                return oe.grep(oe.timers, function(t) {
                    return e === t.elem
                }).length
            }, oe.offset = {
                setOffset: function(e, t, i) {
                    var r, n, o, a, s, l, c, h = oe.css(e, "position"),
                        u = oe(e),
                        p = {};
                    "static" === h && (e.style.position = "relative"), s = u.offset(), o = oe.css(e, "top"), l = oe.css(e, "left"), c = ("absolute" === h || "fixed" === h) && (o + l).indexOf("auto") > -1, c ? (r = u.position(), a = r.top, n = r.left) : (a = parseFloat(o) || 0, n = parseFloat(l) || 0), oe.isFunction(t) && (t = t.call(e, i, oe.extend({}, s))), null != t.top && (p.top = t.top - s.top + a), null != t.left && (p.left = t.left - s.left + n), "using" in t ? t.using.call(e, p) : u.css(p)
                }
            }, oe.fn.extend({
                offset: function(e) {
                    if (arguments.length) return void 0 === e ? this : this.each(function(t) {
                        oe.offset.setOffset(this, e, t)
                    });
                    var t, i, r = this[0],
                        n = {
                            top: 0,
                            left: 0
                        },
                        o = r && r.ownerDocument;
                    if (o) return t = o.documentElement, oe.contains(t, r) ? (n = r.getBoundingClientRect(), i = q(o), {
                        top: n.top + i.pageYOffset - t.clientTop,
                        left: n.left + i.pageXOffset - t.clientLeft
                    }) : n
                },
                position: function() {
                    if (this[0]) {
                        var e, t, i = this[0],
                            r = {
                                top: 0,
                                left: 0
                            };
                        return "fixed" === oe.css(i, "position") ? t = i.getBoundingClientRect() : (e = this.offsetParent(), t = this.offset(), oe.nodeName(e[0], "html") || (r = e.offset()), r.top += oe.css(e[0], "borderTopWidth", !0), r.left += oe.css(e[0], "borderLeftWidth", !0)), {
                            top: t.top - r.top - oe.css(i, "marginTop", !0),
                            left: t.left - r.left - oe.css(i, "marginLeft", !0)
                        }
                    }
                },
                offsetParent: function() {
                    return this.map(function() {
                        for (var e = this.offsetParent; e && "static" === oe.css(e, "position");) e = e.offsetParent;
                        return e || $e
                    })
                }
            }), oe.each({
                scrollLeft: "pageXOffset",
                scrollTop: "pageYOffset"
            }, function(e, t) {
                var i = "pageYOffset" === t;
                oe.fn[e] = function(r) {
                    return Te(this, function(e, r, n) {
                        var o = q(e);
                        return void 0 === n ? o ? o[t] : e[r] : void(o ? o.scrollTo(i ? o.pageXOffset : n, i ? n : o.pageYOffset) : e[r] = n)
                    }, e, r, arguments.length)
                }
            }), oe.each(["top", "left"], function(e, t) {
                oe.cssHooks[t] = A(re.pixelPosition, function(e, i) {
                    return i ? (i = E(e, t), Ze.test(i) ? oe(e).position()[t] + "px" : i) : void 0
                })
            }), oe.each({
                Height: "height",
                Width: "width"
            }, function(e, t) {
                oe.each({
                    padding: "inner" + e,
                    content: t,
                    "": "outer" + e
                }, function(i, r) {
                    oe.fn[r] = function(r, n) {
                        var o = arguments.length && (i || "boolean" != typeof r),
                            a = i || (r === !0 || n === !0 ? "margin" : "border");
                        return Te(this, function(t, i, r) {
                            var n;
                            return oe.isWindow(t) ? t.document.documentElement["client" + e] : 9 === t.nodeType ? (n = t.documentElement, Math.max(t.body["scroll" + e], n["scroll" + e], t.body["offset" + e], n["offset" + e], n["client" + e])) : void 0 === r ? oe.css(t, i, a) : oe.style(t, i, r, a)
                        }, t, o ? r : void 0, o, null)
                    }
                })
            }), oe.fn.extend({
                bind: function(e, t, i) {
                    return this.on(e, null, t, i)
                },
                unbind: function(e, t) {
                    return this.off(e, null, t)
                },
                delegate: function(e, t, i, r) {
                    return this.on(t, e, i, r)
                },
                undelegate: function(e, t, i) {
                    return 1 === arguments.length ? this.off(e, "**") : this.off(t, e || "**", i)
                },
                size: function() {
                    return this.length
                }
            }), oe.fn.andSelf = oe.fn.addBack, "function" == typeof define && define.amd && define("jquery", [], function() {
                return oe
            });
            var Ut = e.jQuery,
                Vt = e.$;
            return oe.noConflict = function(t) {
                return e.$ === oe && (e.$ = Vt), t && e.jQuery === oe && (e.jQuery = Ut), oe
            }, t || (e.jQuery = e.$ = oe), oe
        })
    }, {}],
    5: [function(e, t, i) {
        ! function(e, r) {
            "function" == typeof define && define.amd ? define(r) : "object" == typeof i ? t.exports = r() : e.ScrollMagic = r()
        }(this, function() {
            "use strict";
            var e = function() {
                n.log(2, "(COMPATIBILITY NOTICE) -> As of ScrollMagic 2.0.0 you need to use 'new ScrollMagic.Controller()' to create a new controller instance. Use 'new ScrollMagic.Scene()' to instance a scene.")
            };
            e.version = "2.0.5", window.addEventListener("mousewheel", function() {});
            var t = "data-scrollmagic-pin-spacer";
            e.Controller = function(r) {
                var o, a, s = "ScrollMagic.Controller",
                    l = "FORWARD",
                    c = "REVERSE",
                    h = "PAUSED",
                    u = i.defaults,
                    p = this,
                    f = n.extend({}, u, r),
                    d = [],
                    m = !1,
                    g = 0,
                    v = h,
                    y = !0,
                    _ = 0,
                    x = !0,
                    b = function() {
                        for (var t in f) u.hasOwnProperty(t) || (P(2, 'WARNING: Unknown option "' + t + '"'), delete f[t]);
                        if (f.container = n.get.elements(f.container)[0], !f.container) throw P(1, "ERROR creating object " + s + ": No valid scroll container supplied"), s + " init failed.";
                        y = f.container === window || f.container === document.body || !document.body.contains(f.container), y && (f.container = window), _ = M(), f.container.addEventListener("resize", C), f.container.addEventListener("scroll", C), f.refreshInterval = parseInt(f.refreshInterval) || u.refreshInterval, w(), P(3, "added new " + s + " controller (v" + e.version + ")")
                    },
                    w = function() {
                        f.refreshInterval > 0 && (a = window.setTimeout(L, f.refreshInterval))
                    },
                    T = function() {
                        return f.vertical ? n.get.scrollTop(f.container) : n.get.scrollLeft(f.container)
                    },
                    M = function() {
                        return f.vertical ? n.get.height(f.container) : n.get.width(f.container)
                    },
                    S = this._setScrollPos = function(e) {
                        f.vertical ? y ? window.scrollTo(n.get.scrollLeft(), e) : f.container.scrollTop = e : y ? window.scrollTo(e, n.get.scrollTop()) : f.container.scrollLeft = e
                    },
                    E = function() {
                        if (x && m) {
                            var e = n.type.Array(m) ? m : d.slice(0);
                            m = !1;
                            var t = g;
                            g = p.scrollPos();
                            var i = g - t;
                            0 !== i && (v = i > 0 ? l : c), v === c && e.reverse(), e.forEach(function(t, i) {
                                P(3, "updating Scene " + (i + 1) + "/" + e.length + " (" + d.length + " total)"), t.update(!0)
                            }), 0 === e.length && f.loglevel >= 3 && P(3, "updating 0 Scenes (nothing added to controller)")
                        }
                    },
                    A = function() {
                        o = n.rAF(E)
                    },
                    C = function(e) {
                        P(3, "event fired causing an update:", e.type), "resize" == e.type && (_ = M(), v = h), m !== !0 && (m = !0, A())
                    },
                    L = function() {
                        if (!y && _ != M()) {
                            var e;
                            try {
                                e = new Event("resize", {
                                    bubbles: !1,
                                    cancelable: !1
                                })
                            } catch (t) {
                                e = document.createEvent("Event"), e.initEvent("resize", !1, !1)
                            }
                            f.container.dispatchEvent(e)
                        }
                        d.forEach(function(e, t) {
                            e.refresh()
                        }), w()
                    },
                    P = this._log = function(e, t) {
                        f.loglevel >= e && (Array.prototype.splice.call(arguments, 1, 0, "(" + s + ") ->"), n.log.apply(window, arguments))
                    };
                this._options = f;
                var R = function(e) {
                    if (e.length <= 1) return e;
                    var t = e.slice(0);
                    return t.sort(function(e, t) {
                        return e.scrollOffset() > t.scrollOffset() ? 1 : -1
                    }), t
                };
                return this.addScene = function(t) {
                    if (n.type.Array(t)) t.forEach(function(e, t) {
                        p.addScene(e)
                    });
                    else if (t instanceof e.Scene) {
                        if (t.controller() !== p) t.addTo(p);
                        else if (d.indexOf(t) < 0) {
                            d.push(t), d = R(d), t.on("shift.controller_sort", function() {
                                d = R(d)
                            });
                            for (var i in f.globalSceneOptions) t[i] && t[i].call(t, f.globalSceneOptions[i]);
                            P(3, "adding Scene (now " + d.length + " total)")
                        }
                    } else P(1, "ERROR: invalid argument supplied for '.addScene()'");
                    return p
                }, this.removeScene = function(e) {
                    if (n.type.Array(e)) e.forEach(function(e, t) {
                        p.removeScene(e)
                    });
                    else {
                        var t = d.indexOf(e);
                        t > -1 && (e.off("shift.controller_sort"), d.splice(t, 1), P(3, "removing Scene (now " + d.length + " left)"), e.remove())
                    }
                    return p
                }, this.updateScene = function(t, i) {
                    return n.type.Array(t) ? t.forEach(function(e, t) {
                        p.updateScene(e, i)
                    }) : i ? t.update(!0) : m !== !0 && t instanceof e.Scene && (m = m || [], -1 == m.indexOf(t) && m.push(t), m = R(m), A()), p
                }, this.update = function(e) {
                    return C({
                        type: "resize"
                    }), e && E(), p
                }, this.scrollTo = function(i, r) {
                    if (n.type.Number(i)) S.call(f.container, i, r);
                    else if (i instanceof e.Scene) i.controller() === p ? p.scrollTo(i.scrollOffset(), r) : P(2, "scrollTo(): The supplied scene does not belong to this controller. Scroll cancelled.", i);
                    else if (n.type.Function(i)) S = i;
                    else {
                        var o = n.get.elements(i)[0];
                        if (o) {
                            for (; o.parentNode.hasAttribute(t);) o = o.parentNode;
                            var a = f.vertical ? "top" : "left",
                                s = n.get.offset(f.container),
                                l = n.get.offset(o);
                            y || (s[a] -= p.scrollPos()), p.scrollTo(l[a] - s[a], r)
                        } else P(2, "scrollTo(): The supplied argument is invalid. Scroll cancelled.", i)
                    }
                    return p
                }, this.scrollPos = function(e) {
                    return arguments.length ? (n.type.Function(e) ? T = e : P(2, "Provided value for method 'scrollPos' is not a function. To change the current scroll position use 'scrollTo()'."), p) : T.call(p)
                }, this.info = function(e) {
                    var t = {
                        size: _,
                        vertical: f.vertical,
                        scrollPos: g,
                        scrollDirection: v,
                        container: f.container,
                        isDocument: y
                    };
                    return arguments.length ? void 0 !== t[e] ? t[e] : void P(1, 'ERROR: option "' + e + '" is not available') : t
                }, this.loglevel = function(e) {
                    return arguments.length ? (f.loglevel != e && (f.loglevel = e), p) : f.loglevel
                }, this.enabled = function(e) {
                    return arguments.length ? (x != e && (x = !!e, p.updateScene(d, !0)), p) : x
                }, this.destroy = function(e) {
                    window.clearTimeout(a);
                    for (var t = d.length; t--;) d[t].destroy(e);
                    return f.container.removeEventListener("resize", C), f.container.removeEventListener("scroll", C), n.cAF(o), P(3, "destroyed " + s + " (reset: " + (e ? "true" : "false") + ")"), null
                }, b(), p
            };
            var i = {
                defaults: {
                    container: window,
                    vertical: !0,
                    globalSceneOptions: {},
                    loglevel: 2,
                    refreshInterval: 100
                }
            };
            e.Controller.addOption = function(e, t) {
                i.defaults[e] = t
            }, e.Controller.extend = function(t) {
                var i = this;
                e.Controller = function() {
                    return i.apply(this, arguments), this.$super = n.extend({}, this), t.apply(this, arguments) || this
                }, n.extend(e.Controller, i), e.Controller.prototype = i.prototype, e.Controller.prototype.constructor = e.Controller
            }, e.Scene = function(i) {
                var o, a, s = "ScrollMagic.Scene",
                    l = "BEFORE",
                    c = "DURING",
                    h = "AFTER",
                    u = r.defaults,
                    p = this,
                    f = n.extend({}, u, i),
                    d = l,
                    m = 0,
                    g = {
                        start: 0,
                        end: 0
                    },
                    v = 0,
                    y = !0,
                    _ = function() {
                        for (var e in f) u.hasOwnProperty(e) || (b(2, 'WARNING: Unknown option "' + e + '"'), delete f[e]);
                        for (var t in u) L(t);
                        A()
                    },
                    x = {};
                this.on = function(e, t) {
                    return n.type.Function(t) ? (e = e.trim().split(" "), e.forEach(function(e) {
                        var i = e.split("."),
                            r = i[0],
                            n = i[1];
                        "*" != r && (x[r] || (x[r] = []), x[r].push({
                            namespace: n || "",
                            callback: t
                        }))
                    })) : b(1, "ERROR when calling '.on()': Supplied callback for '" + e + "' is not a valid function!"), p
                }, this.off = function(e, t) {
                    return e ? (e = e.trim().split(" "), e.forEach(function(e, i) {
                        var r = e.split("."),
                            n = r[0],
                            o = r[1] || "",
                            a = "*" === n ? Object.keys(x) : [n];
                        a.forEach(function(e) {
                            for (var i = x[e] || [], r = i.length; r--;) {
                                var n = i[r];
                                !n || o !== n.namespace && "*" !== o || t && t != n.callback || i.splice(r, 1)
                            }
                            i.length || delete x[e]
                        })
                    }), p) : (b(1, "ERROR: Invalid event name supplied."), p)
                }, this.trigger = function(t, i) {
                    if (t) {
                        var r = t.trim().split("."),
                            n = r[0],
                            o = r[1],
                            a = x[n];
                        b(3, "event fired:", n, i ? "->" : "", i || ""), a && a.forEach(function(t, r) {
                            o && o !== t.namespace || t.callback.call(p, new e.Event(n, t.namespace, p, i))
                        })
                    } else b(1, "ERROR: Invalid event name supplied.");
                    return p
                }, p.on("change.internal", function(e) {
                    "loglevel" !== e.what && "tweenChanges" !== e.what && ("triggerElement" === e.what ? M() : "reverse" === e.what && p.update())
                }).on("shift.internal", function(e) {
                    w(), p.update()
                });
                var b = this._log = function(e, t) {
                    f.loglevel >= e && (Array.prototype.splice.call(arguments, 1, 0, "(" + s + ") ->"), n.log.apply(window, arguments))
                };
                this.addTo = function(t) {
                    return t instanceof e.Controller ? a != t && (a && a.removeScene(p), a = t, A(), T(!0), M(!0), w(), a.info("container").addEventListener("resize", S), t.addScene(p), p.trigger("add", {
                        controller: a
                    }), b(3, "added " + s + " to controller"), p.update()) : b(1, "ERROR: supplied argument of 'addTo()' is not a valid ScrollMagic Controller"), p
                }, this.enabled = function(e) {
                    return arguments.length ? (y != e && (y = !!e, p.update(!0)), p) : y
                }, this.remove = function() {
                    if (a) {
                        a.info("container").removeEventListener("resize", S);
                        var e = a;
                        a = void 0, e.removeScene(p), p.trigger("remove"), b(3, "removed " + s + " from controller")
                    }
                    return p
                }, this.destroy = function(e) {
                    return p.trigger("destroy", {
                        reset: e
                    }), p.remove(), p.off("*.*"), b(3, "destroyed " + s + " (reset: " + (e ? "true" : "false") + ")"), null
                }, this.update = function(e) {
                    if (a)
                        if (e)
                            if (a.enabled() && y) {
                                var t, i = a.info("scrollPos");
                                t = f.duration > 0 ? (i - g.start) / (g.end - g.start) : i >= g.start ? 1 : 0, p.trigger("update", {
                                    startPos: g.start,
                                    endPos: g.end,
                                    scrollPos: i
                                }), p.progress(t)
                            } else P && d === c && D(!0);
                    else a.updateScene(p, !1);
                    return p
                }, this.refresh = function() {
                    return T(), M(), p
                }, this.progress = function(e) {
                    if (arguments.length) {
                        var t = !1,
                            i = d,
                            r = a ? a.info("scrollDirection") : "PAUSED",
                            n = f.reverse || e >= m;
                        if (0 === f.duration ? (t = m != e, m = 1 > e && n ? 0 : 1, d = 0 === m ? l : c) : 0 > e && d !== l && n ? (m = 0, d = l, t = !0) : e >= 0 && 1 > e && n ? (m = e, d = c, t = !0) : e >= 1 && d !== h ? (m = 1, d = h, t = !0) : d !== c || n || D(), t) {
                            var o = {
                                    progress: m,
                                    state: d,
                                    scrollDirection: r
                                },
                                s = d != i,
                                u = function(e) {
                                    p.trigger(e, o)
                                };
                            s && i !== c && (u("enter"), u(i === l ? "start" : "end")), u("progress"), s && d !== c && (u(d === l ? "start" : "end"), u("leave"))
                        }
                        return p
                    }
                    return m
                };
                var w = function() {
                        g = {
                            start: v + f.offset
                        }, a && f.triggerElement && (g.start -= a.info("size") * f.triggerHook), g.end = g.start + f.duration
                    },
                    T = function(e) {
                        if (o) {
                            var t = "duration";
                            C(t, o.call(p)) && !e && (p.trigger("change", {
                                what: t,
                                newval: f[t]
                            }), p.trigger("shift", {
                                reason: t
                            }))
                        }
                    },
                    M = function(e) {
                        var i = 0,
                            r = f.triggerElement;
                        if (a && r) {
                            for (var o = a.info(), s = n.get.offset(o.container), l = o.vertical ? "top" : "left"; r.parentNode.hasAttribute(t);) r = r.parentNode;
                            var c = n.get.offset(r);
                            o.isDocument || (s[l] -= a.scrollPos()), i = c[l] - s[l]
                        }
                        var h = i != v;
                        v = i, h && !e && p.trigger("shift", {
                            reason: "triggerElementPosition"
                        })
                    },
                    S = function(e) {
                        f.triggerHook > 0 && p.trigger("shift", {
                            reason: "containerResize"
                        })
                    },
                    E = n.extend(r.validate, {
                        duration: function(e) {
                            if (n.type.String(e) && e.match(/^(\.|\d)*\d+%$/)) {
                                var t = parseFloat(e) / 100;
                                e = function() {
                                    return a ? a.info("size") * t : 0
                                }
                            }
                            if (n.type.Function(e)) {
                                o = e;
                                try {
                                    e = parseFloat(o())
                                } catch (i) {
                                    e = -1
                                }
                            }
                            if (e = parseFloat(e), !n.type.Number(e) || 0 > e) throw o ? (o = void 0, ['Invalid return value of supplied function for option "duration":', e]) : ['Invalid value for option "duration":', e];
                            return e
                        }
                    }),
                    A = function(e) {
                        e = arguments.length ? [e] : Object.keys(E), e.forEach(function(e, t) {
                            var i;
                            if (E[e]) try {
                                i = E[e](f[e])
                            } catch (r) {
                                i = u[e];
                                var o = n.type.String(r) ? [r] : r;
                                n.type.Array(o) ? (o[0] = "ERROR: " + o[0], o.unshift(1), b.apply(this, o)) : b(1, "ERROR: Problem executing validation callback for option '" + e + "':", r.message)
                            } finally {
                                f[e] = i
                            }
                        })
                    },
                    C = function(e, t) {
                        var i = !1,
                            r = f[e];
                        return f[e] != t && (f[e] = t, A(e), i = r != f[e]), i
                    },
                    L = function(e) {
                        p[e] || (p[e] = function(t) {
                            return arguments.length ? ("duration" === e && (o = void 0), C(e, t) && (p.trigger("change", {
                                what: e,
                                newval: f[e]
                            }), r.shifts.indexOf(e) > -1 && p.trigger("shift", {
                                reason: e
                            })), p) : f[e]
                        })
                    };
                this.controller = function() {
                    return a
                }, this.state = function() {
                    return d
                }, this.scrollOffset = function() {
                    return g.start
                }, this.triggerPosition = function() {
                    var e = f.offset;
                    return a && (e += f.triggerElement ? v : a.info("size") * p.triggerHook()), e
                };
                var P, R;
                p.on("shift.internal", function(e) {
                    var t = "duration" === e.reason;
                    (d === h && t || d === c && 0 === f.duration) && D(), t && O()
                }).on("progress.internal", function(e) {
                    D()
                }).on("add.internal", function(e) {
                    O()
                }).on("destroy.internal", function(e) {
                    p.removePin(e.reset)
                });
                var D = function(e) {
                        if (P && a) {
                            var t = a.info(),
                                i = R.spacer.firstChild;
                            if (e || d !== c) {
                                var r = {
                                        position: R.inFlow ? "relative" : "absolute",
                                        top: 0,
                                        left: 0
                                    },
                                    o = n.css(i, "position") != r.position;
                                R.pushFollowers ? f.duration > 0 && (d === h && 0 === parseFloat(n.css(R.spacer, "padding-top")) ? o = !0 : d === l && 0 === parseFloat(n.css(R.spacer, "padding-bottom")) && (o = !0)) : r[t.vertical ? "top" : "left"] = f.duration * m, n.css(i, r), o && O()
                            } else {
                                "fixed" != n.css(i, "position") && (n.css(i, {
                                    position: "fixed"
                                }), O());
                                var s = n.get.offset(R.spacer, !0),
                                    u = f.reverse || 0 === f.duration ? t.scrollPos - g.start : Math.round(m * f.duration * 10) / 10;
                                s[t.vertical ? "top" : "left"] += u, n.css(R.spacer.firstChild, {
                                    top: s.top,
                                    left: s.left
                                })
                            }
                        }
                    },
                    O = function() {
                        if (P && a && R.inFlow) {
                            var e = d === c,
                                t = a.info("vertical"),
                                i = R.spacer.firstChild,
                                r = n.isMarginCollapseType(n.css(R.spacer, "display")),
                                o = {};
                            R.relSize.width || R.relSize.autoFullWidth ? e ? n.css(P, {
                                width: n.get.width(R.spacer)
                            }) : n.css(P, {
                                width: "100%"
                            }) : (o["min-width"] = n.get.width(t ? P : i, !0, !0), o.width = e ? o["min-width"] : "auto"), R.relSize.height ? e ? n.css(P, {
                                height: n.get.height(R.spacer) - (R.pushFollowers ? f.duration : 0)
                            }) : n.css(P, {
                                height: "100%"
                            }) : (o["min-height"] = n.get.height(t ? i : P, !0, !r), o.height = e ? o["min-height"] : "auto"), R.pushFollowers && (o["padding" + (t ? "Top" : "Left")] = f.duration * m, o["padding" + (t ? "Bottom" : "Right")] = f.duration * (1 - m)), n.css(R.spacer, o)
                        }
                    },
                    I = function() {
                        a && P && d === c && !a.info("isDocument") && D()
                    },
                    F = function() {
                        a && P && d === c && ((R.relSize.width || R.relSize.autoFullWidth) && n.get.width(window) != n.get.width(R.spacer.parentNode) || R.relSize.height && n.get.height(window) != n.get.height(R.spacer.parentNode)) && O()
                    },
                    N = function(e) {
                        a && P && d === c && !a.info("isDocument") && (e.preventDefault(), a._setScrollPos(a.info("scrollPos") - ((e.wheelDelta || e[a.info("vertical") ? "wheelDeltaY" : "wheelDeltaX"]) / 3 || 30 * -e.detail)))
                    };
                this.setPin = function(e, i) {
                    var r = {
                        pushFollowers: !0,
                        spacerClass: "scrollmagic-pin-spacer"
                    };
                    if (i = n.extend({}, r, i), e = n.get.elements(e)[0], !e) return b(1, "ERROR calling method 'setPin()': Invalid pin element supplied."), p;
                    if ("fixed" === n.css(e, "position")) return b(1, "ERROR calling method 'setPin()': Pin does not work with elements that are positioned 'fixed'."), p;
                    if (P) {
                        if (P === e) return p;
                        p.removePin()
                    }
                    P = e;
                    var o = P.parentNode.style.display,
                        a = ["top", "left", "bottom", "right", "margin", "marginLeft", "marginRight", "marginTop", "marginBottom"];
                    P.parentNode.style.display = "none";
                    var s = "absolute" != n.css(P, "position"),
                        l = n.css(P, a.concat(["display"])),
                        c = n.css(P, ["width", "height"]);
                    P.parentNode.style.display = o, !s && i.pushFollowers && (b(2, "WARNING: If the pinned element is positioned absolutely pushFollowers will be disabled."), i.pushFollowers = !1), window.setTimeout(function() {
                        P && 0 === f.duration && i.pushFollowers && b(2, "WARNING: pushFollowers =", !0, "has no effect, when scene duration is 0.")
                    }, 0);
                    var h = P.parentNode.insertBefore(document.createElement("div"), P),
                        u = n.extend(l, {
                            position: s ? "relative" : "absolute",
                            boxSizing: "content-box",
                            mozBoxSizing: "content-box",
                            webkitBoxSizing: "content-box"
                        });
                    if (s || n.extend(u, n.css(P, ["width", "height"])), n.css(h, u), h.setAttribute(t, ""), n.addClass(h, i.spacerClass), R = {
                            spacer: h,
                            relSize: {
                                width: "%" === c.width.slice(-1),
                                height: "%" === c.height.slice(-1),
                                autoFullWidth: "auto" === c.width && s && n.isMarginCollapseType(l.display)
                            },
                            pushFollowers: i.pushFollowers,
                            inFlow: s
                        }, !P.___origStyle) {
                        P.___origStyle = {};
                        var d = P.style,
                            m = a.concat(["width", "height", "position", "boxSizing", "mozBoxSizing", "webkitBoxSizing"]);
                        m.forEach(function(e) {
                            P.___origStyle[e] = d[e] || ""
                        })
                    }
                    return R.relSize.width && n.css(h, {
                        width: c.width
                    }), R.relSize.height && n.css(h, {
                        height: c.height
                    }), h.appendChild(P), n.css(P, {
                        position: s ? "relative" : "absolute",
                        margin: "auto",
                        top: "auto",
                        left: "auto",
                        bottom: "auto",
                        right: "auto"
                    }), (R.relSize.width || R.relSize.autoFullWidth) && n.css(P, {
                        boxSizing: "border-box",
                        mozBoxSizing: "border-box",
                        webkitBoxSizing: "border-box"
                    }), window.addEventListener("scroll", I), window.addEventListener("resize", I), window.addEventListener("resize", F), P.addEventListener("mousewheel", N), P.addEventListener("DOMMouseScroll", N), b(3, "added pin"), D(), p
                }, this.removePin = function(e) {
                    if (P) {
                        if (d === c && D(!0), e || !a) {
                            var i = R.spacer.firstChild;
                            if (i.hasAttribute(t)) {
                                var r = R.spacer.style,
                                    o = ["margin", "marginLeft", "marginRight", "marginTop", "marginBottom"];
                                margins = {}, o.forEach(function(e) {
                                    margins[e] = r[e] || ""
                                }), n.css(i, margins)
                            }
                            R.spacer.parentNode.insertBefore(i, R.spacer), R.spacer.parentNode.removeChild(R.spacer), P.parentNode.hasAttribute(t) || (n.css(P, P.___origStyle), delete P.___origStyle)
                        }
                        window.removeEventListener("scroll", I), window.removeEventListener("resize", I), window.removeEventListener("resize", F), P.removeEventListener("mousewheel", N), P.removeEventListener("DOMMouseScroll", N), P = void 0, b(3, "removed pin (reset: " + (e ? "true" : "false") + ")")
                    }
                    return p
                };
                var B, k = [];
                return p.on("destroy.internal", function(e) {
                    p.removeClassToggle(e.reset)
                }), this.setClassToggle = function(e, t) {
                    var i = n.get.elements(e);
                    return 0 !== i.length && n.type.String(t) ? (k.length > 0 && p.removeClassToggle(), B = t, k = i, p.on("enter.internal_class leave.internal_class", function(e) {
                        var t = "enter" === e.type ? n.addClass : n.removeClass;
                        k.forEach(function(e, i) {
                            t(e, B)
                        })
                    }), p) : (b(1, "ERROR calling method 'setClassToggle()': Invalid " + (0 === i.length ? "element" : "classes") + " supplied."), p)
                }, this.removeClassToggle = function(e) {
                    return e && k.forEach(function(e, t) {
                        n.removeClass(e, B)
                    }), p.off("start.internal_class end.internal_class"), B = void 0, k = [], p
                }, _(), p
            };
            var r = {
                defaults: {
                    duration: 0,
                    offset: 0,
                    triggerElement: void 0,
                    triggerHook: .5,
                    reverse: !0,
                    loglevel: 2
                },
                validate: {
                    offset: function(e) {
                        if (e = parseFloat(e), !n.type.Number(e)) throw ['Invalid value for option "offset":', e];
                        return e
                    },
                    triggerElement: function(e) {
                        if (e = e || void 0) {
                            var t = n.get.elements(e)[0];
                            if (!t) throw ['Element defined in option "triggerElement" was not found:', e];
                            e = t
                        }
                        return e
                    },
                    triggerHook: function(e) {
                        var t = {
                            onCenter: .5,
                            onEnter: 1,
                            onLeave: 0
                        };
                        if (n.type.Number(e)) e = Math.max(0, Math.min(parseFloat(e), 1));
                        else {
                            if (!(e in t)) throw ['Invalid value for option "triggerHook": ', e];
                            e = t[e]
                        }
                        return e
                    },
                    reverse: function(e) {
                        return !!e
                    },
                    loglevel: function(e) {
                        if (e = parseInt(e), !n.type.Number(e) || 0 > e || e > 3) throw ['Invalid value for option "loglevel":', e];
                        return e
                    }
                },
                shifts: ["duration", "offset", "triggerHook"]
            };
            e.Scene.addOption = function(t, i, n, o) {
                t in r.defaults ? e._util.log(1, "[static] ScrollMagic.Scene -> Cannot add Scene option '" + t + "', because it already exists.") : (r.defaults[t] = i, r.validate[t] = n, o && r.shifts.push(t))
            }, e.Scene.extend = function(t) {
                var i = this;
                e.Scene = function() {
                    return i.apply(this, arguments), this.$super = n.extend({}, this), t.apply(this, arguments) || this
                }, n.extend(e.Scene, i), e.Scene.prototype = i.prototype, e.Scene.prototype.constructor = e.Scene
            }, e.Event = function(e, t, i, r) {
                r = r || {};
                for (var n in r) this[n] = r[n];
                return this.type = e, this.target = this.currentTarget = i, this.namespace = t || "", this.timeStamp = this.timestamp = Date.now(), this
            };
            var n = e._util = function(e) {
                var t, i = {},
                    r = function(e) {
                        return parseFloat(e) || 0
                    },
                    n = function(t) {
                        return t.currentStyle ? t.currentStyle : e.getComputedStyle(t)
                    },
                    o = function(t, i, o, a) {
                        if (i = i === document ? e : i, i === e) a = !1;
                        else if (!d.DomElement(i)) return 0;
                        t = t.charAt(0).toUpperCase() + t.substr(1).toLowerCase();
                        var s = (o ? i["offset" + t] || i["outer" + t] : i["client" + t] || i["inner" + t]) || 0;
                        if (o && a) {
                            var l = n(i);
                            s += "Height" === t ? r(l.marginTop) + r(l.marginBottom) : r(l.marginLeft) + r(l.marginRight)
                        }
                        return s
                    },
                    a = function(e) {
                        return e.replace(/^[^a-z]+([a-z])/g, "$1").replace(/-([a-z])/g, function(e) {
                            return e[1].toUpperCase()
                        })
                    };
                i.extend = function(e) {
                    for (e = e || {}, t = 1; t < arguments.length; t++)
                        if (arguments[t])
                            for (var i in arguments[t]) arguments[t].hasOwnProperty(i) && (e[i] = arguments[t][i]);
                    return e
                }, i.isMarginCollapseType = function(e) {
                    return ["block", "flex", "list-item", "table", "-webkit-box"].indexOf(e) > -1
                };
                var s = 0,
                    l = ["ms", "moz", "webkit", "o"],
                    c = e.requestAnimationFrame,
                    h = e.cancelAnimationFrame;
                for (t = 0; !c && t < l.length; ++t) c = e[l[t] + "RequestAnimationFrame"], h = e[l[t] + "CancelAnimationFrame"] || e[l[t] + "CancelRequestAnimationFrame"];
                c || (c = function(t) {
                    var i = (new Date).getTime(),
                        r = Math.max(0, 16 - (i - s)),
                        n = e.setTimeout(function() {
                            t(i + r)
                        }, r);
                    return s = i + r, n
                }), h || (h = function(t) {
                    e.clearTimeout(t)
                }), i.rAF = c.bind(e), i.cAF = h.bind(e);
                var u = ["error", "warn", "log"],
                    p = e.console || {};
                for (p.log = p.log || function() {}, t = 0; t < u.length; t++) {
                    var f = u[t];
                    p[f] || (p[f] = p.log)
                }
                i.log = function(e) {
                    (e > u.length || 0 >= e) && (e = u.length);
                    var t = new Date,
                        i = ("0" + t.getHours()).slice(-2) + ":" + ("0" + t.getMinutes()).slice(-2) + ":" + ("0" + t.getSeconds()).slice(-2) + ":" + ("00" + t.getMilliseconds()).slice(-3),
                        r = u[e - 1],
                        n = Array.prototype.splice.call(arguments, 1),
                        o = Function.prototype.bind.call(p[r], p);
                    n.unshift(i), o.apply(p, n)
                };
                var d = i.type = function(e) {
                    return Object.prototype.toString.call(e).replace(/^\[object (.+)\]$/, "$1").toLowerCase()
                };
                d.String = function(e) {
                    return "string" === d(e)
                }, d.Function = function(e) {
                    return "function" === d(e)
                }, d.Array = function(e) {
                    return Array.isArray(e)
                }, d.Number = function(e) {
                    return !d.Array(e) && e - parseFloat(e) + 1 >= 0
                }, d.DomElement = function(e) {
                    return "object" == typeof HTMLElement ? e instanceof HTMLElement : e && "object" == typeof e && null !== e && 1 === e.nodeType && "string" == typeof e.nodeName
                };
                var m = i.get = {};
                return m.elements = function(t) {
                    var i = [];
                    if (d.String(t)) try {
                        t = document.querySelectorAll(t)
                    } catch (r) {
                        return i
                    }
                    if ("nodelist" === d(t) || d.Array(t))
                        for (var n = 0, o = i.length = t.length; o > n; n++) {
                            var a = t[n];
                            i[n] = d.DomElement(a) ? a : m.elements(a)
                        } else(d.DomElement(t) || t === document || t === e) && (i = [t]);
                    return i
                }, m.scrollTop = function(t) {
                    return t && "number" == typeof t.scrollTop ? t.scrollTop : e.pageYOffset || 0
                }, m.scrollLeft = function(t) {
                    return t && "number" == typeof t.scrollLeft ? t.scrollLeft : e.pageXOffset || 0
                }, m.width = function(e, t, i) {
                    return o("width", e, t, i)
                }, m.height = function(e, t, i) {
                    return o("height", e, t, i)
                }, m.offset = function(e, t) {
                    var i = {
                        top: 0,
                        left: 0
                    };
                    if (e && e.getBoundingClientRect) {
                        var r = e.getBoundingClientRect();
                        i.top = r.top, i.left = r.left, t || (i.top += m.scrollTop(), i.left += m.scrollLeft())
                    }
                    return i
                }, i.addClass = function(e, t) {
                    t && (e.classList ? e.classList.add(t) : e.className += " " + t)
                }, i.removeClass = function(e, t) {
                    t && (e.classList ? e.classList.remove(t) : e.className = e.className.replace(new RegExp("(^|\\b)" + t.split(" ").join("|") + "(\\b|$)", "gi"), " "))
                }, i.css = function(e, t) {
                    if (d.String(t)) return n(e)[a(t)];
                    if (d.Array(t)) {
                        var i = {},
                            r = n(e);
                        return t.forEach(function(e, t) {
                            i[e] = r[a(e)]
                        }), i
                    }
                    for (var o in t) {
                        var s = t[o];
                        s == parseFloat(s) && (s += "px"), e.style[a(o)] = s
                    }
                }, i
            }(window || {});
            return e.Scene.prototype.addIndicators = function() {
                return e._util.log(1, "(ScrollMagic.Scene) -> ERROR calling addIndicators() due to missing Plugin 'debug.addIndicators'. Please make sure to include plugins/debug.addIndicators.js"), this
            }, e.Scene.prototype.removeIndicators = function() {
                return e._util.log(1, "(ScrollMagic.Scene) -> ERROR calling removeIndicators() due to missing Plugin 'debug.addIndicators'. Please make sure to include plugins/debug.addIndicators.js"), this
            }, e.Scene.prototype.setTween = function() {
                return e._util.log(1, "(ScrollMagic.Scene) -> ERROR calling setTween() due to missing Plugin 'animation.gsap'. Please make sure to include plugins/animation.gsap.js"), this
            }, e.Scene.prototype.removeTween = function() {
                return e._util.log(1, "(ScrollMagic.Scene) -> ERROR calling removeTween() due to missing Plugin 'animation.gsap'. Please make sure to include plugins/animation.gsap.js"), this
            }, e.Scene.prototype.setVelocity = function() {
                return e._util.log(1, "(ScrollMagic.Scene) -> ERROR calling setVelocity() due to missing Plugin 'animation.velocity'. Please make sure to include plugins/animation.velocity.js"), this
            }, e.Scene.prototype.removeVelocity = function() {
                return e._util.log(1, "(ScrollMagic.Scene) -> ERROR calling removeVelocity() due to missing Plugin 'animation.velocity'. Please make sure to include plugins/animation.velocity.js"), this
            }, e
        })
    }, {}],
    6: [function(e, t, i) {
        ! function(t, r) {
            "function" == typeof define && define.amd ? define(["ScrollMagic", "TweenMax", "TimelineMax"], r) : "object" == typeof i ? (e("gsap"), r(e("scrollmagic"), TweenMax, TimelineMax)) : r(t.ScrollMagic || t.jQuery && t.jQuery.ScrollMagic, t.TweenMax || t.TweenLite, t.TimelineMax || t.TimelineLite)
        }(this, function(e, t, i) {
            "use strict";
            var r = "animation.gsap",
                n = window.console || {},
                o = Function.prototype.bind.call(n.error || n.log || function() {}, n);
            e || o("(" + r + ") -> ERROR: The ScrollMagic main module could not be found. Please make sure it's loaded before this plugin or use an asynchronous loader like requirejs."), t || o("(" + r + ") -> ERROR: TweenLite or TweenMax could not be found. Please make sure GSAP is loaded before ScrollMagic or use an asynchronous loader like requirejs."), e.Scene.addOption("tweenChanges", !1, function(e) {
                return !!e
            }), e.Scene.extend(function() {
                var e, n = this,
                    o = function() {
                        n._log && (Array.prototype.splice.call(arguments, 1, 0, "(" + r + ")", "->"), n._log.apply(this, arguments))
                    };
                n.on("progress.plugin_gsap", function() {
                    a()
                }), n.on("destroy.plugin_gsap", function(e) {
                    n.removeTween(e.reset)
                });
                var a = function() {
                    if (e) {
                        var t = n.progress(),
                            i = n.state();
                        e.repeat && -1 === e.repeat() ? "DURING" === i && e.paused() ? e.play() : "DURING" === i || e.paused() || e.pause() : t != e.progress() && (0 === n.duration() ? t > 0 ? e.play() : e.reverse() : n.tweenChanges() && e.tweenTo ? e.tweenTo(t * e.duration()) : e.progress(t).pause())
                    }
                };
                n.setTween = function(r, s, l) {
                    var c;
                    arguments.length > 1 && (arguments.length < 3 && (l = s, s = 1), r = t.to(r, s, l));
                    try {
                        c = i ? new i({
                            smoothChildTiming: !0
                        }).add(r) : r, c.pause()
                    } catch (h) {
                        return o(1, "ERROR calling method 'setTween()': Supplied argument is not a valid TweenObject"), n
                    }
                    if (e && n.removeTween(), e = c, r.repeat && -1 === r.repeat() && (e.repeat(-1), e.yoyo(r.yoyo())), n.tweenChanges() && !e.tweenTo && o(2, "WARNING: tweenChanges will only work if the TimelineMax object is available for ScrollMagic."), e && n.controller() && n.triggerElement() && n.loglevel() >= 2) {
                        var u = t.getTweensOf(n.triggerElement()),
                            p = n.controller().info("vertical");
                        u.forEach(function(e, t) {
                            var i = e.vars.css || e.vars,
                                r = p ? void 0 !== i.top || void 0 !== i.bottom : void 0 !== i.left || void 0 !== i.right;
                            return r ? (o(2, "WARNING: Tweening the position of the trigger element affects the scene timing and should be avoided!"), !1) : void 0
                        })
                    }
                    if (parseFloat(TweenLite.version) >= 1.14)
                        for (var f, d, m = e.getChildren ? e.getChildren(!0, !0, !1) : [e], g = function() {
                                o(2, "WARNING: tween was overwritten by another. To learn how to avoid this issue see here: https://github.com/janpaepke/ScrollMagic/wiki/WARNING:-tween-was-overwritten-by-another")
                            }, v = 0; v < m.length; v++) f = m[v], d !== g && (d = f.vars.onOverwrite, f.vars.onOverwrite = function() {
                            d && d.apply(this, arguments), g.apply(this, arguments)
                        });
                    return o(3, "added tween"), a(), n
                }, n.removeTween = function(t) {
                    return e && (t && e.progress(0).pause(), e.kill(), e = void 0, o(3, "removed tween (reset: " + (t ? "true" : "false") + ")")), n
                }
            })
        })
    }, {
        gsap: 1,
        scrollmagic: 5
    }],
    7: [function(e, t, i) {
        var r = {
            REVISION: "75"
        };
        "function" == typeof define && define.amd ? define("three", r) : "undefined" != typeof i && "undefined" != typeof t && (t.exports = r), void 0 === Number.EPSILON && (Number.EPSILON = Math.pow(2, -52)), void 0 === Math.sign && (Math.sign = function(e) {
                return 0 > e ? -1 : e > 0 ? 1 : +e
            }), void 0 === Function.prototype.name && void 0 !== Object.defineProperty && Object.defineProperty(Function.prototype, "name", {
                get: function() {
                    return this.toString().match(/^\s*function\s*(\S*)\s*\(/)[1]
                }
            }), void 0 === Object.assign && Object.defineProperty(Object, "assign", {
                writable: !0,
                configurable: !0,
                value: function(e) {
                    "use strict";
                    if (void 0 === e || null === e) throw new TypeError("Cannot convert first argument to object");
                    for (var t = Object(e), i = 1, r = arguments.length; i !== r; ++i) {
                        var n = arguments[i];
                        if (void 0 !== n && null !== n) {
                            n = Object(n);
                            for (var o = Object.keys(n), a = 0, s = o.length; a !== s; ++a) {
                                var l = o[a],
                                    c = Object.getOwnPropertyDescriptor(n, l);
                                void 0 !== c && c.enumerable && (t[l] = n[l])
                            }
                        }
                    }
                    return t
                }
            }), r.MOUSE = {
                LEFT: 0,
                MIDDLE: 1,
                RIGHT: 2
            }, r.CullFaceNone = 0, r.CullFaceBack = 1, r.CullFaceFront = 2, r.CullFaceFrontBack = 3, r.FrontFaceDirectionCW = 0, r.FrontFaceDirectionCCW = 1, r.BasicShadowMap = 0, r.PCFShadowMap = 1, r.PCFSoftShadowMap = 2, r.FrontSide = 0, r.BackSide = 1, r.DoubleSide = 2, r.FlatShading = 1, r.SmoothShading = 2, r.NoColors = 0, r.FaceColors = 1, r.VertexColors = 2, r.NoBlending = 0, r.NormalBlending = 1, r.AdditiveBlending = 2, r.SubtractiveBlending = 3, r.MultiplyBlending = 4, r.CustomBlending = 5, r.AddEquation = 100, r.SubtractEquation = 101, r.ReverseSubtractEquation = 102, r.MinEquation = 103, r.MaxEquation = 104, r.ZeroFactor = 200, r.OneFactor = 201, r.SrcColorFactor = 202, r.OneMinusSrcColorFactor = 203, r.SrcAlphaFactor = 204, r.OneMinusSrcAlphaFactor = 205, r.DstAlphaFactor = 206, r.OneMinusDstAlphaFactor = 207, r.DstColorFactor = 208, r.OneMinusDstColorFactor = 209, r.SrcAlphaSaturateFactor = 210, r.NeverDepth = 0, r.AlwaysDepth = 1, r.LessDepth = 2, r.LessEqualDepth = 3, r.EqualDepth = 4, r.GreaterEqualDepth = 5, r.GreaterDepth = 6, r.NotEqualDepth = 7, r.MultiplyOperation = 0, r.MixOperation = 1, r.AddOperation = 2, r.NoToneMapping = 0, r.LinearToneMapping = 1, r.ReinhardToneMapping = 2, r.Uncharted2ToneMapping = 3, r.CineonToneMapping = 4, r.UVMapping = 300, r.CubeReflectionMapping = 301, r.CubeRefractionMapping = 302, r.EquirectangularReflectionMapping = 303, r.EquirectangularRefractionMapping = 304, r.SphericalReflectionMapping = 305, r.CubeUVReflectionMapping = 306, r.CubeUVRefractionMapping = 307, r.RepeatWrapping = 1e3, r.ClampToEdgeWrapping = 1001, r.MirroredRepeatWrapping = 1002, r.NearestFilter = 1003, r.NearestMipMapNearestFilter = 1004, r.NearestMipMapLinearFilter = 1005, r.LinearFilter = 1006, r.LinearMipMapNearestFilter = 1007, r.LinearMipMapLinearFilter = 1008, r.UnsignedByteType = 1009, r.ByteType = 1010, r.ShortType = 1011, r.UnsignedShortType = 1012, r.IntType = 1013, r.UnsignedIntType = 1014, r.FloatType = 1015, r.HalfFloatType = 1025, r.UnsignedShort4444Type = 1016, r.UnsignedShort5551Type = 1017, r.UnsignedShort565Type = 1018, r.AlphaFormat = 1019, r.RGBFormat = 1020, r.RGBAFormat = 1021, r.LuminanceFormat = 1022, r.LuminanceAlphaFormat = 1023, r.RGBEFormat = r.RGBAFormat, r.RGB_S3TC_DXT1_Format = 2001, r.RGBA_S3TC_DXT1_Format = 2002, r.RGBA_S3TC_DXT3_Format = 2003, r.RGBA_S3TC_DXT5_Format = 2004, r.RGB_PVRTC_4BPPV1_Format = 2100, r.RGB_PVRTC_2BPPV1_Format = 2101, r.RGBA_PVRTC_4BPPV1_Format = 2102, r.RGBA_PVRTC_2BPPV1_Format = 2103, r.RGB_ETC1_Format = 2151, r.LoopOnce = 2200, r.LoopRepeat = 2201, r.LoopPingPong = 2202, r.InterpolateDiscrete = 2300, r.InterpolateLinear = 2301, r.InterpolateSmooth = 2302, r.ZeroCurvatureEnding = 2400, r.ZeroSlopeEnding = 2401, r.WrapAroundEnding = 2402, r.TrianglesDrawMode = 0, r.TriangleStripDrawMode = 1, r.TriangleFanDrawMode = 2, r.LinearEncoding = 3e3, r.sRGBEncoding = 3001, r.GammaEncoding = 3007, r.RGBEEncoding = 3002, r.LogLuvEncoding = 3003, r.RGBM7Encoding = 3004, r.RGBM16Encoding = 3005, r.RGBDEncoding = 3006, r.Color = function(e) {
                return 3 === arguments.length ? this.fromArray(arguments) : this.set(e)
            }, r.Color.prototype = {
                constructor: r.Color,
                r: 1,
                g: 1,
                b: 1,
                set: function(e) {
                    return e instanceof r.Color ? this.copy(e) : "number" == typeof e ? this.setHex(e) : "string" == typeof e && this.setStyle(e), this
                },
                setScalar: function(e) {
                    this.r = e, this.g = e, this.b = e
                },
                setHex: function(e) {
                    return e = Math.floor(e), this.r = (e >> 16 & 255) / 255, this.g = (e >> 8 & 255) / 255, this.b = (255 & e) / 255, this
                },
                setRGB: function(e, t, i) {
                    return this.r = e, this.g = t, this.b = i, this
                },
                setHSL: function() {
                    function e(e, t, i) {
                        return 0 > i && (i += 1), i > 1 && (i -= 1), 1 / 6 > i ? e + 6 * (t - e) * i : .5 > i ? t : 2 / 3 > i ? e + 6 * (t - e) * (2 / 3 - i) : e
                    }
                    return function(t, i, n) {
                        if (t = r.Math.euclideanModulo(t, 1), i = r.Math.clamp(i, 0, 1), n = r.Math.clamp(n, 0, 1), 0 === i) this.r = this.g = this.b = n;
                        else {
                            var o = .5 >= n ? n * (1 + i) : n + i - n * i,
                                a = 2 * n - o;
                            this.r = e(a, o, t + 1 / 3), this.g = e(a, o, t), this.b = e(a, o, t - 1 / 3)
                        }
                        return this
                    }
                }(),
                setStyle: function(e) {
                    function t(t) {
                        void 0 !== t && parseFloat(t) < 1 && console.warn("THREE.Color: Alpha component of " + e + " will be ignored.")
                    }
                    var i;
                    if (i = /^((?:rgb|hsl)a?)\(\s*([^\)]*)\)/.exec(e)) {
                        var n, o = i[1],
                            a = i[2];
                        switch (o) {
                            case "rgb":
                            case "rgba":
                                if (n = /^(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*(,\s*([0-9]*\.?[0-9]+)\s*)?$/.exec(a)) return this.r = Math.min(255, parseInt(n[1], 10)) / 255, this.g = Math.min(255, parseInt(n[2], 10)) / 255, this.b = Math.min(255, parseInt(n[3], 10)) / 255, t(n[5]), this;
                                if (n = /^(\d+)\%\s*,\s*(\d+)\%\s*,\s*(\d+)\%\s*(,\s*([0-9]*\.?[0-9]+)\s*)?$/.exec(a)) return this.r = Math.min(100, parseInt(n[1], 10)) / 100, this.g = Math.min(100, parseInt(n[2], 10)) / 100, this.b = Math.min(100, parseInt(n[3], 10)) / 100, t(n[5]), this;
                                break;
                            case "hsl":
                            case "hsla":
                                if (n = /^([0-9]*\.?[0-9]+)\s*,\s*(\d+)\%\s*,\s*(\d+)\%\s*(,\s*([0-9]*\.?[0-9]+)\s*)?$/.exec(a)) {
                                    var s = parseFloat(n[1]) / 360,
                                        l = parseInt(n[2], 10) / 100,
                                        c = parseInt(n[3], 10) / 100;
                                    return t(n[5]), this.setHSL(s, l, c)
                                }
                        }
                    } else if (i = /^\#([A-Fa-f0-9]+)$/.exec(e)) {
                        var h = i[1],
                            u = h.length;
                        if (3 === u) return this.r = parseInt(h.charAt(0) + h.charAt(0), 16) / 255, this.g = parseInt(h.charAt(1) + h.charAt(1), 16) / 255, this.b = parseInt(h.charAt(2) + h.charAt(2), 16) / 255, this;
                        if (6 === u) return this.r = parseInt(h.charAt(0) + h.charAt(1), 16) / 255, this.g = parseInt(h.charAt(2) + h.charAt(3), 16) / 255, this.b = parseInt(h.charAt(4) + h.charAt(5), 16) / 255, this
                    }
                    if (e && e.length > 0) {
                        var h = r.ColorKeywords[e];
                        void 0 !== h ? this.setHex(h) : console.warn("THREE.Color: Unknown color " + e)
                    }
                    return this
                },
                clone: function() {
                    return new this.constructor(this.r, this.g, this.b)
                },
                copy: function(e) {
                    return this.r = e.r, this.g = e.g, this.b = e.b, this
                },
                copyGammaToLinear: function(e, t) {
                    return void 0 === t && (t = 2), this.r = Math.pow(e.r, t), this.g = Math.pow(e.g, t), this.b = Math.pow(e.b, t), this
                },
                copyLinearToGamma: function(e, t) {
                    void 0 === t && (t = 2);
                    var i = t > 0 ? 1 / t : 1;
                    return this.r = Math.pow(e.r, i), this.g = Math.pow(e.g, i), this.b = Math.pow(e.b, i), this
                },
                convertGammaToLinear: function() {
                    var e = this.r,
                        t = this.g,
                        i = this.b;
                    return this.r = e * e, this.g = t * t, this.b = i * i, this
                },
                convertLinearToGamma: function() {
                    return this.r = Math.sqrt(this.r), this.g = Math.sqrt(this.g), this.b = Math.sqrt(this.b), this
                },
                getHex: function() {
                    return 255 * this.r << 16 ^ 255 * this.g << 8 ^ 255 * this.b << 0
                },
                getHexString: function() {
                    return ("000000" + this.getHex().toString(16)).slice(-6)
                },
                getHSL: function(e) {
                    var t, i, r = e || {
                            h: 0,
                            s: 0,
                            l: 0
                        },
                        n = this.r,
                        o = this.g,
                        a = this.b,
                        s = Math.max(n, o, a),
                        l = Math.min(n, o, a),
                        c = (l + s) / 2;
                    if (l === s) t = 0, i = 0;
                    else {
                        var h = s - l;
                        switch (i = .5 >= c ? h / (s + l) : h / (2 - s - l), s) {
                            case n:
                                t = (o - a) / h + (a > o ? 6 : 0);
                                break;
                            case o:
                                t = (a - n) / h + 2;
                                break;
                            case a:
                                t = (n - o) / h + 4
                        }
                        t /= 6
                    }
                    return r.h = t, r.s = i, r.l = c, r
                },
                getStyle: function() {
                    return "rgb(" + (255 * this.r | 0) + "," + (255 * this.g | 0) + "," + (255 * this.b | 0) + ")"
                },
                offsetHSL: function(e, t, i) {
                    var r = this.getHSL();
                    return r.h += e, r.s += t, r.l += i, this.setHSL(r.h, r.s, r.l), this
                },
                add: function(e) {
                    return this.r += e.r, this.g += e.g, this.b += e.b, this
                },
                addColors: function(e, t) {
                    return this.r = e.r + t.r, this.g = e.g + t.g, this.b = e.b + t.b, this
                },
                addScalar: function(e) {
                    return this.r += e, this.g += e, this.b += e, this
                },
                multiply: function(e) {
                    return this.r *= e.r, this.g *= e.g, this.b *= e.b, this
                },
                multiplyScalar: function(e) {
                    return this.r *= e, this.g *= e, this.b *= e, this
                },
                lerp: function(e, t) {
                    return this.r += (e.r - this.r) * t, this.g += (e.g - this.g) * t, this.b += (e.b - this.b) * t, this
                },
                equals: function(e) {
                    return e.r === this.r && e.g === this.g && e.b === this.b
                },
                fromArray: function(e, t) {
                    return void 0 === t && (t = 0), this.r = e[t], this.g = e[t + 1], this.b = e[t + 2], this
                },
                toArray: function(e, t) {
                    return void 0 === e && (e = []), void 0 === t && (t = 0), e[t] = this.r, e[t + 1] = this.g, e[t + 2] = this.b, e
                }
            }, r.ColorKeywords = {
                aliceblue: 15792383,
                antiquewhite: 16444375,
                aqua: 65535,
                aquamarine: 8388564,
                azure: 15794175,
                beige: 16119260,
                bisque: 16770244,
                black: 0,
                blanchedalmond: 16772045,
                blue: 255,
                blueviolet: 9055202,
                brown: 10824234,
                burlywood: 14596231,
                cadetblue: 6266528,
                chartreuse: 8388352,
                chocolate: 13789470,
                coral: 16744272,
                cornflowerblue: 6591981,
                cornsilk: 16775388,
                crimson: 14423100,
                cyan: 65535,
                darkblue: 139,
                darkcyan: 35723,
                darkgoldenrod: 12092939,
                darkgray: 11119017,
                darkgreen: 25600,
                darkgrey: 11119017,
                darkkhaki: 12433259,
                darkmagenta: 9109643,
                darkolivegreen: 5597999,
                darkorange: 16747520,
                darkorchid: 10040012,
                darkred: 9109504,
                darksalmon: 15308410,
                darkseagreen: 9419919,
                darkslateblue: 4734347,
                darkslategray: 3100495,
                darkslategrey: 3100495,
                darkturquoise: 52945,
                darkviolet: 9699539,
                deeppink: 16716947,
                deepskyblue: 49151,
                dimgray: 6908265,
                dimgrey: 6908265,
                dodgerblue: 2003199,
                firebrick: 11674146,
                floralwhite: 16775920,
                forestgreen: 2263842,
                fuchsia: 16711935,
                gainsboro: 14474460,
                ghostwhite: 16316671,
                gold: 16766720,
                goldenrod: 14329120,
                gray: 8421504,
                green: 32768,
                greenyellow: 11403055,
                grey: 8421504,
                honeydew: 15794160,
                hotpink: 16738740,
                indianred: 13458524,
                indigo: 4915330,
                ivory: 16777200,
                khaki: 15787660,
                lavender: 15132410,
                lavenderblush: 16773365,
                lawngreen: 8190976,
                lemonchiffon: 16775885,
                lightblue: 11393254,
                lightcoral: 15761536,
                lightcyan: 14745599,
                lightgoldenrodyellow: 16448210,
                lightgray: 13882323,
                lightgreen: 9498256,
                lightgrey: 13882323,
                lightpink: 16758465,
                lightsalmon: 16752762,
                lightseagreen: 2142890,
                lightskyblue: 8900346,
                lightslategray: 7833753,
                lightslategrey: 7833753,
                lightsteelblue: 11584734,
                lightyellow: 16777184,
                lime: 65280,
                limegreen: 3329330,
                linen: 16445670,
                magenta: 16711935,
                maroon: 8388608,
                mediumaquamarine: 6737322,
                mediumblue: 205,
                mediumorchid: 12211667,
                mediumpurple: 9662683,
                mediumseagreen: 3978097,
                mediumslateblue: 8087790,
                mediumspringgreen: 64154,
                mediumturquoise: 4772300,
                mediumvioletred: 13047173,
                midnightblue: 1644912,
                mintcream: 16121850,
                mistyrose: 16770273,
                moccasin: 16770229,
                navajowhite: 16768685,
                navy: 128,
                oldlace: 16643558,
                olive: 8421376,
                olivedrab: 7048739,
                orange: 16753920,
                orangered: 16729344,
                orchid: 14315734,
                palegoldenrod: 15657130,
                palegreen: 10025880,
                paleturquoise: 11529966,
                palevioletred: 14381203,
                papayawhip: 16773077,
                peachpuff: 16767673,
                peru: 13468991,
                pink: 16761035,
                plum: 14524637,
                powderblue: 11591910,
                purple: 8388736,
                red: 16711680,
                rosybrown: 12357519,
                royalblue: 4286945,
                saddlebrown: 9127187,
                salmon: 16416882,
                sandybrown: 16032864,
                seagreen: 3050327,
                seashell: 16774638,
                sienna: 10506797,
                silver: 12632256,
                skyblue: 8900331,
                slateblue: 6970061,
                slategray: 7372944,
                slategrey: 7372944,
                snow: 16775930,
                springgreen: 65407,
                steelblue: 4620980,
                tan: 13808780,
                teal: 32896,
                thistle: 14204888,
                tomato: 16737095,
                turquoise: 4251856,
                violet: 15631086,
                wheat: 16113331,
                white: 16777215,
                whitesmoke: 16119285,
                yellow: 16776960,
                yellowgreen: 10145074
            }, r.Quaternion = function(e, t, i, r) {
                this._x = e || 0, this._y = t || 0, this._z = i || 0, this._w = void 0 !== r ? r : 1
            }, r.Quaternion.prototype = {
                constructor: r.Quaternion,
                get x() {
                    return this._x
                },
                set x(e) {
                    this._x = e, this.onChangeCallback()
                },
                get y() {
                    return this._y
                },
                set y(e) {
                    this._y = e, this.onChangeCallback()
                },
                get z() {
                    return this._z
                },
                set z(e) {
                    this._z = e, this.onChangeCallback()
                },
                get w() {
                    return this._w
                },
                set w(e) {
                    this._w = e, this.onChangeCallback()
                },
                set: function(e, t, i, r) {
                    return this._x = e, this._y = t, this._z = i, this._w = r, this.onChangeCallback(), this
                },
                clone: function() {
                    return new this.constructor(this._x, this._y, this._z, this._w)
                },
                copy: function(e) {
                    return this._x = e.x, this._y = e.y, this._z = e.z, this._w = e.w, this.onChangeCallback(), this
                },
                setFromEuler: function(e, t) {
                    if (e instanceof r.Euler == !1) throw new Error("THREE.Quaternion: .setFromEuler() now expects a Euler rotation rather than a Vector3 and order.");
                    var i = Math.cos(e._x / 2),
                        n = Math.cos(e._y / 2),
                        o = Math.cos(e._z / 2),
                        a = Math.sin(e._x / 2),
                        s = Math.sin(e._y / 2),
                        l = Math.sin(e._z / 2),
                        c = e.order;
                    return "XYZ" === c ? (this._x = a * n * o + i * s * l, this._y = i * s * o - a * n * l, this._z = i * n * l + a * s * o, this._w = i * n * o - a * s * l) : "YXZ" === c ? (this._x = a * n * o + i * s * l, this._y = i * s * o - a * n * l, this._z = i * n * l - a * s * o, this._w = i * n * o + a * s * l) : "ZXY" === c ? (this._x = a * n * o - i * s * l, this._y = i * s * o + a * n * l, this._z = i * n * l + a * s * o, this._w = i * n * o - a * s * l) : "ZYX" === c ? (this._x = a * n * o - i * s * l, this._y = i * s * o + a * n * l, this._z = i * n * l - a * s * o, this._w = i * n * o + a * s * l) : "YZX" === c ? (this._x = a * n * o + i * s * l, this._y = i * s * o + a * n * l, this._z = i * n * l - a * s * o, this._w = i * n * o - a * s * l) : "XZY" === c && (this._x = a * n * o - i * s * l, this._y = i * s * o - a * n * l, this._z = i * n * l + a * s * o, this._w = i * n * o + a * s * l), t !== !1 && this.onChangeCallback(), this
                },
                setFromAxisAngle: function(e, t) {
                    var i = t / 2,
                        r = Math.sin(i);
                    return this._x = e.x * r, this._y = e.y * r, this._z = e.z * r, this._w = Math.cos(i), this.onChangeCallback(), this
                },
                setFromRotationMatrix: function(e) {
                    var t, i = e.elements,
                        r = i[0],
                        n = i[4],
                        o = i[8],
                        a = i[1],
                        s = i[5],
                        l = i[9],
                        c = i[2],
                        h = i[6],
                        u = i[10],
                        p = r + s + u;
                    return p > 0 ? (t = .5 / Math.sqrt(p + 1), this._w = .25 / t, this._x = (h - l) * t, this._y = (o - c) * t, this._z = (a - n) * t) : r > s && r > u ? (t = 2 * Math.sqrt(1 + r - s - u), this._w = (h - l) / t, this._x = .25 * t, this._y = (n + a) / t, this._z = (o + c) / t) : s > u ? (t = 2 * Math.sqrt(1 + s - r - u), this._w = (o - c) / t, this._x = (n + a) / t, this._y = .25 * t, this._z = (l + h) / t) : (t = 2 * Math.sqrt(1 + u - r - s), this._w = (a - n) / t, this._x = (o + c) / t, this._y = (l + h) / t, this._z = .25 * t), this.onChangeCallback(), this
                },
                setFromUnitVectors: function() {
                    var e, t, i = 1e-6;
                    return function(n, o) {
                        return void 0 === e && (e = new r.Vector3), t = n.dot(o) + 1, i > t ? (t = 0, Math.abs(n.x) > Math.abs(n.z) ? e.set(-n.y, n.x, 0) : e.set(0, -n.z, n.y)) : e.crossVectors(n, o), this._x = e.x, this._y = e.y, this._z = e.z, this._w = t, this.normalize(), this
                    }
                }(),
                inverse: function() {
                    return this.conjugate().normalize(), this
                },
                conjugate: function() {
                    return this._x *= -1, this._y *= -1, this._z *= -1, this.onChangeCallback(), this
                },
                dot: function(e) {
                    return this._x * e._x + this._y * e._y + this._z * e._z + this._w * e._w
                },
                lengthSq: function() {
                    return this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w
                },
                length: function() {
                    return Math.sqrt(this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w)
                },
                normalize: function() {
                    var e = this.length();
                    return 0 === e ? (this._x = 0, this._y = 0, this._z = 0, this._w = 1) : (e = 1 / e, this._x = this._x * e, this._y = this._y * e, this._z = this._z * e, this._w = this._w * e), this.onChangeCallback(), this
                },
                multiply: function(e, t) {
                    return void 0 !== t ? (console.warn("THREE.Quaternion: .multiply() now only accepts one argument. Use .multiplyQuaternions( a, b ) instead."), this.multiplyQuaternions(e, t)) : this.multiplyQuaternions(this, e)
                },
                multiplyQuaternions: function(e, t) {
                    var i = e._x,
                        r = e._y,
                        n = e._z,
                        o = e._w,
                        a = t._x,
                        s = t._y,
                        l = t._z,
                        c = t._w;
                    return this._x = i * c + o * a + r * l - n * s, this._y = r * c + o * s + n * a - i * l, this._z = n * c + o * l + i * s - r * a, this._w = o * c - i * a - r * s - n * l, this.onChangeCallback(), this
                },
                slerp: function(e, t) {
                    if (0 === t) return this;
                    if (1 === t) return this.copy(e);
                    var i = this._x,
                        r = this._y,
                        n = this._z,
                        o = this._w,
                        a = o * e._w + i * e._x + r * e._y + n * e._z;
                    if (0 > a ? (this._w = -e._w, this._x = -e._x, this._y = -e._y, this._z = -e._z, a = -a) : this.copy(e), a >= 1) return this._w = o, this._x = i, this._y = r, this._z = n, this;
                    var s = Math.sqrt(1 - a * a);
                    if (Math.abs(s) < .001) return this._w = .5 * (o + this._w), this._x = .5 * (i + this._x), this._y = .5 * (r + this._y), this._z = .5 * (n + this._z), this;
                    var l = Math.atan2(s, a),
                        c = Math.sin((1 - t) * l) / s,
                        h = Math.sin(t * l) / s;
                    return this._w = o * c + this._w * h, this._x = i * c + this._x * h, this._y = r * c + this._y * h, this._z = n * c + this._z * h, this.onChangeCallback(), this
                },
                equals: function(e) {
                    return e._x === this._x && e._y === this._y && e._z === this._z && e._w === this._w
                },
                fromArray: function(e, t) {
                    return void 0 === t && (t = 0), this._x = e[t], this._y = e[t + 1], this._z = e[t + 2], this._w = e[t + 3], this.onChangeCallback(), this
                },
                toArray: function(e, t) {
                    return void 0 === e && (e = []), void 0 === t && (t = 0), e[t] = this._x, e[t + 1] = this._y, e[t + 2] = this._z, e[t + 3] = this._w, e
                },
                onChange: function(e) {
                    return this.onChangeCallback = e, this
                },
                onChangeCallback: function() {}
            }, Object.assign(r.Quaternion, {
                slerp: function(e, t, i, r) {
                    return i.copy(e).slerp(t, r)
                },
                slerpFlat: function(e, t, i, r, n, o, a) {
                    var s = i[r + 0],
                        l = i[r + 1],
                        c = i[r + 2],
                        h = i[r + 3],
                        u = n[o + 0],
                        p = n[o + 1],
                        f = n[o + 2],
                        d = n[o + 3];
                    if (h !== d || s !== u || l !== p || c !== f) {
                        var m = 1 - a,
                            g = s * u + l * p + c * f + h * d,
                            v = g >= 0 ? 1 : -1,
                            y = 1 - g * g;
                        if (y > Number.EPSILON) {
                            var _ = Math.sqrt(y),
                                x = Math.atan2(_, g * v);
                            m = Math.sin(m * x) / _, a = Math.sin(a * x) / _
                        }
                        var b = a * v;
                        if (s = s * m + u * b, l = l * m + p * b, c = c * m + f * b, h = h * m + d * b, m === 1 - a) {
                            var w = 1 / Math.sqrt(s * s + l * l + c * c + h * h);
                            s *= w, l *= w, c *= w, h *= w
                        }
                    }
                    e[t] = s, e[t + 1] = l, e[t + 2] = c, e[t + 3] = h
                }
            }), r.Vector2 = function(e, t) {
                this.x = e || 0, this.y = t || 0
            }, r.Vector2.prototype = {
                constructor: r.Vector2,
                get width() {
                    return this.x
                },
                set width(e) {
                    this.x = e
                },
                get height() {
                    return this.y
                },
                set height(e) {
                    this.y = e
                },
                set: function(e, t) {
                    return this.x = e, this.y = t, this
                },
                setScalar: function(e) {
                    return this.x = e, this.y = e, this
                },
                setX: function(e) {
                    return this.x = e, this
                },
                setY: function(e) {
                    return this.y = e, this
                },
                setComponent: function(e, t) {
                    switch (e) {
                        case 0:
                            this.x = t;
                            break;
                        case 1:
                            this.y = t;
                            break;
                        default:
                            throw new Error("index is out of range: " + e)
                    }
                },
                getComponent: function(e) {
                    switch (e) {
                        case 0:
                            return this.x;
                        case 1:
                            return this.y;
                        default:
                            throw new Error("index is out of range: " + e)
                    }
                },
                clone: function() {
                    return new this.constructor(this.x, this.y)
                },
                copy: function(e) {
                    return this.x = e.x, this.y = e.y, this
                },
                add: function(e, t) {
                    return void 0 !== t ? (console.warn("THREE.Vector2: .add() now only accepts one argument. Use .addVectors( a, b ) instead."), this.addVectors(e, t)) : (this.x += e.x, this.y += e.y, this)
                },
                addScalar: function(e) {
                    return this.x += e, this.y += e, this
                },
                addVectors: function(e, t) {
                    return this.x = e.x + t.x, this.y = e.y + t.y, this
                },
                addScaledVector: function(e, t) {
                    return this.x += e.x * t, this.y += e.y * t, this
                },
                sub: function(e, t) {
                    return void 0 !== t ? (console.warn("THREE.Vector2: .sub() now only accepts one argument. Use .subVectors( a, b ) instead."), this.subVectors(e, t)) : (this.x -= e.x, this.y -= e.y, this)
                },
                subScalar: function(e) {
                    return this.x -= e, this.y -= e, this
                },
                subVectors: function(e, t) {
                    return this.x = e.x - t.x, this.y = e.y - t.y, this
                },
                multiply: function(e) {
                    return this.x *= e.x, this.y *= e.y, this
                },
                multiplyScalar: function(e) {
                    return isFinite(e) ? (this.x *= e, this.y *= e) : (this.x = 0, this.y = 0), this
                },
                divide: function(e) {
                    return this.x /= e.x, this.y /= e.y, this
                },
                divideScalar: function(e) {
                    return this.multiplyScalar(1 / e)
                },
                min: function(e) {
                    return this.x = Math.min(this.x, e.x), this.y = Math.min(this.y, e.y), this
                },
                max: function(e) {
                    return this.x = Math.max(this.x, e.x), this.y = Math.max(this.y, e.y), this
                },
                clamp: function(e, t) {
                    return this.x = Math.max(e.x, Math.min(t.x, this.x)), this.y = Math.max(e.y, Math.min(t.y, this.y)), this
                },
                clampScalar: function() {
                    var e, t;
                    return function(i, n) {
                        return void 0 === e && (e = new r.Vector2, t = new r.Vector2), e.set(i, i), t.set(n, n), this.clamp(e, t)
                    }
                }(),
                clampLength: function(e, t) {
                    var i = this.length();
                    return this.multiplyScalar(Math.max(e, Math.min(t, i)) / i), this
                },
                floor: function() {
                    return this.x = Math.floor(this.x), this.y = Math.floor(this.y), this
                },
                ceil: function() {
                    return this.x = Math.ceil(this.x), this.y = Math.ceil(this.y), this
                },
                round: function() {
                    return this.x = Math.round(this.x), this.y = Math.round(this.y), this
                },
                roundToZero: function() {
                    return this.x = this.x < 0 ? Math.ceil(this.x) : Math.floor(this.x), this.y = this.y < 0 ? Math.ceil(this.y) : Math.floor(this.y), this
                },
                negate: function() {
                    return this.x = -this.x, this.y = -this.y, this
                },
                dot: function(e) {
                    return this.x * e.x + this.y * e.y
                },
                lengthSq: function() {
                    return this.x * this.x + this.y * this.y
                },
                length: function() {
                    return Math.sqrt(this.x * this.x + this.y * this.y)
                },
                lengthManhattan: function() {
                    return Math.abs(this.x) + Math.abs(this.y)
                },
                normalize: function() {
                    return this.divideScalar(this.length())
                },
                angle: function() {
                    var e = Math.atan2(this.y, this.x);
                    return 0 > e && (e += 2 * Math.PI), e
                },
                distanceTo: function(e) {
                    return Math.sqrt(this.distanceToSquared(e))
                },
                distanceToSquared: function(e) {
                    var t = this.x - e.x,
                        i = this.y - e.y;
                    return t * t + i * i
                },
                setLength: function(e) {
                    return this.multiplyScalar(e / this.length())
                },
                lerp: function(e, t) {
                    return this.x += (e.x - this.x) * t, this.y += (e.y - this.y) * t, this
                },
                lerpVectors: function(e, t, i) {
                    return this.subVectors(t, e).multiplyScalar(i).add(e), this
                },
                equals: function(e) {
                    return e.x === this.x && e.y === this.y
                },
                fromArray: function(e, t) {
                    return void 0 === t && (t = 0), this.x = e[t], this.y = e[t + 1], this
                },
                toArray: function(e, t) {
                    return void 0 === e && (e = []), void 0 === t && (t = 0), e[t] = this.x, e[t + 1] = this.y, e
                },
                fromAttribute: function(e, t, i) {
                    return void 0 === i && (i = 0), t = t * e.itemSize + i, this.x = e.array[t], this.y = e.array[t + 1], this
                },
                rotateAround: function(e, t) {
                    var i = Math.cos(t),
                        r = Math.sin(t),
                        n = this.x - e.x,
                        o = this.y - e.y;
                    return this.x = n * i - o * r + e.x, this.y = n * r + o * i + e.y, this
                }
            }, r.Vector3 = function(e, t, i) {
                this.x = e || 0, this.y = t || 0, this.z = i || 0
            }, r.Vector3.prototype = {
                constructor: r.Vector3,
                set: function(e, t, i) {
                    return this.x = e, this.y = t, this.z = i, this
                },
                setScalar: function(e) {
                    return this.x = e, this.y = e, this.z = e, this
                },
                setX: function(e) {
                    return this.x = e, this
                },
                setY: function(e) {
                    return this.y = e, this
                },
                setZ: function(e) {
                    return this.z = e, this
                },
                setComponent: function(e, t) {
                    switch (e) {
                        case 0:
                            this.x = t;
                            break;
                        case 1:
                            this.y = t;
                            break;
                        case 2:
                            this.z = t;
                            break;
                        default:
                            throw new Error("index is out of range: " + e)
                    }
                },
                getComponent: function(e) {
                    switch (e) {
                        case 0:
                            return this.x;
                        case 1:
                            return this.y;
                        case 2:
                            return this.z;
                        default:
                            throw new Error("index is out of range: " + e)
                    }
                },
                clone: function() {
                    return new this.constructor(this.x, this.y, this.z)
                },
                copy: function(e) {
                    return this.x = e.x, this.y = e.y, this.z = e.z, this
                },
                add: function(e, t) {
                    return void 0 !== t ? (console.warn("THREE.Vector3: .add() now only accepts one argument. Use .addVectors( a, b ) instead."), this.addVectors(e, t)) : (this.x += e.x, this.y += e.y, this.z += e.z, this)
                },
                addScalar: function(e) {
                    return this.x += e, this.y += e, this.z += e, this
                },
                addVectors: function(e, t) {
                    return this.x = e.x + t.x, this.y = e.y + t.y, this.z = e.z + t.z, this
                },
                addScaledVector: function(e, t) {
                    return this.x += e.x * t, this.y += e.y * t, this.z += e.z * t, this
                },
                sub: function(e, t) {
                    return void 0 !== t ? (console.warn("THREE.Vector3: .sub() now only accepts one argument. Use .subVectors( a, b ) instead."), this.subVectors(e, t)) : (this.x -= e.x, this.y -= e.y, this.z -= e.z, this)
                },
                subScalar: function(e) {
                    return this.x -= e, this.y -= e, this.z -= e, this
                },
                subVectors: function(e, t) {
                    return this.x = e.x - t.x, this.y = e.y - t.y, this.z = e.z - t.z, this
                },
                multiply: function(e, t) {
                    return void 0 !== t ? (console.warn("THREE.Vector3: .multiply() now only accepts one argument. Use .multiplyVectors( a, b ) instead."), this.multiplyVectors(e, t)) : (this.x *= e.x, this.y *= e.y, this.z *= e.z, this)
                },
                multiplyScalar: function(e) {
                    return isFinite(e) ? (this.x *= e, this.y *= e, this.z *= e) : (this.x = 0, this.y = 0, this.z = 0), this
                },
                multiplyVectors: function(e, t) {
                    return this.x = e.x * t.x, this.y = e.y * t.y, this.z = e.z * t.z, this
                },
                applyEuler: function() {
                    var e;
                    return function(t) {
                        return t instanceof r.Euler == !1 && console.error("THREE.Vector3: .applyEuler() now expects an Euler rotation rather than a Vector3 and order."), void 0 === e && (e = new r.Quaternion), this.applyQuaternion(e.setFromEuler(t)), this
                    }
                }(),
                applyAxisAngle: function() {
                    var e;
                    return function(t, i) {
                        return void 0 === e && (e = new r.Quaternion), this.applyQuaternion(e.setFromAxisAngle(t, i)), this
                    }
                }(),
                applyMatrix3: function(e) {
                    var t = this.x,
                        i = this.y,
                        r = this.z,
                        n = e.elements;
                    return this.x = n[0] * t + n[3] * i + n[6] * r, this.y = n[1] * t + n[4] * i + n[7] * r, this.z = n[2] * t + n[5] * i + n[8] * r, this
                },
                applyMatrix4: function(e) {
                    var t = this.x,
                        i = this.y,
                        r = this.z,
                        n = e.elements;
                    return this.x = n[0] * t + n[4] * i + n[8] * r + n[12], this.y = n[1] * t + n[5] * i + n[9] * r + n[13], this.z = n[2] * t + n[6] * i + n[10] * r + n[14], this
                },
                applyProjection: function(e) {
                    var t = this.x,
                        i = this.y,
                        r = this.z,
                        n = e.elements,
                        o = 1 / (n[3] * t + n[7] * i + n[11] * r + n[15]);
                    return this.x = (n[0] * t + n[4] * i + n[8] * r + n[12]) * o, this.y = (n[1] * t + n[5] * i + n[9] * r + n[13]) * o, this.z = (n[2] * t + n[6] * i + n[10] * r + n[14]) * o, this
                },
                applyQuaternion: function(e) {
                    var t = this.x,
                        i = this.y,
                        r = this.z,
                        n = e.x,
                        o = e.y,
                        a = e.z,
                        s = e.w,
                        l = s * t + o * r - a * i,
                        c = s * i + a * t - n * r,
                        h = s * r + n * i - o * t,
                        u = -n * t - o * i - a * r;
                    return this.x = l * s + u * -n + c * -a - h * -o, this.y = c * s + u * -o + h * -n - l * -a, this.z = h * s + u * -a + l * -o - c * -n, this
                },
                project: function() {
                    var e;
                    return function(t) {
                        return void 0 === e && (e = new r.Matrix4), e.multiplyMatrices(t.projectionMatrix, e.getInverse(t.matrixWorld)), this.applyProjection(e)
                    }
                }(),
                unproject: function() {
                    var e;
                    return function(t) {
                        return void 0 === e && (e = new r.Matrix4), e.multiplyMatrices(t.matrixWorld, e.getInverse(t.projectionMatrix)), this.applyProjection(e)
                    }
                }(),
                transformDirection: function(e) {
                    var t = this.x,
                        i = this.y,
                        r = this.z,
                        n = e.elements;
                    return this.x = n[0] * t + n[4] * i + n[8] * r, this.y = n[1] * t + n[5] * i + n[9] * r, this.z = n[2] * t + n[6] * i + n[10] * r, this.normalize(), this
                },
                divide: function(e) {
                    return this.x /= e.x, this.y /= e.y, this.z /= e.z, this
                },
                divideScalar: function(e) {
                    return this.multiplyScalar(1 / e)
                },
                min: function(e) {
                    return this.x = Math.min(this.x, e.x), this.y = Math.min(this.y, e.y), this.z = Math.min(this.z, e.z), this
                },
                max: function(e) {
                    return this.x = Math.max(this.x, e.x), this.y = Math.max(this.y, e.y), this.z = Math.max(this.z, e.z), this
                },
                clamp: function(e, t) {
                    return this.x = Math.max(e.x, Math.min(t.x, this.x)), this.y = Math.max(e.y, Math.min(t.y, this.y)), this.z = Math.max(e.z, Math.min(t.z, this.z)), this
                },
                clampScalar: function() {
                    var e, t;
                    return function(i, n) {
                        return void 0 === e && (e = new r.Vector3, t = new r.Vector3), e.set(i, i, i), t.set(n, n, n), this.clamp(e, t)
                    }
                }(),
                clampLength: function(e, t) {
                    var i = this.length();
                    return this.multiplyScalar(Math.max(e, Math.min(t, i)) / i), this
                },
                floor: function() {
                    return this.x = Math.floor(this.x), this.y = Math.floor(this.y), this.z = Math.floor(this.z), this
                },
                ceil: function() {
                    return this.x = Math.ceil(this.x), this.y = Math.ceil(this.y), this.z = Math.ceil(this.z), this
                },
                round: function() {
                    return this.x = Math.round(this.x), this.y = Math.round(this.y), this.z = Math.round(this.z), this
                },
                roundToZero: function() {
                    return this.x = this.x < 0 ? Math.ceil(this.x) : Math.floor(this.x), this.y = this.y < 0 ? Math.ceil(this.y) : Math.floor(this.y), this.z = this.z < 0 ? Math.ceil(this.z) : Math.floor(this.z), this
                },
                negate: function() {
                    return this.x = -this.x, this.y = -this.y, this.z = -this.z, this
                },
                dot: function(e) {
                    return this.x * e.x + this.y * e.y + this.z * e.z
                },
                lengthSq: function() {
                    return this.x * this.x + this.y * this.y + this.z * this.z
                },
                length: function() {
                    return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z)
                },
                lengthManhattan: function() {
                    return Math.abs(this.x) + Math.abs(this.y) + Math.abs(this.z)
                },
                normalize: function() {
                    return this.divideScalar(this.length())
                },
                setLength: function(e) {
                    return this.multiplyScalar(e / this.length())
                },
                lerp: function(e, t) {
                    return this.x += (e.x - this.x) * t, this.y += (e.y - this.y) * t, this.z += (e.z - this.z) * t, this
                },
                lerpVectors: function(e, t, i) {
                    return this.subVectors(t, e).multiplyScalar(i).add(e), this
                },
                cross: function(e, t) {
                    if (void 0 !== t) return console.warn("THREE.Vector3: .cross() now only accepts one argument. Use .crossVectors( a, b ) instead."), this.crossVectors(e, t);
                    var i = this.x,
                        r = this.y,
                        n = this.z;
                    return this.x = r * e.z - n * e.y, this.y = n * e.x - i * e.z, this.z = i * e.y - r * e.x, this
                },
                crossVectors: function(e, t) {
                    var i = e.x,
                        r = e.y,
                        n = e.z,
                        o = t.x,
                        a = t.y,
                        s = t.z;
                    return this.x = r * s - n * a, this.y = n * o - i * s, this.z = i * a - r * o, this
                },
                projectOnVector: function() {
                    var e, t;
                    return function(i) {
                        return void 0 === e && (e = new r.Vector3), e.copy(i).normalize(), t = this.dot(e), this.copy(e).multiplyScalar(t)
                    }
                }(),
                projectOnPlane: function() {
                    var e;
                    return function(t) {
                        return void 0 === e && (e = new r.Vector3), e.copy(this).projectOnVector(t), this.sub(e)
                    }
                }(),
                reflect: function() {
                    var e;
                    return function(t) {
                        return void 0 === e && (e = new r.Vector3), this.sub(e.copy(t).multiplyScalar(2 * this.dot(t)))
                    }
                }(),
                angleTo: function(e) {
                    var t = this.dot(e) / Math.sqrt(this.lengthSq() * e.lengthSq());
                    return Math.acos(r.Math.clamp(t, -1, 1))
                },
                distanceTo: function(e) {
                    return Math.sqrt(this.distanceToSquared(e))
                },
                distanceToSquared: function(e) {
                    var t = this.x - e.x,
                        i = this.y - e.y,
                        r = this.z - e.z;
                    return t * t + i * i + r * r
                },
                setFromSpherical: function(e) {
                    var t = Math.sin(e.phi) * e.radius;
                    return this.x = t * Math.sin(e.theta), this.y = Math.cos(e.phi) * e.radius, this.z = t * Math.cos(e.theta), this
                },
                setFromMatrixPosition: function(e) {
                    return this.setFromMatrixColumn(e, 3)
                },
                setFromMatrixScale: function(e) {
                    var t = this.setFromMatrixColumn(e, 0).length(),
                        i = this.setFromMatrixColumn(e, 1).length(),
                        r = this.setFromMatrixColumn(e, 2).length();
                    return this.x = t, this.y = i, this.z = r, this
                },
                setFromMatrixColumn: function(e, t) {
                    return "number" == typeof e && (console.warn("THREE.Vector3: setFromMatrixColumn now expects ( matrix, index )."), e = arguments[1], t = arguments[0]), this.fromArray(e.elements, 4 * t)
                },
                equals: function(e) {
                    return e.x === this.x && e.y === this.y && e.z === this.z
                },
                fromArray: function(e, t) {
                    return void 0 === t && (t = 0), this.x = e[t], this.y = e[t + 1], this.z = e[t + 2], this
                },
                toArray: function(e, t) {
                    return void 0 === e && (e = []), void 0 === t && (t = 0), e[t] = this.x, e[t + 1] = this.y, e[t + 2] = this.z, e
                },
                fromAttribute: function(e, t, i) {
                    return void 0 === i && (i = 0), t = t * e.itemSize + i, this.x = e.array[t], this.y = e.array[t + 1], this.z = e.array[t + 2], this
                }
            }, r.Vector4 = function(e, t, i, r) {
                this.x = e || 0, this.y = t || 0, this.z = i || 0, this.w = void 0 !== r ? r : 1
            }, r.Vector4.prototype = {
                constructor: r.Vector4,
                set: function(e, t, i, r) {
                    return this.x = e, this.y = t, this.z = i, this.w = r, this
                },
                setScalar: function(e) {
                    return this.x = e, this.y = e, this.z = e, this.w = e, this
                },
                setX: function(e) {
                    return this.x = e, this
                },
                setY: function(e) {
                    return this.y = e, this
                },
                setZ: function(e) {
                    return this.z = e, this
                },
                setW: function(e) {
                    return this.w = e, this
                },
                setComponent: function(e, t) {
                    switch (e) {
                        case 0:
                            this.x = t;
                            break;
                        case 1:
                            this.y = t;
                            break;
                        case 2:
                            this.z = t;
                            break;
                        case 3:
                            this.w = t;
                            break;
                        default:
                            throw new Error("index is out of range: " + e)
                    }
                },
                getComponent: function(e) {
                    switch (e) {
                        case 0:
                            return this.x;
                        case 1:
                            return this.y;
                        case 2:
                            return this.z;
                        case 3:
                            return this.w;
                        default:
                            throw new Error("index is out of range: " + e)
                    }
                },
                clone: function() {
                    return new this.constructor(this.x, this.y, this.z, this.w)
                },
                copy: function(e) {
                    return this.x = e.x, this.y = e.y, this.z = e.z, this.w = void 0 !== e.w ? e.w : 1, this
                },
                add: function(e, t) {
                    return void 0 !== t ? (console.warn("THREE.Vector4: .add() now only accepts one argument. Use .addVectors( a, b ) instead."), this.addVectors(e, t)) : (this.x += e.x, this.y += e.y, this.z += e.z, this.w += e.w, this)
                },
                addScalar: function(e) {
                    return this.x += e, this.y += e, this.z += e, this.w += e, this
                },
                addVectors: function(e, t) {
                    return this.x = e.x + t.x, this.y = e.y + t.y, this.z = e.z + t.z, this.w = e.w + t.w, this
                },
                addScaledVector: function(e, t) {
                    return this.x += e.x * t, this.y += e.y * t, this.z += e.z * t, this.w += e.w * t, this
                },
                sub: function(e, t) {
                    return void 0 !== t ? (console.warn("THREE.Vector4: .sub() now only accepts one argument. Use .subVectors( a, b ) instead."), this.subVectors(e, t)) : (this.x -= e.x, this.y -= e.y, this.z -= e.z, this.w -= e.w, this)
                },
                subScalar: function(e) {
                    return this.x -= e, this.y -= e, this.z -= e, this.w -= e, this
                },
                subVectors: function(e, t) {
                    return this.x = e.x - t.x, this.y = e.y - t.y, this.z = e.z - t.z, this.w = e.w - t.w, this
                },
                multiplyScalar: function(e) {
                    return isFinite(e) ? (this.x *= e, this.y *= e, this.z *= e, this.w *= e) : (this.x = 0, this.y = 0, this.z = 0, this.w = 0), this
                },
                applyMatrix4: function(e) {
                    var t = this.x,
                        i = this.y,
                        r = this.z,
                        n = this.w,
                        o = e.elements;
                    return this.x = o[0] * t + o[4] * i + o[8] * r + o[12] * n, this.y = o[1] * t + o[5] * i + o[9] * r + o[13] * n, this.z = o[2] * t + o[6] * i + o[10] * r + o[14] * n, this.w = o[3] * t + o[7] * i + o[11] * r + o[15] * n, this
                },
                divideScalar: function(e) {
                    return this.multiplyScalar(1 / e)
                },
                setAxisAngleFromQuaternion: function(e) {
                    this.w = 2 * Math.acos(e.w);
                    var t = Math.sqrt(1 - e.w * e.w);
                    return 1e-4 > t ? (this.x = 1, this.y = 0, this.z = 0) : (this.x = e.x / t, this.y = e.y / t, this.z = e.z / t), this
                },
                setAxisAngleFromRotationMatrix: function(e) {
                    var t, i, r, n, o = .01,
                        a = .1,
                        s = e.elements,
                        l = s[0],
                        c = s[4],
                        h = s[8],
                        u = s[1],
                        p = s[5],
                        f = s[9],
                        d = s[2],
                        m = s[6],
                        g = s[10];
                    if (Math.abs(c - u) < o && Math.abs(h - d) < o && Math.abs(f - m) < o) {
                        if (Math.abs(c + u) < a && Math.abs(h + d) < a && Math.abs(f + m) < a && Math.abs(l + p + g - 3) < a) return this.set(1, 0, 0, 0), this;
                        t = Math.PI;
                        var v = (l + 1) / 2,
                            y = (p + 1) / 2,
                            _ = (g + 1) / 2,
                            x = (c + u) / 4,
                            b = (h + d) / 4,
                            w = (f + m) / 4;
                        return v > y && v > _ ? o > v ? (i = 0, r = .707106781, n = .707106781) : (i = Math.sqrt(v), r = x / i, n = b / i) : y > _ ? o > y ? (i = .707106781, r = 0, n = .707106781) : (r = Math.sqrt(y), i = x / r, n = w / r) : o > _ ? (i = .707106781, r = .707106781, n = 0) : (n = Math.sqrt(_), i = b / n, r = w / n), this.set(i, r, n, t), this
                    }
                    var T = Math.sqrt((m - f) * (m - f) + (h - d) * (h - d) + (u - c) * (u - c));
                    return Math.abs(T) < .001 && (T = 1), this.x = (m - f) / T, this.y = (h - d) / T, this.z = (u - c) / T, this.w = Math.acos((l + p + g - 1) / 2), this
                },
                min: function(e) {
                    return this.x = Math.min(this.x, e.x), this.y = Math.min(this.y, e.y), this.z = Math.min(this.z, e.z), this.w = Math.min(this.w, e.w), this
                },
                max: function(e) {
                    return this.x = Math.max(this.x, e.x), this.y = Math.max(this.y, e.y), this.z = Math.max(this.z, e.z), this.w = Math.max(this.w, e.w), this
                },
                clamp: function(e, t) {
                    return this.x = Math.max(e.x, Math.min(t.x, this.x)), this.y = Math.max(e.y, Math.min(t.y, this.y)), this.z = Math.max(e.z, Math.min(t.z, this.z)), this.w = Math.max(e.w, Math.min(t.w, this.w)), this
                },
                clampScalar: function() {
                    var e, t;
                    return function(i, n) {
                        return void 0 === e && (e = new r.Vector4, t = new r.Vector4), e.set(i, i, i, i), t.set(n, n, n, n), this.clamp(e, t)
                    }
                }(),
                floor: function() {
                    return this.x = Math.floor(this.x), this.y = Math.floor(this.y), this.z = Math.floor(this.z), this.w = Math.floor(this.w), this
                },
                ceil: function() {
                    return this.x = Math.ceil(this.x), this.y = Math.ceil(this.y), this.z = Math.ceil(this.z), this.w = Math.ceil(this.w), this
                },
                round: function() {
                    return this.x = Math.round(this.x), this.y = Math.round(this.y), this.z = Math.round(this.z), this.w = Math.round(this.w), this
                },
                roundToZero: function() {
                    return this.x = this.x < 0 ? Math.ceil(this.x) : Math.floor(this.x), this.y = this.y < 0 ? Math.ceil(this.y) : Math.floor(this.y), this.z = this.z < 0 ? Math.ceil(this.z) : Math.floor(this.z), this.w = this.w < 0 ? Math.ceil(this.w) : Math.floor(this.w), this
                },
                negate: function() {
                    return this.x = -this.x, this.y = -this.y, this.z = -this.z, this.w = -this.w, this
                },
                dot: function(e) {
                    return this.x * e.x + this.y * e.y + this.z * e.z + this.w * e.w
                },
                lengthSq: function() {
                    return this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w
                },
                length: function() {
                    return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w)
                },
                lengthManhattan: function() {
                    return Math.abs(this.x) + Math.abs(this.y) + Math.abs(this.z) + Math.abs(this.w)
                },
                normalize: function() {
                    return this.divideScalar(this.length())
                },
                setLength: function(e) {
                    return this.multiplyScalar(e / this.length())
                },
                lerp: function(e, t) {
                    return this.x += (e.x - this.x) * t, this.y += (e.y - this.y) * t, this.z += (e.z - this.z) * t, this.w += (e.w - this.w) * t, this
                },
                lerpVectors: function(e, t, i) {
                    return this.subVectors(t, e).multiplyScalar(i).add(e), this
                },
                equals: function(e) {
                    return e.x === this.x && e.y === this.y && e.z === this.z && e.w === this.w
                },
                fromArray: function(e, t) {
                    return void 0 === t && (t = 0), this.x = e[t], this.y = e[t + 1], this.z = e[t + 2], this.w = e[t + 3], this
                },
                toArray: function(e, t) {
                    return void 0 === e && (e = []), void 0 === t && (t = 0), e[t] = this.x, e[t + 1] = this.y, e[t + 2] = this.z, e[t + 3] = this.w, e
                },
                fromAttribute: function(e, t, i) {
                    return void 0 === i && (i = 0), t = t * e.itemSize + i, this.x = e.array[t], this.y = e.array[t + 1], this.z = e.array[t + 2], this.w = e.array[t + 3], this
                }
            }, r.Euler = function(e, t, i, n) {
                this._x = e || 0, this._y = t || 0, this._z = i || 0, this._order = n || r.Euler.DefaultOrder
            }, r.Euler.RotationOrders = ["XYZ", "YZX", "ZXY", "XZY", "YXZ", "ZYX"], r.Euler.DefaultOrder = "XYZ", r.Euler.prototype = {
                constructor: r.Euler,
                get x() {
                    return this._x
                },
                set x(e) {
                    this._x = e, this.onChangeCallback()
                },
                get y() {
                    return this._y
                },
                set y(e) {
                    this._y = e, this.onChangeCallback()
                },
                get z() {
                    return this._z
                },
                set z(e) {
                    this._z = e, this.onChangeCallback()
                },
                get order() {
                    return this._order
                },
                set order(e) {
                    this._order = e, this.onChangeCallback()
                },
                set: function(e, t, i, r) {
                    return this._x = e, this._y = t, this._z = i, this._order = r || this._order, this.onChangeCallback(), this
                },
                clone: function() {
                    return new this.constructor(this._x, this._y, this._z, this._order)
                },
                copy: function(e) {
                    return this._x = e._x, this._y = e._y, this._z = e._z, this._order = e._order, this.onChangeCallback(), this
                },
                setFromRotationMatrix: function(e, t, i) {
                    var n = r.Math.clamp,
                        o = e.elements,
                        a = o[0],
                        s = o[4],
                        l = o[8],
                        c = o[1],
                        h = o[5],
                        u = o[9],
                        p = o[2],
                        f = o[6],
                        d = o[10];
                    return t = t || this._order, "XYZ" === t ? (this._y = Math.asin(n(l, -1, 1)), Math.abs(l) < .99999 ? (this._x = Math.atan2(-u, d), this._z = Math.atan2(-s, a)) : (this._x = Math.atan2(f, h), this._z = 0)) : "YXZ" === t ? (this._x = Math.asin(-n(u, -1, 1)), Math.abs(u) < .99999 ? (this._y = Math.atan2(l, d), this._z = Math.atan2(c, h)) : (this._y = Math.atan2(-p, a), this._z = 0)) : "ZXY" === t ? (this._x = Math.asin(n(f, -1, 1)), Math.abs(f) < .99999 ? (this._y = Math.atan2(-p, d), this._z = Math.atan2(-s, h)) : (this._y = 0, this._z = Math.atan2(c, a))) : "ZYX" === t ? (this._y = Math.asin(-n(p, -1, 1)), Math.abs(p) < .99999 ? (this._x = Math.atan2(f, d), this._z = Math.atan2(c, a)) : (this._x = 0, this._z = Math.atan2(-s, h))) : "YZX" === t ? (this._z = Math.asin(n(c, -1, 1)), Math.abs(c) < .99999 ? (this._x = Math.atan2(-u, h), this._y = Math.atan2(-p, a)) : (this._x = 0, this._y = Math.atan2(l, d))) : "XZY" === t ? (this._z = Math.asin(-n(s, -1, 1)), Math.abs(s) < .99999 ? (this._x = Math.atan2(f, h), this._y = Math.atan2(l, a)) : (this._x = Math.atan2(-u, d), this._y = 0)) : console.warn("THREE.Euler: .setFromRotationMatrix() given unsupported order: " + t), this._order = t, i !== !1 && this.onChangeCallback(), this
                },
                setFromQuaternion: function() {
                    var e;
                    return function(t, i, n) {
                        return void 0 === e && (e = new r.Matrix4), e.makeRotationFromQuaternion(t), this.setFromRotationMatrix(e, i, n), this
                    }
                }(),
                setFromVector3: function(e, t) {
                    return this.set(e.x, e.y, e.z, t || this._order)
                },
                reorder: function() {
                    var e = new r.Quaternion;
                    return function(t) {
                        e.setFromEuler(this), this.setFromQuaternion(e, t)
                    }
                }(),
                equals: function(e) {
                    return e._x === this._x && e._y === this._y && e._z === this._z && e._order === this._order
                },
                fromArray: function(e) {
                    return this._x = e[0], this._y = e[1], this._z = e[2], void 0 !== e[3] && (this._order = e[3]), this.onChangeCallback(), this
                },
                toArray: function(e, t) {
                    return void 0 === e && (e = []), void 0 === t && (t = 0), e[t] = this._x, e[t + 1] = this._y, e[t + 2] = this._z, e[t + 3] = this._order, e
                },
                toVector3: function(e) {
                    return e ? e.set(this._x, this._y, this._z) : new r.Vector3(this._x, this._y, this._z)
                },
                onChange: function(e) {
                    return this.onChangeCallback = e, this
                },
                onChangeCallback: function() {}
            }, r.Line3 = function(e, t) {
                this.start = void 0 !== e ? e : new r.Vector3, this.end = void 0 !== t ? t : new r.Vector3
            }, r.Line3.prototype = {
                constructor: r.Line3,
                set: function(e, t) {
                    return this.start.copy(e), this.end.copy(t), this
                },
                clone: function() {
                    return (new this.constructor).copy(this)
                },
                copy: function(e) {
                    return this.start.copy(e.start), this.end.copy(e.end), this
                },
                center: function(e) {
                    var t = e || new r.Vector3;
                    return t.addVectors(this.start, this.end).multiplyScalar(.5)
                },
                delta: function(e) {
                    var t = e || new r.Vector3;
                    return t.subVectors(this.end, this.start)
                },
                distanceSq: function() {
                    return this.start.distanceToSquared(this.end)
                },
                distance: function() {
                    return this.start.distanceTo(this.end)
                },
                at: function(e, t) {
                    var i = t || new r.Vector3;
                    return this.delta(i).multiplyScalar(e).add(this.start)
                },
                closestPointToPointParameter: function() {
                    var e = new r.Vector3,
                        t = new r.Vector3;
                    return function(i, n) {
                        e.subVectors(i, this.start), t.subVectors(this.end, this.start);
                        var o = t.dot(t),
                            a = t.dot(e),
                            s = a / o;
                        return n && (s = r.Math.clamp(s, 0, 1)), s
                    }
                }(),
                closestPointToPoint: function(e, t, i) {
                    var n = this.closestPointToPointParameter(e, t),
                        o = i || new r.Vector3;
                    return this.delta(o).multiplyScalar(n).add(this.start)
                },
                applyMatrix4: function(e) {
                    return this.start.applyMatrix4(e), this.end.applyMatrix4(e), this
                },
                equals: function(e) {
                    return e.start.equals(this.start) && e.end.equals(this.end)
                }
            }, r.Box2 = function(e, t) {
                this.min = void 0 !== e ? e : new r.Vector2(+(1 / 0), +(1 / 0)), this.max = void 0 !== t ? t : new r.Vector2(-(1 / 0), -(1 / 0))
            }, r.Box2.prototype = {
                constructor: r.Box2,
                set: function(e, t) {
                    return this.min.copy(e), this.max.copy(t), this
                },
                setFromPoints: function(e) {
                    this.makeEmpty();
                    for (var t = 0, i = e.length; i > t; t++) this.expandByPoint(e[t]);
                    return this
                },
                setFromCenterAndSize: function() {
                    var e = new r.Vector2;
                    return function(t, i) {
                        var r = e.copy(i).multiplyScalar(.5);
                        return this.min.copy(t).sub(r), this.max.copy(t).add(r), this
                    }
                }(),
                clone: function() {
                    return (new this.constructor).copy(this)
                },
                copy: function(e) {
                    return this.min.copy(e.min), this.max.copy(e.max), this
                },
                makeEmpty: function() {
                    return this.min.x = this.min.y = +(1 / 0), this.max.x = this.max.y = -(1 / 0), this
                },
                isEmpty: function() {
                    return this.max.x < this.min.x || this.max.y < this.min.y
                },
                center: function(e) {
                    var t = e || new r.Vector2;
                    return t.addVectors(this.min, this.max).multiplyScalar(.5)
                },
                size: function(e) {
                    var t = e || new r.Vector2;
                    return t.subVectors(this.max, this.min)
                },
                expandByPoint: function(e) {
                    return this.min.min(e), this.max.max(e), this
                },
                expandByVector: function(e) {
                    return this.min.sub(e), this.max.add(e), this
                },
                expandByScalar: function(e) {
                    return this.min.addScalar(-e), this.max.addScalar(e), this
                },
                containsPoint: function(e) {
                    return !(e.x < this.min.x || e.x > this.max.x || e.y < this.min.y || e.y > this.max.y)
                },
                containsBox: function(e) {
                    return this.min.x <= e.min.x && e.max.x <= this.max.x && this.min.y <= e.min.y && e.max.y <= this.max.y
                },
                getParameter: function(e, t) {
                    var i = t || new r.Vector2;
                    return i.set((e.x - this.min.x) / (this.max.x - this.min.x), (e.y - this.min.y) / (this.max.y - this.min.y))
                },
                intersectsBox: function(e) {
                    return !(e.max.x < this.min.x || e.min.x > this.max.x || e.max.y < this.min.y || e.min.y > this.max.y)
                },
                clampPoint: function(e, t) {
                    var i = t || new r.Vector2;
                    return i.copy(e).clamp(this.min, this.max)
                },
                distanceToPoint: function() {
                    var e = new r.Vector2;
                    return function(t) {
                        var i = e.copy(t).clamp(this.min, this.max);
                        return i.sub(t).length()
                    }
                }(),
                intersect: function(e) {
                    return this.min.max(e.min), this.max.min(e.max), this
                },
                union: function(e) {
                    return this.min.min(e.min), this.max.max(e.max), this
                },
                translate: function(e) {
                    return this.min.add(e), this.max.add(e), this
                },
                equals: function(e) {
                    return e.min.equals(this.min) && e.max.equals(this.max)
                }
            }, r.Box3 = function(e, t) {
                this.min = void 0 !== e ? e : new r.Vector3(+(1 / 0), +(1 / 0), +(1 / 0)), this.max = void 0 !== t ? t : new r.Vector3(-(1 / 0), -(1 / 0), -(1 / 0))
            }, r.Box3.prototype = {
                constructor: r.Box3,
                set: function(e, t) {
                    return this.min.copy(e), this.max.copy(t), this
                },
                setFromArray: function(e) {
                    this.makeEmpty();
                    for (var t = +(1 / 0), i = +(1 / 0), r = +(1 / 0), n = -(1 / 0), o = -(1 / 0), a = -(1 / 0), s = 0, l = e.length; l > s; s += 3) {
                        var c = e[s],
                            h = e[s + 1],
                            u = e[s + 2];
                        t > c && (t = c), i > h && (i = h), r > u && (r = u), c > n && (n = c), h > o && (o = h), u > a && (a = u)
                    }
                    this.min.set(t, i, r), this.max.set(n, o, a)
                },
                setFromPoints: function(e) {
                    this.makeEmpty();
                    for (var t = 0, i = e.length; i > t; t++) this.expandByPoint(e[t]);
                    return this
                },
                setFromCenterAndSize: function() {
                    var e = new r.Vector3;
                    return function(t, i) {
                        var r = e.copy(i).multiplyScalar(.5);
                        return this.min.copy(t).sub(r), this.max.copy(t).add(r), this
                    }
                }(),
                setFromObject: function() {
                    var e;
                    return function(t) {
                        void 0 === e && (e = new r.Box3);
                        var i = this;
                        return this.makeEmpty(), t.updateMatrixWorld(!0), t.traverse(function(t) {
                            var r = t.geometry;
                            void 0 !== r && (null === r.boundingBox && r.computeBoundingBox(), r.boundingBox.isEmpty() === !1 && (e.copy(r.boundingBox), e.applyMatrix4(t.matrixWorld), i.union(e)))
                        }), this
                    }
                }(),
                clone: function() {
                    return (new this.constructor).copy(this)
                },
                copy: function(e) {
                    return this.min.copy(e.min), this.max.copy(e.max), this
                },
                makeEmpty: function() {
                    return this.min.x = this.min.y = this.min.z = +(1 / 0), this.max.x = this.max.y = this.max.z = -(1 / 0), this
                },
                isEmpty: function() {
                    return this.max.x < this.min.x || this.max.y < this.min.y || this.max.z < this.min.z
                },
                center: function(e) {
                    var t = e || new r.Vector3;
                    return t.addVectors(this.min, this.max).multiplyScalar(.5)
                },
                size: function(e) {
                    var t = e || new r.Vector3;
                    return t.subVectors(this.max, this.min)
                },
                expandByPoint: function(e) {
                    return this.min.min(e), this.max.max(e), this
                },
                expandByVector: function(e) {
                    return this.min.sub(e), this.max.add(e), this
                },
                expandByScalar: function(e) {
                    return this.min.addScalar(-e), this.max.addScalar(e), this
                },
                containsPoint: function(e) {
                    return !(e.x < this.min.x || e.x > this.max.x || e.y < this.min.y || e.y > this.max.y || e.z < this.min.z || e.z > this.max.z)
                },
                containsBox: function(e) {
                    return this.min.x <= e.min.x && e.max.x <= this.max.x && this.min.y <= e.min.y && e.max.y <= this.max.y && this.min.z <= e.min.z && e.max.z <= this.max.z
                },
                getParameter: function(e, t) {
                    var i = t || new r.Vector3;
                    return i.set((e.x - this.min.x) / (this.max.x - this.min.x), (e.y - this.min.y) / (this.max.y - this.min.y), (e.z - this.min.z) / (this.max.z - this.min.z))
                },
                intersectsBox: function(e) {
                    return !(e.max.x < this.min.x || e.min.x > this.max.x || e.max.y < this.min.y || e.min.y > this.max.y || e.max.z < this.min.z || e.min.z > this.max.z)
                },
                intersectsSphere: function() {
                    var e;
                    return function(t) {
                        return void 0 === e && (e = new r.Vector3), this.clampPoint(t.center, e), e.distanceToSquared(t.center) <= t.radius * t.radius
                    }
                }(),
                intersectsPlane: function(e) {
                    var t, i;
                    return e.normal.x > 0 ? (t = e.normal.x * this.min.x, i = e.normal.x * this.max.x) : (t = e.normal.x * this.max.x, i = e.normal.x * this.min.x), e.normal.y > 0 ? (t += e.normal.y * this.min.y, i += e.normal.y * this.max.y) : (t += e.normal.y * this.max.y, i += e.normal.y * this.min.y), e.normal.z > 0 ? (t += e.normal.z * this.min.z, i += e.normal.z * this.max.z) : (t += e.normal.z * this.max.z, i += e.normal.z * this.min.z), t <= e.constant && i >= e.constant
                },
                clampPoint: function(e, t) {
                    var i = t || new r.Vector3;
                    return i.copy(e).clamp(this.min, this.max)
                },
                distanceToPoint: function() {
                    var e = new r.Vector3;
                    return function(t) {
                        var i = e.copy(t).clamp(this.min, this.max);
                        return i.sub(t).length()
                    }
                }(),
                getBoundingSphere: function() {
                    var e = new r.Vector3;
                    return function(t) {
                        var i = t || new r.Sphere;
                        return i.center = this.center(), i.radius = .5 * this.size(e).length(), i
                    }
                }(),
                intersect: function(e) {
                    return this.min.max(e.min), this.max.min(e.max), this
                },
                union: function(e) {
                    return this.min.min(e.min), this.max.max(e.max), this
                },
                applyMatrix4: function() {
                    var e = [new r.Vector3, new r.Vector3, new r.Vector3, new r.Vector3, new r.Vector3, new r.Vector3, new r.Vector3, new r.Vector3];
                    return function(t) {
                        return e[0].set(this.min.x, this.min.y, this.min.z).applyMatrix4(t), e[1].set(this.min.x, this.min.y, this.max.z).applyMatrix4(t), e[2].set(this.min.x, this.max.y, this.min.z).applyMatrix4(t), e[3].set(this.min.x, this.max.y, this.max.z).applyMatrix4(t), e[4].set(this.max.x, this.min.y, this.min.z).applyMatrix4(t), e[5].set(this.max.x, this.min.y, this.max.z).applyMatrix4(t), e[6].set(this.max.x, this.max.y, this.min.z).applyMatrix4(t), e[7].set(this.max.x, this.max.y, this.max.z).applyMatrix4(t), this.makeEmpty(), this.setFromPoints(e), this
                    }
                }(),
                translate: function(e) {
                    return this.min.add(e), this.max.add(e), this
                },
                equals: function(e) {
                    return e.min.equals(this.min) && e.max.equals(this.max)
                }
            }, r.Matrix3 = function() {
                this.elements = new Float32Array([1, 0, 0, 0, 1, 0, 0, 0, 1]), arguments.length > 0 && console.error("THREE.Matrix3: the constructor no longer reads arguments. use .set() instead.")
            }, r.Matrix3.prototype = {
                constructor: r.Matrix3,
                set: function(e, t, i, r, n, o, a, s, l) {
                    var c = this.elements;
                    return c[0] = e, c[1] = r, c[2] = a, c[3] = t, c[4] = n, c[5] = s, c[6] = i, c[7] = o, c[8] = l, this
                },
                identity: function() {
                    return this.set(1, 0, 0, 0, 1, 0, 0, 0, 1), this
                },
                clone: function() {
                    return (new this.constructor).fromArray(this.elements)
                },
                copy: function(e) {
                    var t = e.elements;
                    return this.set(t[0], t[3], t[6], t[1], t[4], t[7], t[2], t[5], t[8]), this
                },
                setFromMatrix4: function(e) {
                    var t = e.elements;
                    return this.set(t[0], t[4], t[8], t[1], t[5], t[9], t[2], t[6], t[10]), this
                },
                applyToVector3Array: function() {
                    var e;
                    return function(t, i, n) {
                        void 0 === e && (e = new r.Vector3), void 0 === i && (i = 0), void 0 === n && (n = t.length);
                        for (var o = 0, a = i; n > o; o += 3, a += 3) e.fromArray(t, a), e.applyMatrix3(this), e.toArray(t, a);
                        return t
                    }
                }(),
                applyToBuffer: function() {
                    var e;
                    return function(t, i, n) {
                        void 0 === e && (e = new r.Vector3), void 0 === i && (i = 0), void 0 === n && (n = t.length / t.itemSize);
                        for (var o = 0, a = i; n > o; o++, a++) e.x = t.getX(a), e.y = t.getY(a), e.z = t.getZ(a), e.applyMatrix3(this), t.setXYZ(e.x, e.y, e.z);
                        return t
                    }
                }(),
                multiplyScalar: function(e) {
                    var t = this.elements;
                    return t[0] *= e, t[3] *= e, t[6] *= e, t[1] *= e, t[4] *= e, t[7] *= e, t[2] *= e, t[5] *= e, t[8] *= e, this
                },
                determinant: function() {
                    var e = this.elements,
                        t = e[0],
                        i = e[1],
                        r = e[2],
                        n = e[3],
                        o = e[4],
                        a = e[5],
                        s = e[6],
                        l = e[7],
                        c = e[8];
                    return t * o * c - t * a * l - i * n * c + i * a * s + r * n * l - r * o * s
                },
                getInverse: function(e, t) {
                    e instanceof r.Matrix4 && console.warn("THREE.Matrix3.getInverse no longer takes a Matrix4 argument.");
                    var i = e.elements,
                        n = this.elements,
                        o = i[0],
                        a = i[1],
                        s = i[2],
                        l = i[3],
                        c = i[4],
                        h = i[5],
                        u = i[6],
                        p = i[7],
                        f = i[8],
                        d = f * c - h * p,
                        m = h * u - f * l,
                        g = p * l - c * u,
                        v = o * d + a * m + s * g;
                    if (0 === v) {
                        var y = "THREE.Matrix3.getInverse(): can't invert matrix, determinant is 0";
                        if (t) throw new Error(y);
                        return console.warn(y), this.identity()
                    }
                    return n[0] = d, n[1] = s * p - f * a, n[2] = h * a - s * c, n[3] = m, n[4] = f * o - s * u, n[5] = s * l - h * o, n[6] = g, n[7] = a * u - p * o, n[8] = c * o - a * l, this.multiplyScalar(1 / v)
                },
                transpose: function() {
                    var e, t = this.elements;
                    return e = t[1], t[1] = t[3], t[3] = e, e = t[2], t[2] = t[6], t[6] = e, e = t[5], t[5] = t[7], t[7] = e, this
                },
                flattenToArrayOffset: function(e, t) {
                    var i = this.elements;
                    return e[t] = i[0], e[t + 1] = i[1], e[t + 2] = i[2], e[t + 3] = i[3], e[t + 4] = i[4], e[t + 5] = i[5], e[t + 6] = i[6], e[t + 7] = i[7], e[t + 8] = i[8], e
                },
                getNormalMatrix: function(e) {
                    return this.setFromMatrix4(e).getInverse(this).transpose()
                },
                transposeIntoArray: function(e) {
                    var t = this.elements;
                    return e[0] = t[0], e[1] = t[3], e[2] = t[6], e[3] = t[1], e[4] = t[4], e[5] = t[7], e[6] = t[2], e[7] = t[5], e[8] = t[8], this
                },
                fromArray: function(e) {
                    return this.elements.set(e), this
                },
                toArray: function() {
                    var e = this.elements;
                    return [e[0], e[1], e[2], e[3], e[4], e[5], e[6], e[7], e[8]]
                }
            }, r.Matrix4 = function() {
                this.elements = new Float32Array([1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1]), arguments.length > 0 && console.error("THREE.Matrix4: the constructor no longer reads arguments. use .set() instead.")
            }, r.Matrix4.prototype = {
                constructor: r.Matrix4,
                set: function(e, t, i, r, n, o, a, s, l, c, h, u, p, f, d, m) {
                    var g = this.elements;
                    return g[0] = e, g[4] = t, g[8] = i, g[12] = r, g[1] = n, g[5] = o, g[9] = a, g[13] = s, g[2] = l, g[6] = c, g[10] = h, g[14] = u, g[3] = p, g[7] = f, g[11] = d, g[15] = m, this
                },
                identity: function() {
                    return this.set(1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1), this
                },
                clone: function() {
                    return (new r.Matrix4).fromArray(this.elements)
                },
                copy: function(e) {
                    return this.elements.set(e.elements), this
                },
                copyPosition: function(e) {
                    var t = this.elements,
                        i = e.elements;
                    return t[12] = i[12], t[13] = i[13], t[14] = i[14], this
                },
                extractBasis: function(e, t, i) {
                    return e.setFromMatrixColumn(this, 0), t.setFromMatrixColumn(this, 1), i.setFromMatrixColumn(this, 2), this
                },
                makeBasis: function(e, t, i) {
                    return this.set(e.x, t.x, i.x, 0, e.y, t.y, i.y, 0, e.z, t.z, i.z, 0, 0, 0, 0, 1), this
                },
                extractRotation: function() {
                    var e;
                    return function(t) {
                        void 0 === e && (e = new r.Vector3);
                        var i = this.elements,
                            n = t.elements,
                            o = 1 / e.setFromMatrixColumn(t, 0).length(),
                            a = 1 / e.setFromMatrixColumn(t, 1).length(),
                            s = 1 / e.setFromMatrixColumn(t, 2).length();
                        return i[0] = n[0] * o, i[1] = n[1] * o, i[2] = n[2] * o, i[4] = n[4] * a, i[5] = n[5] * a, i[6] = n[6] * a, i[8] = n[8] * s, i[9] = n[9] * s, i[10] = n[10] * s, this
                    }
                }(),
                makeRotationFromEuler: function(e) {
                    e instanceof r.Euler == !1 && console.error("THREE.Matrix: .makeRotationFromEuler() now expects a Euler rotation rather than a Vector3 and order.");
                    var t = this.elements,
                        i = e.x,
                        n = e.y,
                        o = e.z,
                        a = Math.cos(i),
                        s = Math.sin(i),
                        l = Math.cos(n),
                        c = Math.sin(n),
                        h = Math.cos(o),
                        u = Math.sin(o);
                    if ("XYZ" === e.order) {
                        var p = a * h,
                            f = a * u,
                            d = s * h,
                            m = s * u;
                        t[0] = l * h, t[4] = -l * u, t[8] = c, t[1] = f + d * c, t[5] = p - m * c, t[9] = -s * l, t[2] = m - p * c, t[6] = d + f * c, t[10] = a * l
                    } else if ("YXZ" === e.order) {
                        var g = l * h,
                            v = l * u,
                            y = c * h,
                            _ = c * u;
                        t[0] = g + _ * s, t[4] = y * s - v, t[8] = a * c, t[1] = a * u, t[5] = a * h, t[9] = -s, t[2] = v * s - y, t[6] = _ + g * s, t[10] = a * l
                    } else if ("ZXY" === e.order) {
                        var g = l * h,
                            v = l * u,
                            y = c * h,
                            _ = c * u;
                        t[0] = g - _ * s, t[4] = -a * u, t[8] = y + v * s, t[1] = v + y * s, t[5] = a * h, t[9] = _ - g * s, t[2] = -a * c, t[6] = s, t[10] = a * l
                    } else if ("ZYX" === e.order) {
                        var p = a * h,
                            f = a * u,
                            d = s * h,
                            m = s * u;
                        t[0] = l * h, t[4] = d * c - f, t[8] = p * c + m, t[1] = l * u, t[5] = m * c + p, t[9] = f * c - d, t[2] = -c, t[6] = s * l, t[10] = a * l
                    } else if ("YZX" === e.order) {
                        var x = a * l,
                            b = a * c,
                            w = s * l,
                            T = s * c;
                        t[0] = l * h, t[4] = T - x * u, t[8] = w * u + b, t[1] = u, t[5] = a * h, t[9] = -s * h, t[2] = -c * h, t[6] = b * u + w, t[10] = x - T * u
                    } else if ("XZY" === e.order) {
                        var x = a * l,
                            b = a * c,
                            w = s * l,
                            T = s * c;
                        t[0] = l * h, t[4] = -u, t[8] = c * h, t[1] = x * u + T, t[5] = a * h, t[9] = b * u - w, t[2] = w * u - b, t[6] = s * h, t[10] = T * u + x
                    }
                    return t[3] = 0, t[7] = 0, t[11] = 0, t[12] = 0, t[13] = 0, t[14] = 0, t[15] = 1, this
                },
                makeRotationFromQuaternion: function(e) {
                    var t = this.elements,
                        i = e.x,
                        r = e.y,
                        n = e.z,
                        o = e.w,
                        a = i + i,
                        s = r + r,
                        l = n + n,
                        c = i * a,
                        h = i * s,
                        u = i * l,
                        p = r * s,
                        f = r * l,
                        d = n * l,
                        m = o * a,
                        g = o * s,
                        v = o * l;
                    return t[0] = 1 - (p + d), t[4] = h - v, t[8] = u + g, t[1] = h + v, t[5] = 1 - (c + d), t[9] = f - m, t[2] = u - g, t[6] = f + m, t[10] = 1 - (c + p), t[3] = 0, t[7] = 0, t[11] = 0, t[12] = 0, t[13] = 0, t[14] = 0, t[15] = 1, this
                },
                lookAt: function() {
                    var e, t, i;
                    return function(n, o, a) {
                        void 0 === e && (e = new r.Vector3), void 0 === t && (t = new r.Vector3), void 0 === i && (i = new r.Vector3);
                        var s = this.elements;
                        return i.subVectors(n, o).normalize(), 0 === i.lengthSq() && (i.z = 1), e.crossVectors(a, i).normalize(), 0 === e.lengthSq() && (i.x += 1e-4, e.crossVectors(a, i).normalize()), t.crossVectors(i, e), s[0] = e.x, s[4] = t.x, s[8] = i.x, s[1] = e.y, s[5] = t.y, s[9] = i.y, s[2] = e.z, s[6] = t.z, s[10] = i.z, this
                    }
                }(),
                multiply: function(e, t) {
                    return void 0 !== t ? (console.warn("THREE.Matrix4: .multiply() now only accepts one argument. Use .multiplyMatrices( a, b ) instead."), this.multiplyMatrices(e, t)) : this.multiplyMatrices(this, e)
                },
                multiplyMatrices: function(e, t) {
                    var i = e.elements,
                        r = t.elements,
                        n = this.elements,
                        o = i[0],
                        a = i[4],
                        s = i[8],
                        l = i[12],
                        c = i[1],
                        h = i[5],
                        u = i[9],
                        p = i[13],
                        f = i[2],
                        d = i[6],
                        m = i[10],
                        g = i[14],
                        v = i[3],
                        y = i[7],
                        _ = i[11],
                        x = i[15],
                        b = r[0],
                        w = r[4],
                        T = r[8],
                        M = r[12],
                        S = r[1],
                        E = r[5],
                        A = r[9],
                        C = r[13],
                        L = r[2],
                        P = r[6],
                        R = r[10],
                        D = r[14],
                        O = r[3],
                        I = r[7],
                        F = r[11],
                        N = r[15];
                    return n[0] = o * b + a * S + s * L + l * O, n[4] = o * w + a * E + s * P + l * I, n[8] = o * T + a * A + s * R + l * F, n[12] = o * M + a * C + s * D + l * N, n[1] = c * b + h * S + u * L + p * O, n[5] = c * w + h * E + u * P + p * I, n[9] = c * T + h * A + u * R + p * F, n[13] = c * M + h * C + u * D + p * N, n[2] = f * b + d * S + m * L + g * O, n[6] = f * w + d * E + m * P + g * I, n[10] = f * T + d * A + m * R + g * F, n[14] = f * M + d * C + m * D + g * N, n[3] = v * b + y * S + _ * L + x * O, n[7] = v * w + y * E + _ * P + x * I, n[11] = v * T + y * A + _ * R + x * F, n[15] = v * M + y * C + _ * D + x * N, this
                },
                multiplyToArray: function(e, t, i) {
                    var r = this.elements;
                    return this.multiplyMatrices(e, t), i[0] = r[0], i[1] = r[1], i[2] = r[2], i[3] = r[3], i[4] = r[4], i[5] = r[5], i[6] = r[6], i[7] = r[7], i[8] = r[8], i[9] = r[9], i[10] = r[10], i[11] = r[11], i[12] = r[12], i[13] = r[13], i[14] = r[14], i[15] = r[15], this
                },
                multiplyScalar: function(e) {
                    var t = this.elements;
                    return t[0] *= e, t[4] *= e, t[8] *= e, t[12] *= e, t[1] *= e, t[5] *= e, t[9] *= e, t[13] *= e, t[2] *= e, t[6] *= e, t[10] *= e, t[14] *= e, t[3] *= e, t[7] *= e, t[11] *= e, t[15] *= e, this
                },
                applyToVector3Array: function() {
                    var e;
                    return function(t, i, n) {
                        void 0 === e && (e = new r.Vector3), void 0 === i && (i = 0), void 0 === n && (n = t.length);
                        for (var o = 0, a = i; n > o; o += 3, a += 3) e.fromArray(t, a), e.applyMatrix4(this), e.toArray(t, a);
                        return t
                    }
                }(),
                applyToBuffer: function() {
                    var e;
                    return function(t, i, n) {
                        void 0 === e && (e = new r.Vector3), void 0 === i && (i = 0), void 0 === n && (n = t.length / t.itemSize);
                        for (var o = 0, a = i; n > o; o++, a++) e.x = t.getX(a), e.y = t.getY(a), e.z = t.getZ(a), e.applyMatrix4(this), t.setXYZ(e.x, e.y, e.z);
                        return t
                    }
                }(),
                determinant: function() {
                    var e = this.elements,
                        t = e[0],
                        i = e[4],
                        r = e[8],
                        n = e[12],
                        o = e[1],
                        a = e[5],
                        s = e[9],
                        l = e[13],
                        c = e[2],
                        h = e[6],
                        u = e[10],
                        p = e[14],
                        f = e[3],
                        d = e[7],
                        m = e[11],
                        g = e[15];
                    return f * (+n * s * h - r * l * h - n * a * u + i * l * u + r * a * p - i * s * p) + d * (+t * s * p - t * l * u + n * o * u - r * o * p + r * l * c - n * s * c) + m * (+t * l * h - t * a * p - n * o * h + i * o * p + n * a * c - i * l * c) + g * (-r * a * c - t * s * h + t * a * u + r * o * h - i * o * u + i * s * c)
                },
                transpose: function() {
                    var e, t = this.elements;
                    return e = t[1], t[1] = t[4], t[4] = e, e = t[2], t[2] = t[8], t[8] = e, e = t[6], t[6] = t[9], t[9] = e, e = t[3], t[3] = t[12], t[12] = e, e = t[7], t[7] = t[13], t[13] = e, e = t[11], t[11] = t[14], t[14] = e, this
                },
                flattenToArrayOffset: function(e, t) {
                    var i = this.elements;
                    return e[t] = i[0], e[t + 1] = i[1], e[t + 2] = i[2], e[t + 3] = i[3], e[t + 4] = i[4], e[t + 5] = i[5], e[t + 6] = i[6], e[t + 7] = i[7], e[t + 8] = i[8], e[t + 9] = i[9], e[t + 10] = i[10], e[t + 11] = i[11], e[t + 12] = i[12], e[t + 13] = i[13], e[t + 14] = i[14], e[t + 15] = i[15], e
                },
                getPosition: function() {
                    var e;
                    return function() {
                        return void 0 === e && (e = new r.Vector3), console.warn("THREE.Matrix4: .getPosition() has been removed. Use Vector3.setFromMatrixPosition( matrix ) instead."), e.setFromMatrixColumn(this, 3)
                    }
                }(),
                setPosition: function(e) {
                    var t = this.elements;
                    return t[12] = e.x, t[13] = e.y, t[14] = e.z, this
                },
                getInverse: function(e, t) {
                    var i = this.elements,
                        r = e.elements,
                        n = r[0],
                        o = r[1],
                        a = r[2],
                        s = r[3],
                        l = r[4],
                        c = r[5],
                        h = r[6],
                        u = r[7],
                        p = r[8],
                        f = r[9],
                        d = r[10],
                        m = r[11],
                        g = r[12],
                        v = r[13],
                        y = r[14],
                        _ = r[15],
                        x = f * y * u - v * d * u + v * h * m - c * y * m - f * h * _ + c * d * _,
                        b = g * d * u - p * y * u - g * h * m + l * y * m + p * h * _ - l * d * _,
                        w = p * v * u - g * f * u + g * c * m - l * v * m - p * c * _ + l * f * _,
                        T = g * f * h - p * v * h - g * c * d + l * v * d + p * c * y - l * f * y,
                        M = n * x + o * b + a * w + s * T;
                    if (0 === M) {
                        var S = "THREE.Matrix4.getInverse(): can't invert matrix, determinant is 0";
                        if (t) throw new Error(S);
                        return console.warn(S), this.identity()
                    }
                    return i[0] = x, i[1] = v * d * s - f * y * s - v * a * m + o * y * m + f * a * _ - o * d * _, i[2] = c * y * s - v * h * s + v * a * u - o * y * u - c * a * _ + o * h * _, i[3] = f * h * s - c * d * s - f * a * u + o * d * u + c * a * m - o * h * m, i[4] = b, i[5] = p * y * s - g * d * s + g * a * m - n * y * m - p * a * _ + n * d * _, i[6] = g * h * s - l * y * s - g * a * u + n * y * u + l * a * _ - n * h * _, i[7] = l * d * s - p * h * s + p * a * u - n * d * u - l * a * m + n * h * m, i[8] = w, i[9] = g * f * s - p * v * s - g * o * m + n * v * m + p * o * _ - n * f * _, i[10] = l * v * s - g * c * s + g * o * u - n * v * u - l * o * _ + n * c * _, i[11] = p * c * s - l * f * s - p * o * u + n * f * u + l * o * m - n * c * m, i[12] = T, i[13] = p * v * a - g * f * a + g * o * d - n * v * d - p * o * y + n * f * y, i[14] = g * c * a - l * v * a - g * o * h + n * v * h + l * o * y - n * c * y, i[15] = l * f * a - p * c * a + p * o * h - n * f * h - l * o * d + n * c * d, this.multiplyScalar(1 / M)
                },
                scale: function(e) {
                    var t = this.elements,
                        i = e.x,
                        r = e.y,
                        n = e.z;
                    return t[0] *= i, t[4] *= r, t[8] *= n, t[1] *= i, t[5] *= r, t[9] *= n, t[2] *= i, t[6] *= r, t[10] *= n, t[3] *= i, t[7] *= r, t[11] *= n, this
                },
                getMaxScaleOnAxis: function() {
                    var e = this.elements,
                        t = e[0] * e[0] + e[1] * e[1] + e[2] * e[2],
                        i = e[4] * e[4] + e[5] * e[5] + e[6] * e[6],
                        r = e[8] * e[8] + e[9] * e[9] + e[10] * e[10];
                    return Math.sqrt(Math.max(t, i, r))
                },
                makeTranslation: function(e, t, i) {
                    return this.set(1, 0, 0, e, 0, 1, 0, t, 0, 0, 1, i, 0, 0, 0, 1), this
                },
                makeRotationX: function(e) {
                    var t = Math.cos(e),
                        i = Math.sin(e);
                    return this.set(1, 0, 0, 0, 0, t, -i, 0, 0, i, t, 0, 0, 0, 0, 1), this
                },
                makeRotationY: function(e) {
                    var t = Math.cos(e),
                        i = Math.sin(e);
                    return this.set(t, 0, i, 0, 0, 1, 0, 0, -i, 0, t, 0, 0, 0, 0, 1), this
                },
                makeRotationZ: function(e) {
                    var t = Math.cos(e),
                        i = Math.sin(e);
                    return this.set(t, -i, 0, 0, i, t, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1), this
                },
                makeRotationAxis: function(e, t) {
                    var i = Math.cos(t),
                        r = Math.sin(t),
                        n = 1 - i,
                        o = e.x,
                        a = e.y,
                        s = e.z,
                        l = n * o,
                        c = n * a;
                    return this.set(l * o + i, l * a - r * s, l * s + r * a, 0, l * a + r * s, c * a + i, c * s - r * o, 0, l * s - r * a, c * s + r * o, n * s * s + i, 0, 0, 0, 0, 1), this
                },
                makeScale: function(e, t, i) {
                    return this.set(e, 0, 0, 0, 0, t, 0, 0, 0, 0, i, 0, 0, 0, 0, 1), this
                },
                compose: function(e, t, i) {
                    return this.makeRotationFromQuaternion(t), this.scale(i), this.setPosition(e), this
                },
                decompose: function() {
                    var e, t;
                    return function(i, n, o) {
                        void 0 === e && (e = new r.Vector3), void 0 === t && (t = new r.Matrix4);
                        var a = this.elements,
                            s = e.set(a[0], a[1], a[2]).length(),
                            l = e.set(a[4], a[5], a[6]).length(),
                            c = e.set(a[8], a[9], a[10]).length(),
                            h = this.determinant();
                        0 > h && (s = -s), i.x = a[12], i.y = a[13], i.z = a[14], t.elements.set(this.elements);
                        var u = 1 / s,
                            p = 1 / l,
                            f = 1 / c;
                        return t.elements[0] *= u, t.elements[1] *= u, t.elements[2] *= u, t.elements[4] *= p, t.elements[5] *= p, t.elements[6] *= p, t.elements[8] *= f, t.elements[9] *= f, t.elements[10] *= f, n.setFromRotationMatrix(t), o.x = s, o.y = l, o.z = c, this
                    }
                }(),
                makeFrustum: function(e, t, i, r, n, o) {
                    var a = this.elements,
                        s = 2 * n / (t - e),
                        l = 2 * n / (r - i),
                        c = (t + e) / (t - e),
                        h = (r + i) / (r - i),
                        u = -(o + n) / (o - n),
                        p = -2 * o * n / (o - n);
                    return a[0] = s, a[4] = 0, a[8] = c, a[12] = 0, a[1] = 0, a[5] = l, a[9] = h, a[13] = 0, a[2] = 0, a[6] = 0, a[10] = u, a[14] = p, a[3] = 0, a[7] = 0, a[11] = -1, a[15] = 0, this
                },
                makePerspective: function(e, t, i, n) {
                    var o = i * Math.tan(r.Math.degToRad(.5 * e)),
                        a = -o,
                        s = a * t,
                        l = o * t;
                    return this.makeFrustum(s, l, a, o, i, n)
                },
                makeOrthographic: function(e, t, i, r, n, o) {
                    var a = this.elements,
                        s = 1 / (t - e),
                        l = 1 / (i - r),
                        c = 1 / (o - n),
                        h = (t + e) * s,
                        u = (i + r) * l,
                        p = (o + n) * c;
                    return a[0] = 2 * s, a[4] = 0, a[8] = 0, a[12] = -h, a[1] = 0, a[5] = 2 * l, a[9] = 0, a[13] = -u, a[2] = 0, a[6] = 0, a[10] = -2 * c, a[14] = -p, a[3] = 0, a[7] = 0, a[11] = 0, a[15] = 1, this
                },
                equals: function(e) {
                    for (var t = this.elements, i = e.elements, r = 0; 16 > r; r++)
                        if (t[r] !== i[r]) return !1;
                    return !0
                },
                fromArray: function(e) {
                    return this.elements.set(e), this
                },
                toArray: function() {
                    var e = this.elements;
                    return [e[0], e[1], e[2], e[3], e[4], e[5], e[6], e[7], e[8], e[9], e[10], e[11], e[12], e[13], e[14], e[15]]
                }
            }, r.Ray = function(e, t) {
                this.origin = void 0 !== e ? e : new r.Vector3, this.direction = void 0 !== t ? t : new r.Vector3
            }, r.Ray.prototype = {
                constructor: r.Ray,
                set: function(e, t) {
                    return this.origin.copy(e), this.direction.copy(t), this
                },
                clone: function() {
                    return (new this.constructor).copy(this)
                },
                copy: function(e) {
                    return this.origin.copy(e.origin), this.direction.copy(e.direction), this
                },
                at: function(e, t) {
                    var i = t || new r.Vector3;
                    return i.copy(this.direction).multiplyScalar(e).add(this.origin)
                },
                lookAt: function(e) {
                    this.direction.copy(e).sub(this.origin).normalize()
                },
                recast: function() {
                    var e = new r.Vector3;
                    return function(t) {
                        return this.origin.copy(this.at(t, e)), this
                    }
                }(),
                closestPointToPoint: function(e, t) {
                    var i = t || new r.Vector3;
                    i.subVectors(e, this.origin);
                    var n = i.dot(this.direction);
                    return 0 > n ? i.copy(this.origin) : i.copy(this.direction).multiplyScalar(n).add(this.origin)
                },
                distanceToPoint: function(e) {
                    return Math.sqrt(this.distanceSqToPoint(e))
                },
                distanceSqToPoint: function() {
                    var e = new r.Vector3;
                    return function(t) {
                        var i = e.subVectors(t, this.origin).dot(this.direction);
                        return 0 > i ? this.origin.distanceToSquared(t) : (e.copy(this.direction).multiplyScalar(i).add(this.origin), e.distanceToSquared(t))
                    }
                }(),
                distanceSqToSegment: function() {
                    var e = new r.Vector3,
                        t = new r.Vector3,
                        i = new r.Vector3;
                    return function(r, n, o, a) {
                        e.copy(r).add(n).multiplyScalar(.5), t.copy(n).sub(r).normalize(), i.copy(this.origin).sub(e);
                        var s, l, c, h, u = .5 * r.distanceTo(n),
                            p = -this.direction.dot(t),
                            f = i.dot(this.direction),
                            d = -i.dot(t),
                            m = i.lengthSq(),
                            g = Math.abs(1 - p * p);
                        if (g > 0)
                            if (s = p * d - f, l = p * f - d, h = u * g, s >= 0)
                                if (l >= -h)
                                    if (h >= l) {
                                        var v = 1 / g;
                                        s *= v, l *= v, c = s * (s + p * l + 2 * f) + l * (p * s + l + 2 * d) + m
                                    } else l = u, s = Math.max(0, -(p * l + f)), c = -s * s + l * (l + 2 * d) + m;
                        else l = -u, s = Math.max(0, -(p * l + f)), c = -s * s + l * (l + 2 * d) + m;
                        else -h >= l ? (s = Math.max(0, -(-p * u + f)), l = s > 0 ? -u : Math.min(Math.max(-u, -d), u), c = -s * s + l * (l + 2 * d) + m) : h >= l ? (s = 0, l = Math.min(Math.max(-u, -d), u), c = l * (l + 2 * d) + m) : (s = Math.max(0, -(p * u + f)), l = s > 0 ? u : Math.min(Math.max(-u, -d), u), c = -s * s + l * (l + 2 * d) + m);
                        else l = p > 0 ? -u : u, s = Math.max(0, -(p * l + f)), c = -s * s + l * (l + 2 * d) + m;
                        return o && o.copy(this.direction).multiplyScalar(s).add(this.origin), a && a.copy(t).multiplyScalar(l).add(e), c
                    }
                }(),
                intersectSphere: function() {
                    var e = new r.Vector3;
                    return function(t, i) {
                        e.subVectors(t.center, this.origin);
                        var r = e.dot(this.direction),
                            n = e.dot(e) - r * r,
                            o = t.radius * t.radius;
                        if (n > o) return null;
                        var a = Math.sqrt(o - n),
                            s = r - a,
                            l = r + a;
                        return 0 > s && 0 > l ? null : 0 > s ? this.at(l, i) : this.at(s, i)
                    }
                }(),
                intersectsSphere: function(e) {
                    return this.distanceToPoint(e.center) <= e.radius
                },
                distanceToPlane: function(e) {
                    var t = e.normal.dot(this.direction);
                    if (0 === t) return 0 === e.distanceToPoint(this.origin) ? 0 : null;
                    var i = -(this.origin.dot(e.normal) + e.constant) / t;
                    return i >= 0 ? i : null
                },
                intersectPlane: function(e, t) {
                    var i = this.distanceToPlane(e);
                    return null === i ? null : this.at(i, t)
                },
                intersectsPlane: function(e) {
                    var t = e.distanceToPoint(this.origin);
                    if (0 === t) return !0;
                    var i = e.normal.dot(this.direction);
                    return 0 > i * t
                },
                intersectBox: function(e, t) {
                    var i, r, n, o, a, s, l = 1 / this.direction.x,
                        c = 1 / this.direction.y,
                        h = 1 / this.direction.z,
                        u = this.origin;
                    return l >= 0 ? (i = (e.min.x - u.x) * l, r = (e.max.x - u.x) * l) : (i = (e.max.x - u.x) * l, r = (e.min.x - u.x) * l), c >= 0 ? (n = (e.min.y - u.y) * c, o = (e.max.y - u.y) * c) : (n = (e.max.y - u.y) * c, o = (e.min.y - u.y) * c), i > o || n > r ? null : ((n > i || i !== i) && (i = n), (r > o || r !== r) && (r = o), h >= 0 ? (a = (e.min.z - u.z) * h, s = (e.max.z - u.z) * h) : (a = (e.max.z - u.z) * h, s = (e.min.z - u.z) * h), i > s || a > r ? null : ((a > i || i !== i) && (i = a), (r > s || r !== r) && (r = s), 0 > r ? null : this.at(i >= 0 ? i : r, t)))
                },
                intersectsBox: function() {
                    var e = new r.Vector3;
                    return function(t) {
                        return null !== this.intersectBox(t, e)
                    }
                }(),
                intersectTriangle: function() {
                    var e = new r.Vector3,
                        t = new r.Vector3,
                        i = new r.Vector3,
                        n = new r.Vector3;
                    return function(r, o, a, s, l) {
                        t.subVectors(o, r), i.subVectors(a, r), n.crossVectors(t, i);
                        var c, h = this.direction.dot(n);
                        if (h > 0) {
                            if (s) return null;
                            c = 1
                        } else {
                            if (!(0 > h)) return null;
                            c = -1, h = -h
                        }
                        e.subVectors(this.origin, r);
                        var u = c * this.direction.dot(i.crossVectors(e, i));
                        if (0 > u) return null;
                        var p = c * this.direction.dot(t.cross(e));
                        if (0 > p) return null;
                        if (u + p > h) return null;
                        var f = -c * e.dot(n);
                        return 0 > f ? null : this.at(f / h, l)
                    }
                }(),
                applyMatrix4: function(e) {
                    return this.direction.add(this.origin).applyMatrix4(e), this.origin.applyMatrix4(e), this.direction.sub(this.origin), this.direction.normalize(), this
                },
                equals: function(e) {
                    return e.origin.equals(this.origin) && e.direction.equals(this.direction)
                }
            }, r.Sphere = function(e, t) {
                this.center = void 0 !== e ? e : new r.Vector3, this.radius = void 0 !== t ? t : 0
            }, r.Sphere.prototype = {
                constructor: r.Sphere,
                set: function(e, t) {
                    return this.center.copy(e), this.radius = t, this
                },
                setFromPoints: function() {
                    var e = new r.Box3;
                    return function(t, i) {
                        var r = this.center;
                        void 0 !== i ? r.copy(i) : e.setFromPoints(t).center(r);
                        for (var n = 0, o = 0, a = t.length; a > o; o++) n = Math.max(n, r.distanceToSquared(t[o]));
                        return this.radius = Math.sqrt(n), this
                    }
                }(),
                clone: function() {
                    return (new this.constructor).copy(this)
                },
                copy: function(e) {
                    return this.center.copy(e.center), this.radius = e.radius, this
                },
                empty: function() {
                    return this.radius <= 0
                },
                containsPoint: function(e) {
                    return e.distanceToSquared(this.center) <= this.radius * this.radius
                },
                distanceToPoint: function(e) {
                    return e.distanceTo(this.center) - this.radius
                },
                intersectsSphere: function(e) {
                    var t = this.radius + e.radius;
                    return e.center.distanceToSquared(this.center) <= t * t
                },
                intersectsBox: function(e) {
                    return e.intersectsSphere(this)
                },
                intersectsPlane: function(e) {
                    return Math.abs(this.center.dot(e.normal) - e.constant) <= this.radius
                },
                clampPoint: function(e, t) {
                    var i = this.center.distanceToSquared(e),
                        n = t || new r.Vector3;
                    return n.copy(e), i > this.radius * this.radius && (n.sub(this.center).normalize(), n.multiplyScalar(this.radius).add(this.center)), n
                },
                getBoundingBox: function(e) {
                    var t = e || new r.Box3;
                    return t.set(this.center, this.center), t.expandByScalar(this.radius), t
                },
                applyMatrix4: function(e) {
                    return this.center.applyMatrix4(e), this.radius = this.radius * e.getMaxScaleOnAxis(), this
                },
                translate: function(e) {
                    return this.center.add(e), this
                },
                equals: function(e) {
                    return e.center.equals(this.center) && e.radius === this.radius
                }
            }, r.Frustum = function(e, t, i, n, o, a) {
                this.planes = [void 0 !== e ? e : new r.Plane, void 0 !== t ? t : new r.Plane, void 0 !== i ? i : new r.Plane, void 0 !== n ? n : new r.Plane, void 0 !== o ? o : new r.Plane, void 0 !== a ? a : new r.Plane]
            }, r.Frustum.prototype = {
                constructor: r.Frustum,
                set: function(e, t, i, r, n, o) {
                    var a = this.planes;
                    return a[0].copy(e), a[1].copy(t), a[2].copy(i), a[3].copy(r), a[4].copy(n), a[5].copy(o), this
                },
                clone: function() {
                    return (new this.constructor).copy(this)
                },
                copy: function(e) {
                    for (var t = this.planes, i = 0; 6 > i; i++) t[i].copy(e.planes[i]);
                    return this
                },
                setFromMatrix: function(e) {
                    var t = this.planes,
                        i = e.elements,
                        r = i[0],
                        n = i[1],
                        o = i[2],
                        a = i[3],
                        s = i[4],
                        l = i[5],
                        c = i[6],
                        h = i[7],
                        u = i[8],
                        p = i[9],
                        f = i[10],
                        d = i[11],
                        m = i[12],
                        g = i[13],
                        v = i[14],
                        y = i[15];
                    return t[0].setComponents(a - r, h - s, d - u, y - m).normalize(), t[1].setComponents(a + r, h + s, d + u, y + m).normalize(), t[2].setComponents(a + n, h + l, d + p, y + g).normalize(), t[3].setComponents(a - n, h - l, d - p, y - g).normalize(), t[4].setComponents(a - o, h - c, d - f, y - v).normalize(), t[5].setComponents(a + o, h + c, d + f, y + v).normalize(), this
                },
                intersectsObject: function() {
                    var e = new r.Sphere;
                    return function(t) {
                        var i = t.geometry;
                        return null === i.boundingSphere && i.computeBoundingSphere(), e.copy(i.boundingSphere), e.applyMatrix4(t.matrixWorld), this.intersectsSphere(e)
                    }
                }(),
                intersectsSphere: function(e) {
                    for (var t = this.planes, i = e.center, r = -e.radius, n = 0; 6 > n; n++) {
                        var o = t[n].distanceToPoint(i);
                        if (r > o) return !1
                    }
                    return !0
                },
                intersectsBox: function() {
                    var e = new r.Vector3,
                        t = new r.Vector3;
                    return function(i) {
                        for (var r = this.planes, n = 0; 6 > n; n++) {
                            var o = r[n];
                            e.x = o.normal.x > 0 ? i.min.x : i.max.x, t.x = o.normal.x > 0 ? i.max.x : i.min.x, e.y = o.normal.y > 0 ? i.min.y : i.max.y, t.y = o.normal.y > 0 ? i.max.y : i.min.y, e.z = o.normal.z > 0 ? i.min.z : i.max.z, t.z = o.normal.z > 0 ? i.max.z : i.min.z;
                            var a = o.distanceToPoint(e),
                                s = o.distanceToPoint(t);
                            if (0 > a && 0 > s) return !1
                        }
                        return !0
                    }
                }(),
                containsPoint: function(e) {
                    for (var t = this.planes, i = 0; 6 > i; i++)
                        if (t[i].distanceToPoint(e) < 0) return !1;
                    return !0
                }
            }, r.Plane = function(e, t) {
                this.normal = void 0 !== e ? e : new r.Vector3(1, 0, 0), this.constant = void 0 !== t ? t : 0
            }, r.Plane.prototype = {
                constructor: r.Plane,
                set: function(e, t) {
                    return this.normal.copy(e), this.constant = t, this
                },
                setComponents: function(e, t, i, r) {
                    return this.normal.set(e, t, i), this.constant = r, this
                },
                setFromNormalAndCoplanarPoint: function(e, t) {
                    return this.normal.copy(e), this.constant = -t.dot(this.normal), this
                },
                setFromCoplanarPoints: function() {
                    var e = new r.Vector3,
                        t = new r.Vector3;
                    return function(i, r, n) {
                        var o = e.subVectors(n, r).cross(t.subVectors(i, r)).normalize();
                        return this.setFromNormalAndCoplanarPoint(o, i), this
                    }
                }(),
                clone: function() {
                    return (new this.constructor).copy(this)
                },
                copy: function(e) {
                    return this.normal.copy(e.normal), this.constant = e.constant, this
                },
                normalize: function() {
                    var e = 1 / this.normal.length();
                    return this.normal.multiplyScalar(e), this.constant *= e, this
                },
                negate: function() {
                    return this.constant *= -1, this.normal.negate(), this
                },
                distanceToPoint: function(e) {
                    return this.normal.dot(e) + this.constant
                },
                distanceToSphere: function(e) {
                    return this.distanceToPoint(e.center) - e.radius
                },
                projectPoint: function(e, t) {
                    return this.orthoPoint(e, t).sub(e).negate()
                },
                orthoPoint: function(e, t) {
                    var i = this.distanceToPoint(e),
                        n = t || new r.Vector3;
                    return n.copy(this.normal).multiplyScalar(i)
                },
                intersectLine: function() {
                    var e = new r.Vector3;
                    return function(t, i) {
                        var n = i || new r.Vector3,
                            o = t.delta(e),
                            a = this.normal.dot(o);
                        if (0 !== a) {
                            var s = -(t.start.dot(this.normal) + this.constant) / a;
                            if (!(0 > s || s > 1)) return n.copy(o).multiplyScalar(s).add(t.start)
                        } else if (0 === this.distanceToPoint(t.start)) return n.copy(t.start)
                    }
                }(),
                intersectsLine: function(e) {
                    var t = this.distanceToPoint(e.start),
                        i = this.distanceToPoint(e.end);
                    return 0 > t && i > 0 || 0 > i && t > 0
                },
                intersectsBox: function(e) {
                    return e.intersectsPlane(this)
                },
                intersectsSphere: function(e) {
                    return e.intersectsPlane(this)
                },
                coplanarPoint: function(e) {
                    var t = e || new r.Vector3;
                    return t.copy(this.normal).multiplyScalar(-this.constant)
                },
                applyMatrix4: function() {
                    var e = new r.Vector3,
                        t = new r.Vector3,
                        i = new r.Matrix3;
                    return function(r, n) {
                        var o = n || i.getNormalMatrix(r),
                            a = e.copy(this.normal).applyMatrix3(o),
                            s = this.coplanarPoint(t);
                        return s.applyMatrix4(r), this.setFromNormalAndCoplanarPoint(a, s), this
                    }
                }(),
                translate: function(e) {
                    return this.constant = this.constant - e.dot(this.normal), this
                },
                equals: function(e) {
                    return e.normal.equals(this.normal) && e.constant === this.constant
                }
            }, r.Spherical = function(e, t, i) {
                return this.radius = void 0 !== e ? e : 1, this.phi = void 0 !== t ? t : 0, this.theta = void 0 !== i ? i : 0, this
            }, r.Spherical.prototype = {
                constructor: r.Spherical,
                set: function(e, t, i) {
                    this.radius = e, this.phi = t, this.theta = i
                },
                clone: function() {
                    return (new this.constructor).copy(this)
                },
                copy: function(e) {
                    return this.radius.copy(e.radius), this.phi.copy(e.phi), this.theta.copy(e.theta), this
                },
                makeSafe: function() {
                    var e = 1e-6;
                    this.phi = Math.max(e, Math.min(Math.PI - e, this.phi))
                },
                setFromVector3: function(e) {
                    return this.radius = e.length(), 0 === this.radius ? (this.theta = 0, this.phi = 0) : (this.theta = Math.atan2(e.x, e.z), this.phi = Math.acos(r.Math.clamp(e.y / this.radius, -1, 1))), this
                }
            }, r.Math = {
                generateUUID: function() {
                    var e, t = "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz".split(""),
                        i = new Array(36),
                        r = 0;
                    return function() {
                        for (var n = 0; 36 > n; n++) 8 === n || 13 === n || 18 === n || 23 === n ? i[n] = "-" : 14 === n ? i[n] = "4" : (2 >= r && (r = 33554432 + 16777216 * Math.random() | 0), e = 15 & r, r >>= 4, i[n] = t[19 === n ? 3 & e | 8 : e]);
                        return i.join("")
                    }
                }(),
                clamp: function(e, t, i) {
                    return Math.max(t, Math.min(i, e))
                },
                euclideanModulo: function(e, t) {
                    return (e % t + t) % t
                },
                mapLinear: function(e, t, i, r, n) {
                    return r + (e - t) * (n - r) / (i - t)
                },
                smoothstep: function(e, t, i) {
                    return t >= e ? 0 : e >= i ? 1 : (e = (e - t) / (i - t), e * e * (3 - 2 * e))
                },
                smootherstep: function(e, t, i) {
                    return t >= e ? 0 : e >= i ? 1 : (e = (e - t) / (i - t), e * e * e * (e * (6 * e - 15) + 10))
                },
                random16: function() {
                    return console.warn("THREE.Math.random16() has been deprecated. Use Math.random() instead."), Math.random()
                },
                randInt: function(e, t) {
                    return e + Math.floor(Math.random() * (t - e + 1))
                },
                randFloat: function(e, t) {
                    return e + Math.random() * (t - e)
                },
                randFloatSpread: function(e) {
                    return e * (.5 - Math.random())
                },
                degToRad: function() {
                    var e = Math.PI / 180;
                    return function(t) {
                        return t * e
                    }
                }(),
                radToDeg: function() {
                    var e = 180 / Math.PI;
                    return function(t) {
                        return t * e
                    }
                }(),
                isPowerOfTwo: function(e) {
                    return 0 === (e & e - 1) && 0 !== e
                },
                nearestPowerOfTwo: function(e) {
                    return Math.pow(2, Math.round(Math.log(e) / Math.LN2))
                },
                nextPowerOfTwo: function(e) {
                    return e--, e |= e >> 1, e |= e >> 2, e |= e >> 4, e |= e >> 8, e |= e >> 16, e++, e
                }
            }, r.Spline = function(e) {
                function t(e, t, i, r, n, o, a) {
                    var s = .5 * (i - e),
                        l = .5 * (r - t);
                    return (2 * (t - i) + s + l) * a + (-3 * (t - i) - 2 * s - l) * o + s * n + t
                }
                this.points = e;
                var i, n, o, a, s, l, c, h, u, p = [],
                    f = {
                        x: 0,
                        y: 0,
                        z: 0
                    };
                this.initFromArray = function(e) {
                    this.points = [];
                    for (var t = 0; t < e.length; t++) this.points[t] = {
                        x: e[t][0],
                        y: e[t][1],
                        z: e[t][2]
                    }
                }, this.getPoint = function(e) {
                    return i = (this.points.length - 1) * e, n = Math.floor(i), o = i - n, p[0] = 0 === n ? n : n - 1, p[1] = n, p[2] = n > this.points.length - 2 ? this.points.length - 1 : n + 1, p[3] = n > this.points.length - 3 ? this.points.length - 1 : n + 2, l = this.points[p[0]], c = this.points[p[1]], h = this.points[p[2]], u = this.points[p[3]], a = o * o, s = o * a, f.x = t(l.x, c.x, h.x, u.x, o, a, s), f.y = t(l.y, c.y, h.y, u.y, o, a, s), f.z = t(l.z, c.z, h.z, u.z, o, a, s), f
                }, this.getControlPointsArray = function() {
                    var e, t, i = this.points.length,
                        r = [];
                    for (e = 0; i > e; e++) t = this.points[e], r[e] = [t.x, t.y, t.z];
                    return r
                }, this.getLength = function(e) {
                    var t, i, n, o, a = 0,
                        s = 0,
                        l = 0,
                        c = new r.Vector3,
                        h = new r.Vector3,
                        u = [],
                        p = 0;
                    for (u[0] = 0, e || (e = 100), n = this.points.length * e, c.copy(this.points[0]), t = 1; n > t; t++) i = t / n, o = this.getPoint(i), h.copy(o), p += h.distanceTo(c), c.copy(o), a = (this.points.length - 1) * i, s = Math.floor(a), s !== l && (u[s] = p, l = s);
                    return u[u.length] = p, {
                        chunks: u,
                        total: p
                    }
                }, this.reparametrizeByArcLength = function(e) {
                    var t, i, n, o, a, s, l, c, h = [],
                        u = new r.Vector3,
                        p = this.getLength();
                    for (h.push(u.copy(this.points[0]).clone()), t = 1; t < this.points.length; t++) {
                        for (s = p.chunks[t] - p.chunks[t - 1], l = Math.ceil(e * s / p.total), o = (t - 1) / (this.points.length - 1), a = t / (this.points.length - 1), i = 1; l - 1 > i; i++) n = o + i * (1 / l) * (a - o), c = this.getPoint(n), h.push(u.copy(c).clone());
                        h.push(u.copy(this.points[t]).clone())
                    }
                    this.points = h
                }
            }, r.Triangle = function(e, t, i) {
                this.a = void 0 !== e ? e : new r.Vector3, this.b = void 0 !== t ? t : new r.Vector3, this.c = void 0 !== i ? i : new r.Vector3
            }, r.Triangle.normal = function() {
                var e = new r.Vector3;
                return function(t, i, n, o) {
                    var a = o || new r.Vector3;
                    a.subVectors(n, i), e.subVectors(t, i), a.cross(e);
                    var s = a.lengthSq();
                    return s > 0 ? a.multiplyScalar(1 / Math.sqrt(s)) : a.set(0, 0, 0)
                }
            }(), r.Triangle.barycoordFromPoint = function() {
                var e = new r.Vector3,
                    t = new r.Vector3,
                    i = new r.Vector3;
                return function(n, o, a, s, l) {
                    e.subVectors(s, o), t.subVectors(a, o), i.subVectors(n, o);
                    var c = e.dot(e),
                        h = e.dot(t),
                        u = e.dot(i),
                        p = t.dot(t),
                        f = t.dot(i),
                        d = c * p - h * h,
                        m = l || new r.Vector3;
                    if (0 === d) return m.set(-2, -1, -1);
                    var g = 1 / d,
                        v = (p * u - h * f) * g,
                        y = (c * f - h * u) * g;
                    return m.set(1 - v - y, y, v)
                }
            }(), r.Triangle.containsPoint = function() {
                var e = new r.Vector3;
                return function(t, i, n, o) {
                    var a = r.Triangle.barycoordFromPoint(t, i, n, o, e);
                    return a.x >= 0 && a.y >= 0 && a.x + a.y <= 1
                }
            }(), r.Triangle.prototype = {
                constructor: r.Triangle,
                set: function(e, t, i) {
                    return this.a.copy(e), this.b.copy(t), this.c.copy(i), this
                },
                setFromPointsAndIndices: function(e, t, i, r) {
                    return this.a.copy(e[t]), this.b.copy(e[i]), this.c.copy(e[r]), this
                },
                clone: function() {
                    return (new this.constructor).copy(this)
                },
                copy: function(e) {
                    return this.a.copy(e.a), this.b.copy(e.b), this.c.copy(e.c), this
                },
                area: function() {
                    var e = new r.Vector3,
                        t = new r.Vector3;
                    return function() {
                        return e.subVectors(this.c, this.b), t.subVectors(this.a, this.b), .5 * e.cross(t).length()
                    }
                }(),
                midpoint: function(e) {
                    var t = e || new r.Vector3;
                    return t.addVectors(this.a, this.b).add(this.c).multiplyScalar(1 / 3)
                },
                normal: function(e) {
                    return r.Triangle.normal(this.a, this.b, this.c, e)
                },
                plane: function(e) {
                    var t = e || new r.Plane;
                    return t.setFromCoplanarPoints(this.a, this.b, this.c)
                },
                barycoordFromPoint: function(e, t) {
                    return r.Triangle.barycoordFromPoint(e, this.a, this.b, this.c, t)
                },
                containsPoint: function(e) {
                    return r.Triangle.containsPoint(e, this.a, this.b, this.c)
                },
                equals: function(e) {
                    return e.a.equals(this.a) && e.b.equals(this.b) && e.c.equals(this.c)
                }
            }, r.Interpolant = function(e, t, i, r) {
                this.parameterPositions = e, this._cachedIndex = 0, this.resultBuffer = void 0 !== r ? r : new t.constructor(i), this.sampleValues = t, this.valueSize = i
            }, r.Interpolant.prototype = {
                constructor: r.Interpolant,
                evaluate: function(e) {
                    var t = this.parameterPositions,
                        i = this._cachedIndex,
                        r = t[i],
                        n = t[i - 1];
                    e: {
                        t: {
                            var o;
                            i: {
                                r: if (!(r > e)) {
                                    for (var a = i + 2;;) {
                                        if (void 0 === r) {
                                            if (n > e) break r;
                                            return i = t.length, this._cachedIndex = i, this.afterEnd_(i - 1, e, n)
                                        }
                                        if (i === a) break;
                                        if (n = r, r = t[++i], r > e) break t
                                    }
                                    o = t.length;
                                    break i
                                } {
                                    if (e >= n) break e;
                                    var s = t[1];
                                    s > e && (i = 2, n = s);
                                    for (var a = i - 2;;) {
                                        if (void 0 === n) return this._cachedIndex = 0, this.beforeStart_(0, e, r);
                                        if (i === a) break;
                                        if (r = n, n = t[--i - 1], e >= n) break t
                                    }
                                    o = i, i = 0
                                }
                            }
                            for (; o > i;) {
                                var l = i + o >>> 1;
                                e < t[l] ? o = l : i = l + 1
                            }
                            if (r = t[i], n = t[i - 1], void 0 === n) return this._cachedIndex = 0, this.beforeStart_(0, e, r);
                            if (void 0 === r) return i = t.length, this._cachedIndex = i, this.afterEnd_(i - 1, n, e)
                        }
                        this._cachedIndex = i,
                        this.intervalChanged_(i, n, r)
                    }
                    return this.interpolate_(i, n, e, r)
                },
                settings: null,
                DefaultSettings_: {},
                getSettings_: function() {
                    return this.settings || this.DefaultSettings_
                },
                copySampleValue_: function(e) {
                    for (var t = this.resultBuffer, i = this.sampleValues, r = this.valueSize, n = e * r, o = 0; o !== r; ++o) t[o] = i[n + o];
                    return t
                },
                interpolate_: function(e, t, i, r) {
                    throw new Error("call to abstract method")
                },
                intervalChanged_: function(e, t, i) {}
            }, Object.assign(r.Interpolant.prototype, {
                beforeStart_: r.Interpolant.prototype.copySampleValue_,
                afterEnd_: r.Interpolant.prototype.copySampleValue_
            }), r.CubicInterpolant = function(e, t, i, n) {
                r.Interpolant.call(this, e, t, i, n), this._weightPrev = -0, this._offsetPrev = -0, this._weightNext = -0, this._offsetNext = -0
            }, r.CubicInterpolant.prototype = Object.assign(Object.create(r.Interpolant.prototype), {
                constructor: r.CubicInterpolant,
                DefaultSettings_: {
                    endingStart: r.ZeroCurvatureEnding,
                    endingEnd: r.ZeroCurvatureEnding
                },
                intervalChanged_: function(e, t, i) {
                    var n = this.parameterPositions,
                        o = e - 2,
                        a = e + 1,
                        s = n[o],
                        l = n[a];
                    if (void 0 === s) switch (this.getSettings_().endingStart) {
                        case r.ZeroSlopeEnding:
                            o = e, s = 2 * t - i;
                            break;
                        case r.WrapAroundEnding:
                            o = n.length - 2, s = t + n[o] - n[o + 1];
                            break;
                        default:
                            o = e, s = i
                    }
                    if (void 0 === l) switch (this.getSettings_().endingEnd) {
                        case r.ZeroSlopeEnding:
                            a = e, l = 2 * i - t;
                            break;
                        case r.WrapAroundEnding:
                            a = 1, l = i + n[1] - n[0];
                            break;
                        default:
                            a = e - 1, l = t
                    }
                    var c = .5 * (i - t),
                        h = this.valueSize;
                    this._weightPrev = c / (t - s), this._weightNext = c / (l - i), this._offsetPrev = o * h, this._offsetNext = a * h
                },
                interpolate_: function(e, t, i, r) {
                    for (var n = this.resultBuffer, o = this.sampleValues, a = this.valueSize, s = e * a, l = s - a, c = this._offsetPrev, h = this._offsetNext, u = this._weightPrev, p = this._weightNext, f = (i - t) / (r - t), d = f * f, m = d * f, g = -u * m + 2 * u * d - u * f, v = (1 + u) * m + (-1.5 - 2 * u) * d + (-.5 + u) * f + 1, y = (-1 - p) * m + (1.5 + p) * d + .5 * f, _ = p * m - p * d, x = 0; x !== a; ++x) n[x] = g * o[c + x] + v * o[l + x] + y * o[s + x] + _ * o[h + x];
                    return n
                }
            }), r.DiscreteInterpolant = function(e, t, i, n) {
                r.Interpolant.call(this, e, t, i, n)
            }, r.DiscreteInterpolant.prototype = Object.assign(Object.create(r.Interpolant.prototype), {
                constructor: r.DiscreteInterpolant,
                interpolate_: function(e, t, i, r) {
                    return this.copySampleValue_(e - 1)
                }
            }), r.LinearInterpolant = function(e, t, i, n) {
                r.Interpolant.call(this, e, t, i, n)
            }, r.LinearInterpolant.prototype = Object.assign(Object.create(r.Interpolant.prototype), {
                constructor: r.LinearInterpolant,
                interpolate_: function(e, t, i, r) {
                    for (var n = this.resultBuffer, o = this.sampleValues, a = this.valueSize, s = e * a, l = s - a, c = (i - t) / (r - t), h = 1 - c, u = 0; u !== a; ++u) n[u] = o[l + u] * h + o[s + u] * c;
                    return n
                }
            }), r.QuaternionLinearInterpolant = function(e, t, i, n) {
                r.Interpolant.call(this, e, t, i, n)
            }, r.QuaternionLinearInterpolant.prototype = Object.assign(Object.create(r.Interpolant.prototype), {
                constructor: r.QuaternionLinearInterpolant,
                interpolate_: function(e, t, i, n) {
                    for (var o = this.resultBuffer, a = this.sampleValues, s = this.valueSize, l = e * s, c = (i - t) / (n - t), h = l + s; l !== h; l += 4) r.Quaternion.slerpFlat(o, 0, a, l - s, a, l, c);
                    return o
                }
            }), r.Clock = function(e) {
                this.autoStart = void 0 !== e ? e : !0, this.startTime = 0, this.oldTime = 0, this.elapsedTime = 0, this.running = !1
            }, r.Clock.prototype = {
                constructor: r.Clock,
                start: function() {
                    this.startTime = performance.now(), this.oldTime = this.startTime, this.running = !0
                },
                stop: function() {
                    this.getElapsedTime(), this.running = !1
                },
                getElapsedTime: function() {
                    return this.getDelta(), this.elapsedTime
                },
                getDelta: function() {
                    var e = 0;
                    if (this.autoStart && !this.running && this.start(), this.running) {
                        var t = performance.now();
                        e = .001 * (t - this.oldTime), this.oldTime = t, this.elapsedTime += e
                    }
                    return e
                }
            }, r.EventDispatcher = function() {}, r.EventDispatcher.prototype = {
                constructor: r.EventDispatcher,
                apply: function(e) {
                    e.addEventListener = r.EventDispatcher.prototype.addEventListener, e.hasEventListener = r.EventDispatcher.prototype.hasEventListener, e.removeEventListener = r.EventDispatcher.prototype.removeEventListener, e.dispatchEvent = r.EventDispatcher.prototype.dispatchEvent
                },
                addEventListener: function(e, t) {
                    void 0 === this._listeners && (this._listeners = {});
                    var i = this._listeners;
                    void 0 === i[e] && (i[e] = []), -1 === i[e].indexOf(t) && i[e].push(t)
                },
                hasEventListener: function(e, t) {
                    if (void 0 === this._listeners) return !1;
                    var i = this._listeners;
                    return void 0 !== i[e] && -1 !== i[e].indexOf(t)
                },
                removeEventListener: function(e, t) {
                    if (void 0 !== this._listeners) {
                        var i = this._listeners,
                            r = i[e];
                        if (void 0 !== r) {
                            var n = r.indexOf(t); - 1 !== n && r.splice(n, 1)
                        }
                    }
                },
                dispatchEvent: function(e) {
                    if (void 0 !== this._listeners) {
                        var t = this._listeners,
                            i = t[e.type];
                        if (void 0 !== i) {
                            e.target = this;
                            for (var r = [], n = i.length, o = 0; n > o; o++) r[o] = i[o];
                            for (var o = 0; n > o; o++) r[o].call(this, e)
                        }
                    }
                }
            }, r.Layers = function() {
                this.mask = 1
            }, r.Layers.prototype = {
                constructor: r.Layers,
                set: function(e) {
                    this.mask = 1 << e
                },
                enable: function(e) {
                    this.mask |= 1 << e
                },
                toggle: function(e) {
                    this.mask ^= 1 << e
                },
                disable: function(e) {
                    this.mask &= ~(1 << e)
                },
                test: function(e) {
                    return 0 !== (this.mask & e.mask)
                }
            },
            function(e) {
                function t(e, t) {
                    return e.distance - t.distance
                }

                function i(e, t, r, n) {
                    if (e.visible !== !1 && (e.raycast(t, r), n === !0))
                        for (var o = e.children, a = 0, s = o.length; s > a; a++) i(o[a], t, r, !0)
                }
                e.Raycaster = function(t, i, r, n) {
                    this.ray = new e.Ray(t, i), this.near = r || 0, this.far = n || 1 / 0, this.params = {
                        Mesh: {},
                        Line: {},
                        LOD: {},
                        Points: {
                            threshold: 1
                        },
                        Sprite: {}
                    }, Object.defineProperties(this.params, {
                        PointCloud: {
                            get: function() {
                                return console.warn("THREE.Raycaster: params.PointCloud has been renamed to params.Points."), this.Points
                            }
                        }
                    })
                }, e.Raycaster.prototype = {
                    constructor: e.Raycaster,
                    linePrecision: 1,
                    set: function(e, t) {
                        this.ray.set(e, t)
                    },
                    setFromCamera: function(t, i) {
                        i instanceof e.PerspectiveCamera ? (this.ray.origin.setFromMatrixPosition(i.matrixWorld), this.ray.direction.set(t.x, t.y, .5).unproject(i).sub(this.ray.origin).normalize()) : i instanceof e.OrthographicCamera ? (this.ray.origin.set(t.x, t.y, -1).unproject(i), this.ray.direction.set(0, 0, -1).transformDirection(i.matrixWorld)) : console.error("THREE.Raycaster: Unsupported camera type.")
                    },
                    intersectObject: function(e, r) {
                        var n = [];
                        return i(e, this, n, r), n.sort(t), n
                    },
                    intersectObjects: function(e, r) {
                        var n = [];
                        if (Array.isArray(e) === !1) return console.warn("THREE.Raycaster.intersectObjects: objects is not an Array."), n;
                        for (var o = 0, a = e.length; a > o; o++) i(e[o], this, n, r);
                        return n.sort(t), n
                    }
                }
            }(r), r.Object3D = function() {
                function e() {
                    o.setFromEuler(n, !1)
                }

                function t() {
                    n.setFromQuaternion(o, void 0, !1)
                }
                Object.defineProperty(this, "id", {
                    value: r.Object3DIdCount++
                }), this.uuid = r.Math.generateUUID(), this.name = "", this.type = "Object3D", this.parent = null, this.children = [], this.up = r.Object3D.DefaultUp.clone();
                var i = new r.Vector3,
                    n = new r.Euler,
                    o = new r.Quaternion,
                    a = new r.Vector3(1, 1, 1);
                n.onChange(e), o.onChange(t), Object.defineProperties(this, {
                    position: {
                        enumerable: !0,
                        value: i
                    },
                    rotation: {
                        enumerable: !0,
                        value: n
                    },
                    quaternion: {
                        enumerable: !0,
                        value: o
                    },
                    scale: {
                        enumerable: !0,
                        value: a
                    },
                    modelViewMatrix: {
                        value: new r.Matrix4
                    },
                    normalMatrix: {
                        value: new r.Matrix3
                    }
                }), this.rotationAutoUpdate = !0, this.matrix = new r.Matrix4, this.matrixWorld = new r.Matrix4, this.matrixAutoUpdate = r.Object3D.DefaultMatrixAutoUpdate, this.matrixWorldNeedsUpdate = !1, this.layers = new r.Layers, this.visible = !0, this.castShadow = !1, this.receiveShadow = !1, this.frustumCulled = !0, this.renderOrder = 0, this.userData = {}
            }, r.Object3D.DefaultUp = new r.Vector3(0, 1, 0),
            r.Object3D.DefaultMatrixAutoUpdate = !0, r.Object3D.prototype = {
                constructor: r.Object3D,
                applyMatrix: function(e) {
                    this.matrix.multiplyMatrices(e, this.matrix), this.matrix.decompose(this.position, this.quaternion, this.scale)
                },
                setRotationFromAxisAngle: function(e, t) {
                    this.quaternion.setFromAxisAngle(e, t)
                },
                setRotationFromEuler: function(e) {
                    this.quaternion.setFromEuler(e, !0)
                },
                setRotationFromMatrix: function(e) {
                    this.quaternion.setFromRotationMatrix(e)
                },
                setRotationFromQuaternion: function(e) {
                    this.quaternion.copy(e)
                },
                rotateOnAxis: function() {
                    var e = new r.Quaternion;
                    return function(t, i) {
                        return e.setFromAxisAngle(t, i), this.quaternion.multiply(e), this
                    }
                }(),
                rotateX: function() {
                    var e = new r.Vector3(1, 0, 0);
                    return function(t) {
                        return this.rotateOnAxis(e, t)
                    }
                }(),
                rotateY: function() {
                    var e = new r.Vector3(0, 1, 0);
                    return function(t) {
                        return this.rotateOnAxis(e, t)
                    }
                }(),
                rotateZ: function() {
                    var e = new r.Vector3(0, 0, 1);
                    return function(t) {
                        return this.rotateOnAxis(e, t)
                    }
                }(),
                translateOnAxis: function() {
                    var e = new r.Vector3;
                    return function(t, i) {
                        return e.copy(t).applyQuaternion(this.quaternion), this.position.add(e.multiplyScalar(i)), this
                    }
                }(),
                translateX: function() {
                    var e = new r.Vector3(1, 0, 0);
                    return function(t) {
                        return this.translateOnAxis(e, t)
                    }
                }(),
                translateY: function() {
                    var e = new r.Vector3(0, 1, 0);
                    return function(t) {
                        return this.translateOnAxis(e, t)
                    }
                }(),
                translateZ: function() {
                    var e = new r.Vector3(0, 0, 1);
                    return function(t) {
                        return this.translateOnAxis(e, t)
                    }
                }(),
                localToWorld: function(e) {
                    return e.applyMatrix4(this.matrixWorld)
                },
                worldToLocal: function() {
                    var e = new r.Matrix4;
                    return function(t) {
                        return t.applyMatrix4(e.getInverse(this.matrixWorld))
                    }
                }(),
                lookAt: function() {
                    var e = new r.Matrix4;
                    return function(t) {
                        e.lookAt(t, this.position, this.up), this.quaternion.setFromRotationMatrix(e)
                    }
                }(),
                add: function(e) {
                    if (arguments.length > 1) {
                        for (var t = 0; t < arguments.length; t++) this.add(arguments[t]);
                        return this
                    }
                    return e === this ? (console.error("THREE.Object3D.add: object can't be added as a child of itself.", e), this) : (e instanceof r.Object3D ? (null !== e.parent && e.parent.remove(e), e.parent = this, e.dispatchEvent({
                        type: "added"
                    }), this.children.push(e)) : console.error("THREE.Object3D.add: object not an instance of THREE.Object3D.", e), this)
                },
                remove: function(e) {
                    if (arguments.length > 1)
                        for (var t = 0; t < arguments.length; t++) this.remove(arguments[t]);
                    var i = this.children.indexOf(e); - 1 !== i && (e.parent = null, e.dispatchEvent({
                        type: "removed"
                    }), this.children.splice(i, 1))
                },
                getObjectById: function(e) {
                    return this.getObjectByProperty("id", e)
                },
                getObjectByName: function(e) {
                    return this.getObjectByProperty("name", e)
                },
                getObjectByProperty: function(e, t) {
                    if (this[e] === t) return this;
                    for (var i = 0, r = this.children.length; r > i; i++) {
                        var n = this.children[i],
                            o = n.getObjectByProperty(e, t);
                        if (void 0 !== o) return o
                    }
                },
                getWorldPosition: function(e) {
                    var t = e || new r.Vector3;
                    return this.updateMatrixWorld(!0), t.setFromMatrixPosition(this.matrixWorld)
                },
                getWorldQuaternion: function() {
                    var e = new r.Vector3,
                        t = new r.Vector3;
                    return function(i) {
                        var n = i || new r.Quaternion;
                        return this.updateMatrixWorld(!0), this.matrixWorld.decompose(e, n, t), n
                    }
                }(),
                getWorldRotation: function() {
                    var e = new r.Quaternion;
                    return function(t) {
                        var i = t || new r.Euler;
                        return this.getWorldQuaternion(e), i.setFromQuaternion(e, this.rotation.order, !1)
                    }
                }(),
                getWorldScale: function() {
                    var e = new r.Vector3,
                        t = new r.Quaternion;
                    return function(i) {
                        var n = i || new r.Vector3;
                        return this.updateMatrixWorld(!0), this.matrixWorld.decompose(e, t, n), n
                    }
                }(),
                getWorldDirection: function() {
                    var e = new r.Quaternion;
                    return function(t) {
                        var i = t || new r.Vector3;
                        return this.getWorldQuaternion(e), i.set(0, 0, 1).applyQuaternion(e)
                    }
                }(),
                raycast: function() {},
                traverse: function(e) {
                    e(this);
                    for (var t = this.children, i = 0, r = t.length; r > i; i++) t[i].traverse(e)
                },
                traverseVisible: function(e) {
                    if (this.visible !== !1) {
                        e(this);
                        for (var t = this.children, i = 0, r = t.length; r > i; i++) t[i].traverseVisible(e)
                    }
                },
                traverseAncestors: function(e) {
                    var t = this.parent;
                    null !== t && (e(t), t.traverseAncestors(e))
                },
                updateMatrix: function() {
                    this.matrix.compose(this.position, this.quaternion, this.scale), this.matrixWorldNeedsUpdate = !0
                },
                updateMatrixWorld: function(e) {
                    this.matrixAutoUpdate === !0 && this.updateMatrix(), this.matrixWorldNeedsUpdate !== !0 && e !== !0 || (null === this.parent ? this.matrixWorld.copy(this.matrix) : this.matrixWorld.multiplyMatrices(this.parent.matrixWorld, this.matrix), this.matrixWorldNeedsUpdate = !1, e = !0);
                    for (var t = 0, i = this.children.length; i > t; t++) this.children[t].updateMatrixWorld(e)
                },
                toJSON: function(e) {
                    function t(e) {
                        var t = [];
                        for (var i in e) {
                            var r = e[i];
                            delete r.metadata, t.push(r)
                        }
                        return t
                    }
                    var i = void 0 === e,
                        r = {};
                    i && (e = {
                        geometries: {},
                        materials: {},
                        textures: {},
                        images: {}
                    }, r.metadata = {
                        version: 4.4,
                        type: "Object",
                        generator: "Object3D.toJSON"
                    });
                    var n = {};
                    if (n.uuid = this.uuid, n.type = this.type, "" !== this.name && (n.name = this.name), "{}" !== JSON.stringify(this.userData) && (n.userData = this.userData), this.castShadow === !0 && (n.castShadow = !0), this.receiveShadow === !0 && (n.receiveShadow = !0), this.visible === !1 && (n.visible = !1), n.matrix = this.matrix.toArray(), void 0 !== this.geometry && (void 0 === e.geometries[this.geometry.uuid] && (e.geometries[this.geometry.uuid] = this.geometry.toJSON(e)), n.geometry = this.geometry.uuid), void 0 !== this.material && (void 0 === e.materials[this.material.uuid] && (e.materials[this.material.uuid] = this.material.toJSON(e)), n.material = this.material.uuid), this.children.length > 0) {
                        n.children = [];
                        for (var o = 0; o < this.children.length; o++) n.children.push(this.children[o].toJSON(e).object)
                    }
                    if (i) {
                        var a = t(e.geometries),
                            s = t(e.materials),
                            l = t(e.textures),
                            c = t(e.images);
                        a.length > 0 && (r.geometries = a), s.length > 0 && (r.materials = s), l.length > 0 && (r.textures = l), c.length > 0 && (r.images = c)
                    }
                    return r.object = n, r
                },
                clone: function(e) {
                    return (new this.constructor).copy(this, e)
                },
                copy: function(e, t) {
                    if (void 0 === t && (t = !0), this.name = e.name, this.up.copy(e.up), this.position.copy(e.position), this.quaternion.copy(e.quaternion), this.scale.copy(e.scale), this.rotationAutoUpdate = e.rotationAutoUpdate, this.matrix.copy(e.matrix), this.matrixWorld.copy(e.matrixWorld), this.matrixAutoUpdate = e.matrixAutoUpdate, this.matrixWorldNeedsUpdate = e.matrixWorldNeedsUpdate, this.visible = e.visible, this.castShadow = e.castShadow, this.receiveShadow = e.receiveShadow, this.frustumCulled = e.frustumCulled, this.renderOrder = e.renderOrder, this.userData = JSON.parse(JSON.stringify(e.userData)), t === !0)
                        for (var i = 0; i < e.children.length; i++) {
                            var r = e.children[i];
                            this.add(r.clone())
                        }
                    return this
                }
            }, r.EventDispatcher.prototype.apply(r.Object3D.prototype), r.Object3DIdCount = 0, r.Face3 = function(e, t, i, n, o, a) {
                this.a = e, this.b = t, this.c = i, this.normal = n instanceof r.Vector3 ? n : new r.Vector3, this.vertexNormals = Array.isArray(n) ? n : [], this.color = o instanceof r.Color ? o : new r.Color, this.vertexColors = Array.isArray(o) ? o : [], this.materialIndex = void 0 !== a ? a : 0
            }, r.Face3.prototype = {
                constructor: r.Face3,
                clone: function() {
                    return (new this.constructor).copy(this)
                },
                copy: function(e) {
                    this.a = e.a, this.b = e.b, this.c = e.c, this.normal.copy(e.normal), this.color.copy(e.color), this.materialIndex = e.materialIndex;
                    for (var t = 0, i = e.vertexNormals.length; i > t; t++) this.vertexNormals[t] = e.vertexNormals[t].clone();
                    for (var t = 0, i = e.vertexColors.length; i > t; t++) this.vertexColors[t] = e.vertexColors[t].clone();
                    return this
                }
            }, r.BufferAttribute = function(e, t) {
                this.uuid = r.Math.generateUUID(), this.array = e, this.itemSize = t, this.dynamic = !1, this.updateRange = {
                    offset: 0,
                    count: -1
                }, this.version = 0
            }, r.BufferAttribute.prototype = {
                constructor: r.BufferAttribute,
                get count() {
                    return this.array.length / this.itemSize
                },
                set needsUpdate(e) {
                    e === !0 && this.version++
                },
                setDynamic: function(e) {
                    return this.dynamic = e, this
                },
                copy: function(e) {
                    return this.array = new e.array.constructor(e.array), this.itemSize = e.itemSize, this.dynamic = e.dynamic, this
                },
                copyAt: function(e, t, i) {
                    e *= this.itemSize, i *= t.itemSize;
                    for (var r = 0, n = this.itemSize; n > r; r++) this.array[e + r] = t.array[i + r];
                    return this
                },
                copyArray: function(e) {
                    return this.array.set(e), this
                },
                copyColorsArray: function(e) {
                    for (var t = this.array, i = 0, n = 0, o = e.length; o > n; n++) {
                        var a = e[n];
                        void 0 === a && (console.warn("THREE.BufferAttribute.copyColorsArray(): color is undefined", n), a = new r.Color), t[i++] = a.r, t[i++] = a.g, t[i++] = a.b
                    }
                    return this
                },
                copyIndicesArray: function(e) {
                    for (var t = this.array, i = 0, r = 0, n = e.length; n > r; r++) {
                        var o = e[r];
                        t[i++] = o.a, t[i++] = o.b, t[i++] = o.c
                    }
                    return this
                },
                copyVector2sArray: function(e) {
                    for (var t = this.array, i = 0, n = 0, o = e.length; o > n; n++) {
                        var a = e[n];
                        void 0 === a && (console.warn("THREE.BufferAttribute.copyVector2sArray(): vector is undefined", n), a = new r.Vector2), t[i++] = a.x, t[i++] = a.y
                    }
                    return this
                },
                copyVector3sArray: function(e) {
                    for (var t = this.array, i = 0, n = 0, o = e.length; o > n; n++) {
                        var a = e[n];
                        void 0 === a && (console.warn("THREE.BufferAttribute.copyVector3sArray(): vector is undefined", n), a = new r.Vector3), t[i++] = a.x, t[i++] = a.y, t[i++] = a.z
                    }
                    return this
                },
                copyVector4sArray: function(e) {
                    for (var t = this.array, i = 0, n = 0, o = e.length; o > n; n++) {
                        var a = e[n];
                        void 0 === a && (console.warn("THREE.BufferAttribute.copyVector4sArray(): vector is undefined", n), a = new r.Vector4), t[i++] = a.x, t[i++] = a.y, t[i++] = a.z, t[i++] = a.w
                    }
                    return this
                },
                set: function(e, t) {
                    return void 0 === t && (t = 0), this.array.set(e, t), this
                },
                getX: function(e) {
                    return this.array[e * this.itemSize]
                },
                setX: function(e, t) {
                    return this.array[e * this.itemSize] = t, this
                },
                getY: function(e) {
                    return this.array[e * this.itemSize + 1]
                },
                setY: function(e, t) {
                    return this.array[e * this.itemSize + 1] = t, this
                },
                getZ: function(e) {
                    return this.array[e * this.itemSize + 2]
                },
                setZ: function(e, t) {
                    return this.array[e * this.itemSize + 2] = t, this
                },
                getW: function(e) {
                    return this.array[e * this.itemSize + 3]
                },
                setW: function(e, t) {
                    return this.array[e * this.itemSize + 3] = t, this
                },
                setXY: function(e, t, i) {
                    return e *= this.itemSize, this.array[e + 0] = t, this.array[e + 1] = i, this
                },
                setXYZ: function(e, t, i, r) {
                    return e *= this.itemSize, this.array[e + 0] = t, this.array[e + 1] = i, this.array[e + 2] = r, this
                },
                setXYZW: function(e, t, i, r, n) {
                    return e *= this.itemSize, this.array[e + 0] = t, this.array[e + 1] = i, this.array[e + 2] = r, this.array[e + 3] = n, this
                },
                clone: function() {
                    return (new this.constructor).copy(this)
                }
            }, r.Int8Attribute = function(e, t) {
                return new r.BufferAttribute(new Int8Array(e), t)
            }, r.Uint8Attribute = function(e, t) {
                return new r.BufferAttribute(new Uint8Array(e), t)
            }, r.Uint8ClampedAttribute = function(e, t) {
                return new r.BufferAttribute(new Uint8ClampedArray(e), t)
            }, r.Int16Attribute = function(e, t) {
                return new r.BufferAttribute(new Int16Array(e), t)
            }, r.Uint16Attribute = function(e, t) {
                return new r.BufferAttribute(new Uint16Array(e), t)
            }, r.Int32Attribute = function(e, t) {
                return new r.BufferAttribute(new Int32Array(e), t)
            }, r.Uint32Attribute = function(e, t) {
                return new r.BufferAttribute(new Uint32Array(e), t)
            }, r.Float32Attribute = function(e, t) {
                return new r.BufferAttribute(new Float32Array(e), t)
            }, r.Float64Attribute = function(e, t) {
                return new r.BufferAttribute(new Float64Array(e), t)
            }, r.DynamicBufferAttribute = function(e, t) {
                return console.warn("THREE.DynamicBufferAttribute has been removed. Use new THREE.BufferAttribute().setDynamic( true ) instead."), new r.BufferAttribute(e, t).setDynamic(!0)
            }, r.InstancedBufferAttribute = function(e, t, i) {
                r.BufferAttribute.call(this, e, t), this.meshPerAttribute = i || 1
            }, r.InstancedBufferAttribute.prototype = Object.create(r.BufferAttribute.prototype), r.InstancedBufferAttribute.prototype.constructor = r.InstancedBufferAttribute, r.InstancedBufferAttribute.prototype.copy = function(e) {
                return r.BufferAttribute.prototype.copy.call(this, e), this.meshPerAttribute = e.meshPerAttribute, this
            }, r.InterleavedBuffer = function(e, t) {
                this.uuid = r.Math.generateUUID(), this.array = e, this.stride = t, this.dynamic = !1, this.updateRange = {
                    offset: 0,
                    count: -1
                }, this.version = 0
            }, r.InterleavedBuffer.prototype = {
                constructor: r.InterleavedBuffer,
                get length() {
                    return this.array.length
                },
                get count() {
                    return this.array.length / this.stride
                },
                set needsUpdate(e) {
                    e === !0 && this.version++
                },
                setDynamic: function(e) {
                    return this.dynamic = e, this
                },
                copy: function(e) {
                    return this.array = new e.array.constructor(e.array), this.stride = e.stride, this.dynamic = e.dynamic, this
                },
                copyAt: function(e, t, i) {
                    e *= this.stride, i *= t.stride;
                    for (var r = 0, n = this.stride; n > r; r++) this.array[e + r] = t.array[i + r];
                    return this
                },
                set: function(e, t) {
                    return void 0 === t && (t = 0), this.array.set(e, t), this
                },
                clone: function() {
                    return (new this.constructor).copy(this)
                }
            }, r.InstancedInterleavedBuffer = function(e, t, i) {
                r.InterleavedBuffer.call(this, e, t), this.meshPerAttribute = i || 1
            }, r.InstancedInterleavedBuffer.prototype = Object.create(r.InterleavedBuffer.prototype), r.InstancedInterleavedBuffer.prototype.constructor = r.InstancedInterleavedBuffer, r.InstancedInterleavedBuffer.prototype.copy = function(e) {
                return r.InterleavedBuffer.prototype.copy.call(this, e), this.meshPerAttribute = e.meshPerAttribute, this
            }, r.InterleavedBufferAttribute = function(e, t, i) {
                this.uuid = r.Math.generateUUID(), this.data = e, this.itemSize = t, this.offset = i
            }, r.InterleavedBufferAttribute.prototype = {
                constructor: r.InterleavedBufferAttribute,
                get length() {
                    return console.warn("THREE.BufferAttribute: .length has been deprecated. Please use .count."), this.array.length
                },
                get count() {
                    return this.data.count
                },
                setX: function(e, t) {
                    return this.data.array[e * this.data.stride + this.offset] = t, this
                },
                setY: function(e, t) {
                    return this.data.array[e * this.data.stride + this.offset + 1] = t, this
                },
                setZ: function(e, t) {
                    return this.data.array[e * this.data.stride + this.offset + 2] = t, this
                },
                setW: function(e, t) {
                    return this.data.array[e * this.data.stride + this.offset + 3] = t, this
                },
                getX: function(e) {
                    return this.data.array[e * this.data.stride + this.offset]
                },
                getY: function(e) {
                    return this.data.array[e * this.data.stride + this.offset + 1]
                },
                getZ: function(e) {
                    return this.data.array[e * this.data.stride + this.offset + 2]
                },
                getW: function(e) {
                    return this.data.array[e * this.data.stride + this.offset + 3]
                },
                setXY: function(e, t, i) {
                    return e = e * this.data.stride + this.offset, this.data.array[e + 0] = t, this.data.array[e + 1] = i, this
                },
                setXYZ: function(e, t, i, r) {
                    return e = e * this.data.stride + this.offset, this.data.array[e + 0] = t, this.data.array[e + 1] = i, this.data.array[e + 2] = r, this
                },
                setXYZW: function(e, t, i, r, n) {
                    return e = e * this.data.stride + this.offset, this.data.array[e + 0] = t, this.data.array[e + 1] = i, this.data.array[e + 2] = r, this.data.array[e + 3] = n, this
                }
            }, r.Geometry = function() {
                Object.defineProperty(this, "id", {
                    value: r.GeometryIdCount++
                }), this.uuid = r.Math.generateUUID(), this.name = "", this.type = "Geometry", this.vertices = [], this.colors = [], this.faces = [], this.faceVertexUvs = [
                    []
                ], this.morphTargets = [], this.morphNormals = [], this.skinWeights = [], this.skinIndices = [], this.lineDistances = [], this.boundingBox = null, this.boundingSphere = null, this.verticesNeedUpdate = !1, this.elementsNeedUpdate = !1, this.uvsNeedUpdate = !1, this.normalsNeedUpdate = !1, this.colorsNeedUpdate = !1, this.lineDistancesNeedUpdate = !1, this.groupsNeedUpdate = !1
            }, r.Geometry.prototype = {
                constructor: r.Geometry,
                applyMatrix: function(e) {
                    for (var t = (new r.Matrix3).getNormalMatrix(e), i = 0, n = this.vertices.length; n > i; i++) {
                        var o = this.vertices[i];
                        o.applyMatrix4(e)
                    }
                    for (var i = 0, n = this.faces.length; n > i; i++) {
                        var a = this.faces[i];
                        a.normal.applyMatrix3(t).normalize();
                        for (var s = 0, l = a.vertexNormals.length; l > s; s++) a.vertexNormals[s].applyMatrix3(t).normalize()
                    }
                    return null !== this.boundingBox && this.computeBoundingBox(), null !== this.boundingSphere && this.computeBoundingSphere(), this.verticesNeedUpdate = !0, this.normalsNeedUpdate = !0, this
                },
                rotateX: function() {
                    var e;
                    return function(t) {
                        return void 0 === e && (e = new r.Matrix4), e.makeRotationX(t), this.applyMatrix(e), this
                    }
                }(),
                rotateY: function() {
                    var e;
                    return function(t) {
                        return void 0 === e && (e = new r.Matrix4), e.makeRotationY(t), this.applyMatrix(e), this
                    }
                }(),
                rotateZ: function() {
                    var e;
                    return function(t) {
                        return void 0 === e && (e = new r.Matrix4), e.makeRotationZ(t), this.applyMatrix(e), this
                    }
                }(),
                translate: function() {
                    var e;
                    return function(t, i, n) {
                        return void 0 === e && (e = new r.Matrix4), e.makeTranslation(t, i, n), this.applyMatrix(e), this
                    }
                }(),
                scale: function() {
                    var e;
                    return function(t, i, n) {
                        return void 0 === e && (e = new r.Matrix4), e.makeScale(t, i, n), this.applyMatrix(e), this
                    }
                }(),
                lookAt: function() {
                    var e;
                    return function(t) {
                        void 0 === e && (e = new r.Object3D), e.lookAt(t), e.updateMatrix(), this.applyMatrix(e.matrix)
                    }
                }(),
                fromBufferGeometry: function(e) {
                    function t(e, t, n, o) {
                        var a = void 0 !== s ? [u[e].clone(), u[t].clone(), u[n].clone()] : [],
                            d = void 0 !== l ? [i.colors[e].clone(), i.colors[t].clone(), i.colors[n].clone()] : [],
                            m = new r.Face3(e, t, n, a, d, o);
                        i.faces.push(m), void 0 !== c && i.faceVertexUvs[0].push([p[e].clone(), p[t].clone(), p[n].clone()]), void 0 !== h && i.faceVertexUvs[1].push([f[e].clone(), f[t].clone(), f[n].clone()])
                    }
                    var i = this,
                        n = null !== e.index ? e.index.array : void 0,
                        o = e.attributes,
                        a = o.position.array,
                        s = void 0 !== o.normal ? o.normal.array : void 0,
                        l = void 0 !== o.color ? o.color.array : void 0,
                        c = void 0 !== o.uv ? o.uv.array : void 0,
                        h = void 0 !== o.uv2 ? o.uv2.array : void 0;
                    void 0 !== h && (this.faceVertexUvs[1] = []);
                    for (var u = [], p = [], f = [], d = 0, m = 0; d < a.length; d += 3, m += 2) i.vertices.push(new r.Vector3(a[d], a[d + 1], a[d + 2])), void 0 !== s && u.push(new r.Vector3(s[d], s[d + 1], s[d + 2])), void 0 !== l && i.colors.push(new r.Color(l[d], l[d + 1], l[d + 2])), void 0 !== c && p.push(new r.Vector2(c[m], c[m + 1])), void 0 !== h && f.push(new r.Vector2(h[m], h[m + 1]));
                    if (void 0 !== n) {
                        var g = e.groups;
                        if (g.length > 0)
                            for (var d = 0; d < g.length; d++)
                                for (var v = g[d], y = v.start, _ = v.count, m = y, x = y + _; x > m; m += 3) t(n[m], n[m + 1], n[m + 2], v.materialIndex);
                        else
                            for (var d = 0; d < n.length; d += 3) t(n[d], n[d + 1], n[d + 2])
                    } else
                        for (var d = 0; d < a.length / 3; d += 3) t(d, d + 1, d + 2);
                    return this.computeFaceNormals(), null !== e.boundingBox && (this.boundingBox = e.boundingBox.clone()), null !== e.boundingSphere && (this.boundingSphere = e.boundingSphere.clone()), this
                },
                center: function() {
                    this.computeBoundingBox();
                    var e = this.boundingBox.center().negate();
                    return this.translate(e.x, e.y, e.z), e
                },
                normalize: function() {
                    this.computeBoundingSphere();
                    var e = this.boundingSphere.center,
                        t = this.boundingSphere.radius,
                        i = 0 === t ? 1 : 1 / t,
                        n = new r.Matrix4;
                    return n.set(i, 0, 0, -i * e.x, 0, i, 0, -i * e.y, 0, 0, i, -i * e.z, 0, 0, 0, 1), this.applyMatrix(n), this
                },
                computeFaceNormals: function() {
                    for (var e = new r.Vector3, t = new r.Vector3, i = 0, n = this.faces.length; n > i; i++) {
                        var o = this.faces[i],
                            a = this.vertices[o.a],
                            s = this.vertices[o.b],
                            l = this.vertices[o.c];
                        e.subVectors(l, s), t.subVectors(a, s), e.cross(t), e.normalize(), o.normal.copy(e)
                    }
                },
                computeVertexNormals: function(e) {
                    void 0 === e && (e = !0);
                    var t, i, n, o, a, s;
                    for (s = new Array(this.vertices.length), t = 0, i = this.vertices.length; i > t; t++) s[t] = new r.Vector3;
                    if (e) {
                        var l, c, h, u = new r.Vector3,
                            p = new r.Vector3;
                        for (n = 0, o = this.faces.length; o > n; n++) a = this.faces[n], l = this.vertices[a.a], c = this.vertices[a.b], h = this.vertices[a.c], u.subVectors(h, c), p.subVectors(l, c), u.cross(p), s[a.a].add(u), s[a.b].add(u), s[a.c].add(u)
                    } else
                        for (n = 0, o = this.faces.length; o > n; n++) a = this.faces[n], s[a.a].add(a.normal), s[a.b].add(a.normal), s[a.c].add(a.normal);
                    for (t = 0, i = this.vertices.length; i > t; t++) s[t].normalize();
                    for (n = 0, o = this.faces.length; o > n; n++) {
                        a = this.faces[n];
                        var f = a.vertexNormals;
                        3 === f.length ? (f[0].copy(s[a.a]), f[1].copy(s[a.b]), f[2].copy(s[a.c])) : (f[0] = s[a.a].clone(), f[1] = s[a.b].clone(), f[2] = s[a.c].clone())
                    }
                    this.faces.length > 0 && (this.normalsNeedUpdate = !0)
                },
                computeMorphNormals: function() {
                    var e, t, i, n, o;
                    for (i = 0, n = this.faces.length; n > i; i++)
                        for (o = this.faces[i], o.__originalFaceNormal ? o.__originalFaceNormal.copy(o.normal) : o.__originalFaceNormal = o.normal.clone(), o.__originalVertexNormals || (o.__originalVertexNormals = []), e = 0, t = o.vertexNormals.length; t > e; e++) o.__originalVertexNormals[e] ? o.__originalVertexNormals[e].copy(o.vertexNormals[e]) : o.__originalVertexNormals[e] = o.vertexNormals[e].clone();
                    var a = new r.Geometry;
                    for (a.faces = this.faces, e = 0, t = this.morphTargets.length; t > e; e++) {
                        if (!this.morphNormals[e]) {
                            this.morphNormals[e] = {}, this.morphNormals[e].faceNormals = [], this.morphNormals[e].vertexNormals = [];
                            var s, l, c = this.morphNormals[e].faceNormals,
                                h = this.morphNormals[e].vertexNormals;
                            for (i = 0, n = this.faces.length; n > i; i++) s = new r.Vector3, l = {
                                a: new r.Vector3,
                                b: new r.Vector3,
                                c: new r.Vector3
                            }, c.push(s), h.push(l)
                        }
                        var u = this.morphNormals[e];
                        a.vertices = this.morphTargets[e].vertices, a.computeFaceNormals(), a.computeVertexNormals();
                        var s, l;
                        for (i = 0, n = this.faces.length; n > i; i++) o = this.faces[i], s = u.faceNormals[i], l = u.vertexNormals[i], s.copy(o.normal), l.a.copy(o.vertexNormals[0]), l.b.copy(o.vertexNormals[1]), l.c.copy(o.vertexNormals[2])
                    }
                    for (i = 0, n = this.faces.length; n > i; i++) o = this.faces[i], o.normal = o.__originalFaceNormal, o.vertexNormals = o.__originalVertexNormals
                },
                computeTangents: function() {
                    console.warn("THREE.Geometry: .computeTangents() has been removed.")
                },
                computeLineDistances: function() {
                    for (var e = 0, t = this.vertices, i = 0, r = t.length; r > i; i++) i > 0 && (e += t[i].distanceTo(t[i - 1])), this.lineDistances[i] = e
                },
                computeBoundingBox: function() {
                    null === this.boundingBox && (this.boundingBox = new r.Box3), this.boundingBox.setFromPoints(this.vertices)
                },
                computeBoundingSphere: function() {
                    null === this.boundingSphere && (this.boundingSphere = new r.Sphere), this.boundingSphere.setFromPoints(this.vertices)
                },
                merge: function(e, t, i) {
                    if (e instanceof r.Geometry == !1) return void console.error("THREE.Geometry.merge(): geometry not an instance of THREE.Geometry.", e);
                    var n, o = this.vertices.length,
                        a = this.vertices,
                        s = e.vertices,
                        l = this.faces,
                        c = e.faces,
                        h = this.faceVertexUvs[0],
                        u = e.faceVertexUvs[0];
                    void 0 === i && (i = 0), void 0 !== t && (n = (new r.Matrix3).getNormalMatrix(t));
                    for (var p = 0, f = s.length; f > p; p++) {
                        var d = s[p],
                            m = d.clone();
                        void 0 !== t && m.applyMatrix4(t), a.push(m)
                    }
                    for (p = 0, f = c.length; f > p; p++) {
                        var g, v, y, _ = c[p],
                            x = _.vertexNormals,
                            b = _.vertexColors;
                        g = new r.Face3(_.a + o, _.b + o, _.c + o), g.normal.copy(_.normal), void 0 !== n && g.normal.applyMatrix3(n).normalize();
                        for (var w = 0, T = x.length; T > w; w++) v = x[w].clone(), void 0 !== n && v.applyMatrix3(n).normalize(), g.vertexNormals.push(v);
                        g.color.copy(_.color);
                        for (var w = 0, T = b.length; T > w; w++) y = b[w], g.vertexColors.push(y.clone());
                        g.materialIndex = _.materialIndex + i, l.push(g)
                    }
                    for (p = 0, f = u.length; f > p; p++) {
                        var M = u[p],
                            S = [];
                        if (void 0 !== M) {
                            for (var w = 0, T = M.length; T > w; w++) S.push(M[w].clone());
                            h.push(S)
                        }
                    }
                },
                mergeMesh: function(e) {
                    return e instanceof r.Mesh == !1 ? void console.error("THREE.Geometry.mergeMesh(): mesh not an instance of THREE.Mesh.", e) : (e.matrixAutoUpdate && e.updateMatrix(), void this.merge(e.geometry, e.matrix))
                },
                mergeVertices: function() {
                    var e, t, i, r, n, o, a, s, l = {},
                        c = [],
                        h = [],
                        u = 4,
                        p = Math.pow(10, u);
                    for (i = 0, r = this.vertices.length; r > i; i++) e = this.vertices[i], t = Math.round(e.x * p) + "_" + Math.round(e.y * p) + "_" + Math.round(e.z * p), void 0 === l[t] ? (l[t] = i, c.push(this.vertices[i]), h[i] = c.length - 1) : h[i] = h[l[t]];
                    var f = [];
                    for (i = 0, r = this.faces.length; r > i; i++) {
                        n = this.faces[i], n.a = h[n.a], n.b = h[n.b], n.c = h[n.c], o = [n.a, n.b, n.c];
                        for (var d = -1, m = 0; 3 > m; m++)
                            if (o[m] === o[(m + 1) % 3]) {
                                d = m, f.push(i);
                                break
                            }
                    }
                    for (i = f.length - 1; i >= 0; i--) {
                        var g = f[i];
                        for (this.faces.splice(g, 1), a = 0, s = this.faceVertexUvs.length; s > a; a++) this.faceVertexUvs[a].splice(g, 1)
                    }
                    var v = this.vertices.length - c.length;
                    return this.vertices = c, v
                },
                sortFacesByMaterialIndex: function() {
                    function e(e, t) {
                        return e.materialIndex - t.materialIndex
                    }
                    for (var t = this.faces, i = t.length, r = 0; i > r; r++) t[r]._id = r;
                    t.sort(e);
                    var n, o, a = this.faceVertexUvs[0],
                        s = this.faceVertexUvs[1];
                    a && a.length === i && (n = []), s && s.length === i && (o = []);
                    for (var r = 0; i > r; r++) {
                        var l = t[r]._id;
                        n && n.push(a[l]), o && o.push(s[l])
                    }
                    n && (this.faceVertexUvs[0] = n), o && (this.faceVertexUvs[1] = o)
                },
                toJSON: function() {
                    function e(e, t, i) {
                        return i ? e | 1 << t : e & ~(1 << t)
                    }

                    function t(e) {
                        var t = e.x.toString() + e.y.toString() + e.z.toString();
                        return void 0 !== p[t] ? p[t] : (p[t] = u.length / 3, u.push(e.x, e.y, e.z), p[t])
                    }

                    function i(e) {
                        var t = e.r.toString() + e.g.toString() + e.b.toString();
                        return void 0 !== d[t] ? d[t] : (d[t] = f.length, f.push(e.getHex()), d[t])
                    }

                    function r(e) {
                        var t = e.x.toString() + e.y.toString();
                        return void 0 !== g[t] ? g[t] : (g[t] = m.length / 2, m.push(e.x, e.y), g[t])
                    }
                    var n = {
                        metadata: {
                            version: 4.4,
                            type: "Geometry",
                            generator: "Geometry.toJSON"
                        }
                    };
                    if (n.uuid = this.uuid, n.type = this.type, "" !== this.name && (n.name = this.name), void 0 !== this.parameters) {
                        var o = this.parameters;
                        for (var a in o) void 0 !== o[a] && (n[a] = o[a]);
                        return n
                    }
                    for (var s = [], l = 0; l < this.vertices.length; l++) {
                        var c = this.vertices[l];
                        s.push(c.x, c.y, c.z)
                    }
                    for (var h = [], u = [], p = {}, f = [], d = {}, m = [], g = {}, l = 0; l < this.faces.length; l++) {
                        var v = this.faces[l],
                            y = !0,
                            _ = !1,
                            x = void 0 !== this.faceVertexUvs[0][l],
                            b = v.normal.length() > 0,
                            w = v.vertexNormals.length > 0,
                            T = 1 !== v.color.r || 1 !== v.color.g || 1 !== v.color.b,
                            M = v.vertexColors.length > 0,
                            S = 0;
                        if (S = e(S, 0, 0), S = e(S, 1, y), S = e(S, 2, _), S = e(S, 3, x), S = e(S, 4, b), S = e(S, 5, w), S = e(S, 6, T), S = e(S, 7, M), h.push(S), h.push(v.a, v.b, v.c), h.push(v.materialIndex), x) {
                            var E = this.faceVertexUvs[0][l];
                            h.push(r(E[0]), r(E[1]), r(E[2]))
                        }
                        if (b && h.push(t(v.normal)), w) {
                            var A = v.vertexNormals;
                            h.push(t(A[0]), t(A[1]), t(A[2]))
                        }
                        if (T && h.push(i(v.color)), M) {
                            var C = v.vertexColors;
                            h.push(i(C[0]), i(C[1]), i(C[2]))
                        }
                    }
                    return n.data = {}, n.data.vertices = s, n.data.normals = u, f.length > 0 && (n.data.colors = f), m.length > 0 && (n.data.uvs = [m]), n.data.faces = h, n
                },
                clone: function() {
                    return (new r.Geometry).copy(this)
                },
                copy: function(e) {
                    this.vertices = [], this.faces = [], this.faceVertexUvs = [
                        []
                    ];
                    for (var t = e.vertices, i = 0, r = t.length; r > i; i++) this.vertices.push(t[i].clone());
                    for (var n = e.faces, i = 0, r = n.length; r > i; i++) this.faces.push(n[i].clone());
                    for (var i = 0, r = e.faceVertexUvs.length; r > i; i++) {
                        var o = e.faceVertexUvs[i];
                        void 0 === this.faceVertexUvs[i] && (this.faceVertexUvs[i] = []);
                        for (var a = 0, s = o.length; s > a; a++) {
                            for (var l = o[a], c = [], h = 0, u = l.length; u > h; h++) {
                                var p = l[h];
                                c.push(p.clone())
                            }
                            this.faceVertexUvs[i].push(c)
                        }
                    }
                    return this
                },
                dispose: function() {
                    this.dispatchEvent({
                        type: "dispose"
                    })
                }
            }, r.EventDispatcher.prototype.apply(r.Geometry.prototype), r.GeometryIdCount = 0, r.DirectGeometry = function() {
                Object.defineProperty(this, "id", {
                    value: r.GeometryIdCount++
                }), this.uuid = r.Math.generateUUID(), this.name = "", this.type = "DirectGeometry", this.indices = [], this.vertices = [], this.normals = [], this.colors = [], this.uvs = [], this.uvs2 = [], this.groups = [], this.morphTargets = {}, this.skinWeights = [], this.skinIndices = [], this.boundingBox = null, this.boundingSphere = null, this.verticesNeedUpdate = !1, this.normalsNeedUpdate = !1, this.colorsNeedUpdate = !1, this.uvsNeedUpdate = !1, this.groupsNeedUpdate = !1
            }, r.DirectGeometry.prototype = {
                constructor: r.DirectGeometry,
                computeBoundingBox: r.Geometry.prototype.computeBoundingBox,
                computeBoundingSphere: r.Geometry.prototype.computeBoundingSphere,
                computeFaceNormals: function() {
                    console.warn("THREE.DirectGeometry: computeFaceNormals() is not a method of this type of geometry.")
                },
                computeVertexNormals: function() {
                    console.warn("THREE.DirectGeometry: computeVertexNormals() is not a method of this type of geometry.")
                },
                computeGroups: function(e) {
                    for (var t, i, r = [], n = e.faces, o = 0; o < n.length; o++) {
                        var a = n[o];
                        a.materialIndex !== i && (i = a.materialIndex, void 0 !== t && (t.count = 3 * o - t.start, r.push(t)), t = {
                            start: 3 * o,
                            materialIndex: i
                        })
                    }
                    void 0 !== t && (t.count = 3 * o - t.start, r.push(t)), this.groups = r
                },
                fromGeometry: function(e) {
                    var t, i = e.faces,
                        n = e.vertices,
                        o = e.faceVertexUvs,
                        a = o[0] && o[0].length > 0,
                        s = o[1] && o[1].length > 0,
                        l = e.morphTargets,
                        c = l.length;
                    if (c > 0) {
                        t = [];
                        for (var h = 0; c > h; h++) t[h] = [];
                        this.morphTargets.position = t
                    }
                    var u, p = e.morphNormals,
                        f = p.length;
                    if (f > 0) {
                        u = [];
                        for (var h = 0; f > h; h++) u[h] = [];
                        this.morphTargets.normal = u
                    }
                    for (var d = e.skinIndices, m = e.skinWeights, g = d.length === n.length, v = m.length === n.length, h = 0; h < i.length; h++) {
                        var y = i[h];
                        this.vertices.push(n[y.a], n[y.b], n[y.c]);
                        var _ = y.vertexNormals;
                        if (3 === _.length) this.normals.push(_[0], _[1], _[2]);
                        else {
                            var x = y.normal;
                            this.normals.push(x, x, x)
                        }
                        var b = y.vertexColors;
                        if (3 === b.length) this.colors.push(b[0], b[1], b[2]);
                        else {
                            var w = y.color;
                            this.colors.push(w, w, w)
                        }
                        if (a === !0) {
                            var T = o[0][h];
                            void 0 !== T ? this.uvs.push(T[0], T[1], T[2]) : (console.warn("THREE.DirectGeometry.fromGeometry(): Undefined vertexUv ", h), this.uvs.push(new r.Vector2, new r.Vector2, new r.Vector2))
                        }
                        if (s === !0) {
                            var T = o[1][h];
                            void 0 !== T ? this.uvs2.push(T[0], T[1], T[2]) : (console.warn("THREE.DirectGeometry.fromGeometry(): Undefined vertexUv2 ", h), this.uvs2.push(new r.Vector2, new r.Vector2, new r.Vector2))
                        }
                        for (var M = 0; c > M; M++) {
                            var S = l[M].vertices;
                            t[M].push(S[y.a], S[y.b], S[y.c])
                        }
                        for (var M = 0; f > M; M++) {
                            var E = p[M].vertexNormals[h];
                            u[M].push(E.a, E.b, E.c)
                        }
                        g && this.skinIndices.push(d[y.a], d[y.b], d[y.c]), v && this.skinWeights.push(m[y.a], m[y.b], m[y.c])
                    }
                    return this.computeGroups(e), this.verticesNeedUpdate = e.verticesNeedUpdate, this.normalsNeedUpdate = e.normalsNeedUpdate, this.colorsNeedUpdate = e.colorsNeedUpdate, this.uvsNeedUpdate = e.uvsNeedUpdate, this.groupsNeedUpdate = e.groupsNeedUpdate, this
                },
                dispose: function() {
                    this.dispatchEvent({
                        type: "dispose"
                    })
                }
            }, r.EventDispatcher.prototype.apply(r.DirectGeometry.prototype), r.BufferGeometry = function() {
                Object.defineProperty(this, "id", {
                    value: r.GeometryIdCount++
                }), this.uuid = r.Math.generateUUID(), this.name = "", this.type = "BufferGeometry", this.index = null, this.attributes = {}, this.morphAttributes = {}, this.groups = [], this.boundingBox = null, this.boundingSphere = null, this.drawRange = {
                    start: 0,
                    count: 1 / 0
                }
            }, r.BufferGeometry.prototype = {
                constructor: r.BufferGeometry,
                getIndex: function() {
                    return this.index
                },
                setIndex: function(e) {
                    this.index = e
                },
                addAttribute: function(e, t) {
                    return t instanceof r.BufferAttribute == !1 && t instanceof r.InterleavedBufferAttribute == !1 ? (console.warn("THREE.BufferGeometry: .addAttribute() now expects ( name, attribute )."), void this.addAttribute(e, new r.BufferAttribute(arguments[1], arguments[2]))) : "index" === e ? (console.warn("THREE.BufferGeometry.addAttribute: Use .setIndex() for index attribute."), void this.setIndex(t)) : (this.attributes[e] = t, this)
                },
                getAttribute: function(e) {
                    return this.attributes[e]
                },
                removeAttribute: function(e) {
                    return delete this.attributes[e], this
                },
                addGroup: function(e, t, i) {
                    this.groups.push({
                        start: e,
                        count: t,
                        materialIndex: void 0 !== i ? i : 0
                    })
                },
                clearGroups: function() {
                    this.groups = []
                },
                setDrawRange: function(e, t) {
                    this.drawRange.start = e, this.drawRange.count = t
                },
                applyMatrix: function(e) {
                    var t = this.attributes.position;
                    void 0 !== t && (e.applyToVector3Array(t.array), t.needsUpdate = !0);
                    var i = this.attributes.normal;
                    if (void 0 !== i) {
                        var n = (new r.Matrix3).getNormalMatrix(e);
                        n.applyToVector3Array(i.array), i.needsUpdate = !0
                    }
                    return null !== this.boundingBox && this.computeBoundingBox(), null !== this.boundingSphere && this.computeBoundingSphere(), this
                },
                rotateX: function() {
                    var e;
                    return function(t) {
                        return void 0 === e && (e = new r.Matrix4), e.makeRotationX(t), this.applyMatrix(e), this
                    }
                }(),
                rotateY: function() {
                    var e;
                    return function(t) {
                        return void 0 === e && (e = new r.Matrix4), e.makeRotationY(t), this.applyMatrix(e), this
                    }
                }(),
                rotateZ: function() {
                    var e;
                    return function(t) {
                        return void 0 === e && (e = new r.Matrix4), e.makeRotationZ(t), this.applyMatrix(e), this
                    }
                }(),
                translate: function() {
                    var e;
                    return function(t, i, n) {
                        return void 0 === e && (e = new r.Matrix4), e.makeTranslation(t, i, n), this.applyMatrix(e), this
                    }
                }(),
                scale: function() {
                    var e;
                    return function(t, i, n) {
                        return void 0 === e && (e = new r.Matrix4), e.makeScale(t, i, n), this.applyMatrix(e), this
                    }
                }(),
                lookAt: function() {
                    var e;
                    return function(t) {
                        void 0 === e && (e = new r.Object3D), e.lookAt(t), e.updateMatrix(), this.applyMatrix(e.matrix)
                    }
                }(),
                center: function() {
                    this.computeBoundingBox();
                    var e = this.boundingBox.center().negate();
                    return this.translate(e.x, e.y, e.z), e
                },
                setFromObject: function(e) {
                    var t = e.geometry;
                    if (e instanceof r.Points || e instanceof r.Line) {
                        var i = new r.Float32Attribute(3 * t.vertices.length, 3),
                            n = new r.Float32Attribute(3 * t.colors.length, 3);
                        if (this.addAttribute("position", i.copyVector3sArray(t.vertices)), this.addAttribute("color", n.copyColorsArray(t.colors)), t.lineDistances && t.lineDistances.length === t.vertices.length) {
                            var o = new r.Float32Attribute(t.lineDistances.length, 1);
                            this.addAttribute("lineDistance", o.copyArray(t.lineDistances))
                        }
                        null !== t.boundingSphere && (this.boundingSphere = t.boundingSphere.clone()), null !== t.boundingBox && (this.boundingBox = t.boundingBox.clone())
                    } else e instanceof r.Mesh && t instanceof r.Geometry && this.fromGeometry(t);
                    return this
                },
                updateFromObject: function(e) {
                    var t = e.geometry;
                    if (e instanceof r.Mesh) {
                        var i = t.__directGeometry;
                        if (void 0 === i) return this.fromGeometry(t);
                        i.verticesNeedUpdate = t.verticesNeedUpdate, i.normalsNeedUpdate = t.normalsNeedUpdate, i.colorsNeedUpdate = t.colorsNeedUpdate, i.uvsNeedUpdate = t.uvsNeedUpdate, i.groupsNeedUpdate = t.groupsNeedUpdate, t.verticesNeedUpdate = !1, t.normalsNeedUpdate = !1, t.colorsNeedUpdate = !1, t.uvsNeedUpdate = !1, t.groupsNeedUpdate = !1, t = i
                    }
                    if (t.verticesNeedUpdate === !0) {
                        var n = this.attributes.position;
                        void 0 !== n && (n.copyVector3sArray(t.vertices), n.needsUpdate = !0), t.verticesNeedUpdate = !1
                    }
                    if (t.normalsNeedUpdate === !0) {
                        var n = this.attributes.normal;
                        void 0 !== n && (n.copyVector3sArray(t.normals), n.needsUpdate = !0), t.normalsNeedUpdate = !1
                    }
                    if (t.colorsNeedUpdate === !0) {
                        var n = this.attributes.color;
                        void 0 !== n && (n.copyColorsArray(t.colors), n.needsUpdate = !0), t.colorsNeedUpdate = !1
                    }
                    if (t.uvsNeedUpdate) {
                        var n = this.attributes.uv;
                        void 0 !== n && (n.copyVector2sArray(t.uvs), n.needsUpdate = !0), t.uvsNeedUpdate = !1
                    }
                    if (t.lineDistancesNeedUpdate) {
                        var n = this.attributes.lineDistance;
                        void 0 !== n && (n.copyArray(t.lineDistances), n.needsUpdate = !0), t.lineDistancesNeedUpdate = !1
                    }
                    return t.groupsNeedUpdate && (t.computeGroups(e.geometry), this.groups = t.groups, t.groupsNeedUpdate = !1), this
                },
                fromGeometry: function(e) {
                    return e.__directGeometry = (new r.DirectGeometry).fromGeometry(e), this.fromDirectGeometry(e.__directGeometry)
                },
                fromDirectGeometry: function(e) {
                    var t = new Float32Array(3 * e.vertices.length);
                    if (this.addAttribute("position", new r.BufferAttribute(t, 3).copyVector3sArray(e.vertices)), e.normals.length > 0) {
                        var i = new Float32Array(3 * e.normals.length);
                        this.addAttribute("normal", new r.BufferAttribute(i, 3).copyVector3sArray(e.normals))
                    }
                    if (e.colors.length > 0) {
                        var n = new Float32Array(3 * e.colors.length);
                        this.addAttribute("color", new r.BufferAttribute(n, 3).copyColorsArray(e.colors))
                    }
                    if (e.uvs.length > 0) {
                        var o = new Float32Array(2 * e.uvs.length);
                        this.addAttribute("uv", new r.BufferAttribute(o, 2).copyVector2sArray(e.uvs))
                    }
                    if (e.uvs2.length > 0) {
                        var a = new Float32Array(2 * e.uvs2.length);
                        this.addAttribute("uv2", new r.BufferAttribute(a, 2).copyVector2sArray(e.uvs2))
                    }
                    if (e.indices.length > 0) {
                        var s = e.vertices.length > 65535 ? Uint32Array : Uint16Array,
                            l = new s(3 * e.indices.length);
                        this.setIndex(new r.BufferAttribute(l, 1).copyIndicesArray(e.indices))
                    }
                    this.groups = e.groups;
                    for (var c in e.morphTargets) {
                        for (var h = [], u = e.morphTargets[c], p = 0, f = u.length; f > p; p++) {
                            var d = u[p],
                                m = new r.Float32Attribute(3 * d.length, 3);
                            h.push(m.copyVector3sArray(d))
                        }
                        this.morphAttributes[c] = h
                    }
                    if (e.skinIndices.length > 0) {
                        var g = new r.Float32Attribute(4 * e.skinIndices.length, 4);
                        this.addAttribute("skinIndex", g.copyVector4sArray(e.skinIndices))
                    }
                    if (e.skinWeights.length > 0) {
                        var v = new r.Float32Attribute(4 * e.skinWeights.length, 4);
                        this.addAttribute("skinWeight", v.copyVector4sArray(e.skinWeights))
                    }
                    return null !== e.boundingSphere && (this.boundingSphere = e.boundingSphere.clone()), null !== e.boundingBox && (this.boundingBox = e.boundingBox.clone()), this
                },
                computeBoundingBox: function() {
                    new r.Vector3;
                    return function() {
                        null === this.boundingBox && (this.boundingBox = new r.Box3);
                        var e = this.attributes.position.array;
                        e && this.boundingBox.setFromArray(e), void 0 !== e && 0 !== e.length || (this.boundingBox.min.set(0, 0, 0), this.boundingBox.max.set(0, 0, 0)), (isNaN(this.boundingBox.min.x) || isNaN(this.boundingBox.min.y) || isNaN(this.boundingBox.min.z)) && console.error('THREE.BufferGeometry.computeBoundingBox: Computed min/max have NaN values. The "position" attribute is likely to have NaN values.', this)
                    }
                }(),
                computeBoundingSphere: function() {
                    var e = new r.Box3,
                        t = new r.Vector3;
                    return function() {
                        null === this.boundingSphere && (this.boundingSphere = new r.Sphere);
                        var i = this.attributes.position.array;
                        if (i) {
                            var n = this.boundingSphere.center;
                            e.setFromArray(i), e.center(n);
                            for (var o = 0, a = 0, s = i.length; s > a; a += 3) t.fromArray(i, a), o = Math.max(o, n.distanceToSquared(t));
                            this.boundingSphere.radius = Math.sqrt(o), isNaN(this.boundingSphere.radius) && console.error('THREE.BufferGeometry.computeBoundingSphere(): Computed radius is NaN. The "position" attribute is likely to have NaN values.', this)
                        }
                    }
                }(),
                computeFaceNormals: function() {},
                computeVertexNormals: function() {
                    var e = this.index,
                        t = this.attributes,
                        i = this.groups;
                    if (t.position) {
                        var n = t.position.array;
                        if (void 0 === t.normal) this.addAttribute("normal", new r.BufferAttribute(new Float32Array(n.length), 3));
                        else
                            for (var o = t.normal.array, a = 0, s = o.length; s > a; a++) o[a] = 0;
                        var l, c, h, u = t.normal.array,
                            p = new r.Vector3,
                            f = new r.Vector3,
                            d = new r.Vector3,
                            m = new r.Vector3,
                            g = new r.Vector3;
                        if (e) {
                            var v = e.array;
                            0 === i.length && this.addGroup(0, v.length);
                            for (var y = 0, _ = i.length; _ > y; ++y)
                                for (var x = i[y], b = x.start, w = x.count, a = b, s = b + w; s > a; a += 3) l = 3 * v[a + 0], c = 3 * v[a + 1], h = 3 * v[a + 2], p.fromArray(n, l), f.fromArray(n, c), d.fromArray(n, h), m.subVectors(d, f), g.subVectors(p, f), m.cross(g), u[l] += m.x, u[l + 1] += m.y, u[l + 2] += m.z, u[c] += m.x, u[c + 1] += m.y, u[c + 2] += m.z, u[h] += m.x, u[h + 1] += m.y, u[h + 2] += m.z
                        } else
                            for (var a = 0, s = n.length; s > a; a += 9) p.fromArray(n, a), f.fromArray(n, a + 3), d.fromArray(n, a + 6), m.subVectors(d, f), g.subVectors(p, f), m.cross(g), u[a] = m.x, u[a + 1] = m.y, u[a + 2] = m.z, u[a + 3] = m.x, u[a + 4] = m.y, u[a + 5] = m.z, u[a + 6] = m.x, u[a + 7] = m.y, u[a + 8] = m.z;
                        this.normalizeNormals(), t.normal.needsUpdate = !0
                    }
                },
                merge: function(e, t) {
                    if (e instanceof r.BufferGeometry == !1) return void console.error("THREE.BufferGeometry.merge(): geometry not an instance of THREE.BufferGeometry.", e);
                    void 0 === t && (t = 0);
                    var i = this.attributes;
                    for (var n in i)
                        if (void 0 !== e.attributes[n])
                            for (var o = i[n], a = o.array, s = e.attributes[n], l = s.array, c = s.itemSize, h = 0, u = c * t; h < l.length; h++, u++) a[u] = l[h];
                    return this
                },
                normalizeNormals: function() {
                    for (var e, t, i, r, n = this.attributes.normal.array, o = 0, a = n.length; a > o; o += 3) e = n[o], t = n[o + 1], i = n[o + 2], r = 1 / Math.sqrt(e * e + t * t + i * i), n[o] *= r, n[o + 1] *= r, n[o + 2] *= r
                },
                toNonIndexed: function() {
                    if (null === this.index) return console.warn("THREE.BufferGeometry.toNonIndexed(): Geometry is already non-indexed."), this;
                    var e = new r.BufferGeometry,
                        t = this.index.array,
                        i = this.attributes;
                    for (var n in i) {
                        for (var o = i[n], a = o.array, s = o.itemSize, l = new a.constructor(t.length * s), c = 0, h = 0, u = 0, p = t.length; p > u; u++) {
                            c = t[u] * s;
                            for (var f = 0; s > f; f++) l[h++] = a[c++]
                        }
                        e.addAttribute(n, new r.BufferAttribute(l, s))
                    }
                    return e
                },
                toJSON: function() {
                    var e = {
                        metadata: {
                            version: 4.4,
                            type: "BufferGeometry",
                            generator: "BufferGeometry.toJSON"
                        }
                    };
                    if (e.uuid = this.uuid, e.type = this.type, "" !== this.name && (e.name = this.name), void 0 !== this.parameters) {
                        var t = this.parameters;
                        for (var i in t) void 0 !== t[i] && (e[i] = t[i]);
                        return e
                    }
                    e.data = {
                        attributes: {}
                    };
                    var r = this.index;
                    if (null !== r) {
                        var n = Array.prototype.slice.call(r.array);
                        e.data.index = {
                            type: r.array.constructor.name,
                            array: n
                        }
                    }
                    var o = this.attributes;
                    for (var i in o) {
                        var a = o[i],
                            n = Array.prototype.slice.call(a.array);
                        e.data.attributes[i] = {
                            itemSize: a.itemSize,
                            type: a.array.constructor.name,
                            array: n
                        }
                    }
                    var s = this.groups;
                    s.length > 0 && (e.data.groups = JSON.parse(JSON.stringify(s)));
                    var l = this.boundingSphere;
                    return null !== l && (e.data.boundingSphere = {
                        center: l.center.toArray(),
                        radius: l.radius
                    }), e
                },
                clone: function() {
                    return (new r.BufferGeometry).copy(this)
                },
                copy: function(e) {
                    var t = e.index;
                    null !== t && this.setIndex(t.clone());
                    var i = e.attributes;
                    for (var r in i) {
                        var n = i[r];
                        this.addAttribute(r, n.clone())
                    }
                    for (var o = e.groups, a = 0, s = o.length; s > a; a++) {
                        var l = o[a];
                        this.addGroup(l.start, l.count)
                    }
                    return this
                },
                dispose: function() {
                    this.dispatchEvent({
                        type: "dispose"
                    })
                }
            }, r.EventDispatcher.prototype.apply(r.BufferGeometry.prototype), r.BufferGeometry.MaxIndex = 65535, r.InstancedBufferGeometry = function() {
                r.BufferGeometry.call(this), this.type = "InstancedBufferGeometry", this.maxInstancedCount = void 0
            }, r.InstancedBufferGeometry.prototype = Object.create(r.BufferGeometry.prototype), r.InstancedBufferGeometry.prototype.constructor = r.InstancedBufferGeometry, r.InstancedBufferGeometry.prototype.addGroup = function(e, t, i) {
                this.groups.push({
                    start: e,
                    count: t,
                    instances: i
                })
            }, r.InstancedBufferGeometry.prototype.copy = function(e) {
                var t = e.index;
                null !== t && this.setIndex(t.clone());
                var i = e.attributes;
                for (var r in i) {
                    var n = i[r];
                    this.addAttribute(r, n.clone())
                }
                for (var o = e.groups, a = 0, s = o.length; s > a; a++) {
                    var l = o[a];
                    this.addGroup(l.start, l.count, l.instances)
                }
                return this
            }, r.EventDispatcher.prototype.apply(r.InstancedBufferGeometry.prototype), r.Uniform = function(e, t) {
                this.type = e, this.value = t, this.dynamic = !1
            }, r.Uniform.prototype = {
                constructor: r.Uniform,
                onUpdate: function(e) {
                    return this.dynamic = !0, this.onUpdateCallback = e, this
                }
            }, r.AnimationClip = function(e, t, i) {
                this.name = e || r.Math.generateUUID(), this.tracks = i, this.duration = void 0 !== t ? t : -1, this.duration < 0 && this.resetDuration(), this.trim(), this.optimize()
            }, r.AnimationClip.prototype = {
                constructor: r.AnimationClip,
                resetDuration: function() {
                    for (var e = this.tracks, t = 0, i = 0, r = e.length; i !== r; ++i) {
                        var n = this.tracks[i];
                        t = Math.max(t, n.times[n.times.length - 1])
                    }
                    this.duration = t
                },
                trim: function() {
                    for (var e = 0; e < this.tracks.length; e++) this.tracks[e].trim(0, this.duration);
                    return this
                },
                optimize: function() {
                    for (var e = 0; e < this.tracks.length; e++) this.tracks[e].optimize();
                    return this
                }
            }, Object.assign(r.AnimationClip, {
                parse: function(e) {
                    for (var t = [], i = e.tracks, n = 1 / (e.fps || 1), o = 0, a = i.length; o !== a; ++o) t.push(r.KeyframeTrack.parse(i[o]).scale(n));
                    return new r.AnimationClip(e.name, e.duration, t)
                },
                toJSON: function(e) {
                    for (var t = [], i = e.tracks, n = {
                            name: e.name,
                            duration: e.duration,
                            tracks: t
                        }, o = 0, a = i.length; o !== a; ++o) t.push(r.KeyframeTrack.toJSON(i[o]));
                    return n
                },
                CreateFromMorphTargetSequence: function(e, t, i) {
                    for (var n = t.length, o = [], a = 0; n > a; a++) {
                        var s = [],
                            l = [];
                        s.push((a + n - 1) % n, a, (a + 1) % n), l.push(0, 1, 0);
                        var c = r.AnimationUtils.getKeyframeOrder(s);
                        s = r.AnimationUtils.sortedArray(s, 1, c), l = r.AnimationUtils.sortedArray(l, 1, c), 0 === s[0] && (s.push(n), l.push(l[0])), o.push(new r.NumberKeyframeTrack(".morphTargetInfluences[" + t[a].name + "]", s, l).scale(1 / i))
                    }
                    return new r.AnimationClip(e, -1, o)
                },
                findByName: function(e, t) {
                    for (var i = 0; i < e.length; i++)
                        if (e[i].name === t) return e[i];
                    return null
                },
                CreateClipsFromMorphTargetSequences: function(e, t) {
                    for (var i = {}, n = /^([\w-]*?)([\d]+)$/, o = 0, a = e.length; a > o; o++) {
                        var s = e[o],
                            l = s.name.match(n);
                        if (l && l.length > 1) {
                            var c = l[1],
                                h = i[c];
                            h || (i[c] = h = []), h.push(s)
                        }
                    }
                    var u = [];
                    for (var c in i) u.push(r.AnimationClip.CreateFromMorphTargetSequence(c, i[c], t));
                    return u
                },
                parseAnimation: function(e, t, i) {
                    if (!e) return console.error("  no animation in JSONLoader data"), null;
                    for (var n = function(e, t, i, n, o) {
                            if (0 !== i.length) {
                                var a = [],
                                    s = [];
                                r.AnimationUtils.flattenJSON(i, a, s, n), 0 !== a.length && o.push(new e(t, a, s))
                            }
                        }, o = [], a = e.name || "default", s = e.length || -1, l = e.fps || 30, c = e.hierarchy || [], h = 0; h < c.length; h++) {
                        var u = c[h].keys;
                        if (u && 0 != u.length)
                            if (u[0].morphTargets) {
                                for (var p = {}, f = 0; f < u.length; f++)
                                    if (u[f].morphTargets)
                                        for (var d = 0; d < u[f].morphTargets.length; d++) p[u[f].morphTargets[d]] = -1;
                                for (var m in p) {
                                    for (var g = [], v = [], d = 0; d !== u[f].morphTargets.length; ++d) {
                                        var y = u[f];
                                        g.push(y.time), v.push(y.morphTarget === m ? 1 : 0)
                                    }
                                    o.push(new r.NumberKeyframeTrack(".morphTargetInfluence[" + m + "]", g, v))
                                }
                                s = p.length * (l || 1)
                            } else {
                                var _ = ".bones[" + t[h].name + "]";
                                n(r.VectorKeyframeTrack, _ + ".position", u, "pos", o), n(r.QuaternionKeyframeTrack, _ + ".quaternion", u, "rot", o), n(r.VectorKeyframeTrack, _ + ".scale", u, "scl", o)
                            }
                    }
                    if (0 === o.length) return null;
                    var x = new r.AnimationClip(a, s, o);
                    return x
                }
            }), r.AnimationMixer = function(e) {
                this._root = e, this._initMemoryManager(), this._accuIndex = 0, this.time = 0, this.timeScale = 1
            }, r.AnimationMixer.prototype = {
                constructor: r.AnimationMixer,
                clipAction: function(e, t) {
                    var i, n = t || this._root,
                        o = n.uuid,
                        a = "string" == typeof e ? e : e.name,
                        s = e !== a ? e : null,
                        l = this._actionsByClip[a];
                    if (void 0 !== l) {
                        var c = l.actionByRoot[o];
                        if (void 0 !== c) return c;
                        if (i = l.knownActions[0], s = i._clip, e !== a && e !== s) throw new Error("Different clips with the same name detected!")
                    }
                    if (null === s) return null;
                    var h = new r.AnimationMixer._Action(this, s, t);
                    return this._bindAction(h, i), this._addInactiveAction(h, a, o), h
                },
                existingAction: function(e, t) {
                    var i = t || this._root,
                        r = i.uuid,
                        n = "string" == typeof e ? e : e.name,
                        o = this._actionsByClip[n];
                    return void 0 !== o ? o.actionByRoot[r] || null : null
                },
                stopAllAction: function() {
                    var e = this._actions,
                        t = this._nActiveActions,
                        i = this._bindings,
                        r = this._nActiveBindings;
                    this._nActiveActions = 0, this._nActiveBindings = 0;
                    for (var n = 0; n !== t; ++n) e[n].reset();
                    for (var n = 0; n !== r; ++n) i[n].useCount = 0;
                    return this
                },
                update: function(e) {
                    e *= this.timeScale;
                    for (var t = this._actions, i = this._nActiveActions, r = this.time += e, n = Math.sign(e), o = this._accuIndex ^= 1, a = 0; a !== i; ++a) {
                        var s = t[a];
                        s.enabled && s._update(r, e, n, o)
                    }
                    for (var l = this._bindings, c = this._nActiveBindings, a = 0; a !== c; ++a) l[a].apply(o);
                    return this
                },
                getRoot: function() {
                    return this._root
                },
                uncacheClip: function(e) {
                    var t = this._actions,
                        i = e.name,
                        r = this._actionsByClip,
                        n = r[i];
                    if (void 0 !== n) {
                        for (var o = n.knownActions, a = 0, s = o.length; a !== s; ++a) {
                            var l = o[a];
                            this._deactivateAction(l);
                            var c = l._cacheIndex,
                                h = t[t.length - 1];
                            l._cacheIndex = null, l._byClipCacheIndex = null, h._cacheIndex = c, t[c] = h, t.pop(), this._removeInactiveBindingsForAction(l)
                        }
                        delete r[i]
                    }
                },
                uncacheRoot: function(e) {
                    var t = e.uuid,
                        i = this._actionsByClip;
                    for (var r in i) {
                        var n = i[r].actionByRoot,
                            o = n[t];
                        void 0 !== o && (this._deactivateAction(o), this._removeInactiveAction(o))
                    }
                    var a = this._bindingsByRootAndName,
                        s = a[t];
                    if (void 0 !== s)
                        for (var l in s) {
                            var c = s[l];
                            c.restoreOriginalState(), this._removeInactiveBinding(c)
                        }
                },
                uncacheAction: function(e, t) {
                    var i = this.existingAction(e, t);
                    null !== i && (this._deactivateAction(i), this._removeInactiveAction(i))
                }
            }, r.EventDispatcher.prototype.apply(r.AnimationMixer.prototype), r.AnimationMixer._Action = function(e, t, i) {
                this._mixer = e, this._clip = t, this._localRoot = i || null;
                for (var n = t.tracks, o = n.length, a = new Array(o), s = {
                        endingStart: r.ZeroCurvatureEnding,
                        endingEnd: r.ZeroCurvatureEnding
                    }, l = 0; l !== o; ++l) {
                    var c = n[l].createInterpolant(null);
                    a[l] = c, c.settings = s
                }
                this._interpolantSettings = s, this._interpolants = a, this._propertyBindings = new Array(o), this._cacheIndex = null, this._byClipCacheIndex = null, this._timeScaleInterpolant = null, this._weightInterpolant = null, this.loop = r.LoopRepeat, this._loopCount = -1, this._startTime = null, this.time = 0, this.timeScale = 1, this._effectiveTimeScale = 1, this.weight = 1, this._effectiveWeight = 1, this.repetitions = 1 / 0, this.paused = !1, this.enabled = !0, this.clampWhenFinished = !1, this.zeroSlopeAtStart = !0, this.zeroSlopeAtEnd = !0
            }, r.AnimationMixer._Action.prototype = {
                constructor: r.AnimationMixer._Action,
                play: function() {
                    return this._mixer._activateAction(this), this
                },
                stop: function() {
                    return this._mixer._deactivateAction(this), this.reset()
                },
                reset: function() {
                    return this.paused = !1, this.enabled = !0, this.time = 0, this._loopCount = -1, this._startTime = null, this.stopFading().stopWarping()
                },
                isRunning: function() {
                    this._startTime;
                    return this.enabled && !this.paused && 0 !== this.timeScale && null === this._startTime && this._mixer._isActiveAction(this)
                },
                isScheduled: function() {
                    return this._mixer._isActiveAction(this)
                },
                startAt: function(e) {
                    return this._startTime = e, this
                },
                setLoop: function(e, t) {
                    return this.loop = e, this.repetitions = t, this
                },
                setEffectiveWeight: function(e) {
                    return this.weight = e, this._effectiveWeight = this.enabled ? e : 0, this.stopFading()
                },
                getEffectiveWeight: function() {
                    return this._effectiveWeight
                },
                fadeIn: function(e) {
                    return this._scheduleFading(e, 0, 1)
                },
                fadeOut: function(e) {
                    return this._scheduleFading(e, 1, 0)
                },
                crossFadeFrom: function(e, t, i) {
                    this._mixer;
                    if (e.fadeOut(t), this.fadeIn(t), i) {
                        var r = this._clip.duration,
                            n = e._clip.duration,
                            o = n / r,
                            a = r / n;
                        e.warp(1, o, t), this.warp(a, 1, t)
                    }
                    return this
                },
                crossFadeTo: function(e, t, i) {
                    return e.crossFadeFrom(this, t, i)
                },
                stopFading: function() {
                    var e = this._weightInterpolant;
                    return null !== e && (this._weightInterpolant = null, this._mixer._takeBackControlInterpolant(e)), this
                },
                setEffectiveTimeScale: function(e) {
                    return this.timeScale = e, this._effectiveTimeScale = this.paused ? 0 : e, this.stopWarping()
                },
                getEffectiveTimeScale: function() {
                    return this._effectiveTimeScale
                },
                setDuration: function(e) {
                    return this.timeScale = this._clip.duration / e, this.stopWarping()
                },
                syncWith: function(e) {
                    return this.time = e.time, this.timeScale = e.timeScale, this.stopWarping()
                },
                halt: function(e) {
                    return this.warp(this._currentTimeScale, 0, e)
                },
                warp: function(e, t, i) {
                    var r = this._mixer,
                        n = r.time,
                        o = this._timeScaleInterpolant,
                        a = this.timeScale;
                    null === o && (o = r._lendControlInterpolant(), this._timeScaleInterpolant = o);
                    var s = o.parameterPositions,
                        l = o.sampleValues;
                    return s[0] = n, s[1] = n + i, l[0] = e / a, l[1] = t / a, this
                },
                stopWarping: function() {
                    var e = this._timeScaleInterpolant;
                    return null !== e && (this._timeScaleInterpolant = null, this._mixer._takeBackControlInterpolant(e)), this
                },
                getMixer: function() {
                    return this._mixer
                },
                getClip: function() {
                    return this._clip
                },
                getRoot: function() {
                    return this._localRoot || this._mixer._root
                },
                _update: function(e, t, i, r) {
                    var n = this._startTime;
                    if (null !== n) {
                        var o = (e - n) * i;
                        if (0 > o || 0 === i) return;
                        this._startTime = null, t = i * o
                    }
                    t *= this._updateTimeScale(e);
                    var a = this._updateTime(t),
                        s = this._updateWeight(e);
                    if (s > 0)
                        for (var l = this._interpolants, c = this._propertyBindings, h = 0, u = l.length; h !== u; ++h) l[h].evaluate(a), c[h].accumulate(r, s)
                },
                _updateWeight: function(e) {
                    var t = 0;
                    if (this.enabled) {
                        t = this.weight;
                        var i = this._weightInterpolant;
                        if (null !== i) {
                            var r = i.evaluate(e)[0];
                            t *= r, e > i.parameterPositions[1] && (this.stopFading(), 0 === r && (this.enabled = !1))
                        }
                    }
                    return this._effectiveWeight = t, t
                },
                _updateTimeScale: function(e) {
                    var t = 0;
                    if (!this.paused) {
                        t = this.timeScale;
                        var i = this._timeScaleInterpolant;
                        if (null !== i) {
                            var r = i.evaluate(e)[0];
                            t *= r, e > i.parameterPositions[1] && (this.stopWarping(), 0 === t ? this.pause = !0 : this.timeScale = t)
                        }
                    }
                    return this._effectiveTimeScale = t, t
                },
                _updateTime: function(e) {
                    var t = this.time + e;
                    if (0 === e) return t;
                    var i = this._clip.duration,
                        n = this.loop,
                        o = this._loopCount,
                        a = !1;
                    switch (n) {
                        case r.LoopOnce:
                            if (-1 === o && (this.loopCount = 0, this._setEndings(!0, !0, !1)), t >= i) t = i;
                            else {
                                if (!(0 > t)) break;
                                t = 0
                            }
                            this.clampWhenFinished ? this.pause = !0 : this.enabled = !1, this._mixer.dispatchEvent({
                                type: "finished",
                                action: this,
                                direction: 0 > e ? -1 : 1
                            });
                            break;
                        case r.LoopPingPong:
                            a = !0;
                        case r.LoopRepeat:
                            if (-1 === o && (e > 0 ? (o = 0, this._setEndings(!0, 0 === this.repetitions, a)) : this._setEndings(0 === this.repetitions, !0, a)), t >= i || 0 > t) {
                                var s = Math.floor(t / i);
                                t -= i * s, o += Math.abs(s);
                                var l = this.repetitions - o;
                                if (0 > l) {
                                    this.clampWhenFinished ? this.paused = !0 : this.enabled = !1, t = e > 0 ? i : 0, this._mixer.dispatchEvent({
                                        type: "finished",
                                        action: this,
                                        direction: e > 0 ? 1 : -1
                                    });
                                    break
                                }
                                if (0 === l) {
                                    var c = 0 > e;
                                    this._setEndings(c, !c, a)
                                } else this._setEndings(!1, !1, a);
                                this._loopCount = o, this._mixer.dispatchEvent({
                                    type: "loop",
                                    action: this,
                                    loopDelta: s
                                })
                            }
                            if (n === r.LoopPingPong && 1 === (1 & o)) return this.time = t, i - t
                    }
                    return this.time = t, t
                },
                _setEndings: function(e, t, i) {
                    var n = this._interpolantSettings;
                    i ? (n.endingStart = r.ZeroSlopeEnding, n.endingEnd = r.ZeroSlopeEnding) : (e ? n.endingStart = this.zeroSlopeAtStart ? r.ZeroSlopeEnding : r.ZeroCurvatureEnding : n.endingStart = r.WrapAroundEnding, t ? n.endingEnd = this.zeroSlopeAtEnd ? r.ZeroSlopeEnding : r.ZeroCurvatureEnding : n.endingEnd = r.WrapAroundEnding)
                },
                _scheduleFading: function(e, t, i) {
                    var r = this._mixer,
                        n = r.time,
                        o = this._weightInterpolant;
                    null === o && (o = r._lendControlInterpolant(), this._weightInterpolant = o);
                    var a = o.parameterPositions,
                        s = o.sampleValues;
                    return a[0] = n, s[0] = t, a[1] = n + e, s[1] = i, this
                }
            }, Object.assign(r.AnimationMixer.prototype, {
                _bindAction: function(e, t) {
                    var i = e._localRoot || this._root,
                        n = e._clip.tracks,
                        o = n.length,
                        a = e._propertyBindings,
                        s = e._interpolants,
                        l = i.uuid,
                        c = this._bindingsByRootAndName,
                        h = c[l];
                    void 0 === h && (h = {}, c[l] = h);
                    for (var u = 0; u !== o; ++u) {
                        var p = n[u],
                            f = p.name,
                            d = h[f];
                        if (void 0 !== d) a[u] = d;
                        else {
                            if (d = a[u], void 0 !== d) {
                                null === d._cacheIndex && (++d.referenceCount, this._addInactiveBinding(d, l, f));
                                continue
                            }
                            var m = t && t._propertyBindings[u].binding.parsedPath;
                            d = new r.PropertyMixer(r.PropertyBinding.create(i, f, m), p.ValueTypeName, p.getValueSize()), ++d.referenceCount, this._addInactiveBinding(d, l, f), a[u] = d
                        }
                        s[u].resultBuffer = d.buffer
                    }
                },
                _activateAction: function(e) {
                    if (!this._isActiveAction(e)) {
                        if (null === e._cacheIndex) {
                            var t = (e._localRoot || this._root).uuid,
                                i = e._clip.name,
                                r = this._actionsByClip[i];
                            this._bindAction(e, r && r.knownActions[0]), this._addInactiveAction(e, i, t)
                        }
                        for (var n = e._propertyBindings, o = 0, a = n.length; o !== a; ++o) {
                            var s = n[o];
                            0 === s.useCount++ && (this._lendBinding(s), s.saveOriginalState())
                        }
                        this._lendAction(e)
                    }
                },
                _deactivateAction: function(e) {
                    if (this._isActiveAction(e)) {
                        for (var t = e._propertyBindings, i = 0, r = t.length; i !== r; ++i) {
                            var n = t[i];
                            0 === --n.useCount && (n.restoreOriginalState(), this._takeBackBinding(n))
                        }
                        this._takeBackAction(e)
                    }
                },
                _initMemoryManager: function() {
                    this._actions = [], this._nActiveActions = 0, this._actionsByClip = {}, this._bindings = [], this._nActiveBindings = 0, this._bindingsByRootAndName = {}, this._controlInterpolants = [], this._nActiveControlInterpolants = 0;
                    var e = this;
                    this.stats = {
                        actions: {get total() {
                                return e._actions.length
                            },
                            get inUse() {
                                return e._nActiveActions
                            }
                        },
                        bindings: {get total() {
                                return e._bindings.length
                            },
                            get inUse() {
                                return e._nActiveBindings
                            }
                        },
                        controlInterpolants: {get total() {
                                return e._controlInterpolants.length
                            },
                            get inUse() {
                                return e._nActiveControlInterpolants
                            }
                        }
                    }
                },
                _isActiveAction: function(e) {
                    var t = e._cacheIndex;
                    return null !== t && t < this._nActiveActions
                },
                _addInactiveAction: function(e, t, i) {
                    var r = this._actions,
                        n = this._actionsByClip,
                        o = n[t];
                    if (void 0 === o) o = {
                        knownActions: [e],
                        actionByRoot: {}
                    }, e._byClipCacheIndex = 0, n[t] = o;
                    else {
                        var a = o.knownActions;
                        e._byClipCacheIndex = a.length, a.push(e)
                    }
                    e._cacheIndex = r.length, r.push(e), o.actionByRoot[i] = e
                },
                _removeInactiveAction: function(e) {
                    var t = this._actions,
                        i = t[t.length - 1],
                        r = e._cacheIndex;
                    i._cacheIndex = r, t[r] = i, t.pop(), e._cacheIndex = null;
                    var n = e._clip.name,
                        o = this._actionsByClip,
                        a = o[n],
                        s = a.knownActions,
                        l = s[s.length - 1],
                        c = e._byClipCacheIndex;
                    l._byClipCacheIndex = c, s[c] = l, s.pop(), e._byClipCacheIndex = null;
                    var h = a.actionByRoot,
                        u = (t._localRoot || this._root).uuid;
                    delete h[u], 0 === s.length && delete o[n], this._removeInactiveBindingsForAction(e)
                },
                _removeInactiveBindingsForAction: function(e) {
                    for (var t = e._propertyBindings, i = 0, r = t.length; i !== r; ++i) {
                        var n = t[i];
                        0 === --n.referenceCount && this._removeInactiveBinding(n)
                    }
                },
                _lendAction: function(e) {
                    var t = this._actions,
                        i = e._cacheIndex,
                        r = this._nActiveActions++,
                        n = t[r];
                    e._cacheIndex = r, t[r] = e, n._cacheIndex = i, t[i] = n
                },
                _takeBackAction: function(e) {
                    var t = this._actions,
                        i = e._cacheIndex,
                        r = --this._nActiveActions,
                        n = t[r];
                    e._cacheIndex = r, t[r] = e, n._cacheIndex = i, t[i] = n
                },
                _addInactiveBinding: function(e, t, i) {
                    var r = this._bindingsByRootAndName,
                        n = r[t],
                        o = this._bindings;
                    void 0 === n && (n = {}, r[t] = n), n[i] = e, e._cacheIndex = o.length, o.push(e)
                },
                _removeInactiveBinding: function(e) {
                    var t = this._bindings,
                        i = e.binding,
                        r = i.rootNode.uuid,
                        n = i.path,
                        o = this._bindingsByRootAndName,
                        a = o[r],
                        s = t[t.length - 1],
                        l = e._cacheIndex;
                    s._cacheIndex = l, t[l] = s, t.pop(), delete a[n];
                    e: {
                        for (var c in a) break e;
                        delete o[r]
                    }
                },
                _lendBinding: function(e) {
                    var t = this._bindings,
                        i = e._cacheIndex,
                        r = this._nActiveBindings++,
                        n = t[r];
                    e._cacheIndex = r, t[r] = e, n._cacheIndex = i, t[i] = n
                },
                _takeBackBinding: function(e) {
                    var t = this._bindings,
                        i = e._cacheIndex,
                        r = --this._nActiveBindings,
                        n = t[r];
                    e._cacheIndex = r, t[r] = e, n._cacheIndex = i, t[i] = n
                },
                _lendControlInterpolant: function() {
                    var e = this._controlInterpolants,
                        t = this._nActiveControlInterpolants++,
                        i = e[t];
                    return void 0 === i && (i = new r.LinearInterpolant(new Float32Array(2), new Float32Array(2), 1, this._controlInterpolantsResultBuffer), i.__cacheIndex = t, e[t] = i), i
                },
                _takeBackControlInterpolant: function(e) {
                    var t = this._controlInterpolants,
                        i = e.__cacheIndex,
                        r = --this._nActiveControlInterpolants,
                        n = t[r];
                    e.__cacheIndex = r, t[r] = e, n.__cacheIndex = i, t[i] = n
                },
                _controlInterpolantsResultBuffer: new Float32Array(1)
            }), r.AnimationObjectGroup = function(e) {
                this.uuid = r.Math.generateUUID(), this._objects = Array.prototype.slice.call(arguments), this.nCachedObjects_ = 0;
                var t = {};
                this._indicesByUUID = t;
                for (var i = 0, n = arguments.length; i !== n; ++i) t[arguments[i].uuid] = i;
                this._paths = [], this._parsedPaths = [], this._bindings = [], this._bindingsIndicesByPath = {};
                var o = this;
                this.stats = {
                    objects: {get total() {
                            return o._objects.length
                        },
                        get inUse() {
                            return this.total - o.nCachedObjects_
                        }
                    },
                    get bindingsPerObject() {
                        return o._bindings.length
                    }
                }
            }, r.AnimationObjectGroup.prototype = {
                constructor: r.AnimationObjectGroup,
                add: function(e) {
                    for (var t = this._objects, i = t.length, n = this.nCachedObjects_, o = this._indicesByUUID, a = this._paths, s = this._parsedPaths, l = this._bindings, c = l.length, h = 0, u = arguments.length; h !== u; ++h) {
                        var p = arguments[h],
                            f = p.uuid,
                            d = o[f];
                        if (void 0 === d) {
                            d = i++, o[f] = d, t.push(p);
                            for (var m = 0, g = c; m !== g; ++m) l[m].push(new r.PropertyBinding(p, a[m], s[m]))
                        } else if (n > d) {
                            var v = t[d],
                                y = --n,
                                _ = t[y];
                            o[_.uuid] = d, t[d] = _, o[f] = y, t[y] = p;
                            for (var m = 0, g = c; m !== g; ++m) {
                                var x = l[m],
                                    b = x[y],
                                    w = x[d];
                                x[d] = b, void 0 === w && (w = new r.PropertyBinding(p, a[m], s[m])), x[y] = w
                            }
                        } else t[d] !== v && console.error("Different objects with the same UUID detected. Clean the caches or recreate your infrastructure when reloading scenes...")
                    }
                    this.nCachedObjects_ = n
                },
                remove: function(e) {
                    for (var t = this._objects, i = (t.length, this.nCachedObjects_), r = this._indicesByUUID, n = this._bindings, o = n.length, a = 0, s = arguments.length; a !== s; ++a) {
                        var l = arguments[a],
                            c = l.uuid,
                            h = r[c];
                        if (void 0 !== h && h >= i) {
                            var u = i++,
                                p = t[u];
                            r[p.uuid] = h, t[h] = p, r[c] = u, t[u] = l;
                            for (var f = 0, d = o; f !== d; ++f) {
                                var m = n[f],
                                    g = m[u],
                                    v = m[h];
                                m[h] = g, m[u] = v
                            }
                        }
                    }
                    this.nCachedObjects_ = i
                },
                uncache: function(e) {
                    for (var t = this._objects, i = t.length, r = this.nCachedObjects_, n = this._indicesByUUID, o = this._bindings, a = o.length, s = 0, l = arguments.length; s !== l; ++s) {
                        var c = arguments[s],
                            h = c.uuid,
                            u = n[h];
                        if (void 0 !== u)
                            if (delete n[h], r > u) {
                                var p = --r,
                                    f = t[p],
                                    d = --i,
                                    m = t[d];
                                n[f.uuid] = u, t[u] = f, n[m.uuid] = p, t[p] = m, t.pop();
                                for (var g = 0, v = a; g !== v; ++g) {
                                    var y = o[g],
                                        _ = y[p],
                                        x = y[d];
                                    y[u] = _, y[p] = x, y.pop()
                                }
                            } else {
                                var d = --i,
                                    m = t[d];
                                n[m.uuid] = u, t[u] = m, t.pop();
                                for (var g = 0, v = a; g !== v; ++g) {
                                    var y = o[g];
                                    y[u] = y[d], y.pop()
                                }
                            }
                    }
                    this.nCachedObjects_ = r
                },
                subscribe_: function(e, t) {
                    var i = this._bindingsIndicesByPath,
                        n = i[e],
                        o = this._bindings;
                    if (void 0 !== n) return o[n];
                    var a = this._paths,
                        s = this._parsedPaths,
                        l = this._objects,
                        c = l.length,
                        h = this.nCachedObjects_,
                        u = new Array(c);
                    n = o.length, i[e] = n, a.push(e), s.push(t), o.push(u);
                    for (var p = h, f = l.length; p !== f; ++p) {
                        var d = l[p];
                        u[p] = new r.PropertyBinding(d, e, t)
                    }
                    return u
                },
                unsubscribe_: function(e) {
                    var t = this._bindingsIndicesByPath,
                        i = t[e];
                    if (void 0 !== i) {
                        var r = this._paths,
                            n = this._parsedPaths,
                            o = this._bindings,
                            a = o.length - 1,
                            s = o[a],
                            l = e[a];
                        t[l] = i, o[i] = s, o.pop(), n[i] = n[a], n.pop(), r[i] = r[a], r.pop()
                    }
                }
            }, r.AnimationUtils = {
                arraySlice: function(e, t, i) {
                    return r.AnimationUtils.isTypedArray(e) ? new e.constructor(e.subarray(t, i)) : e.slice(t, i)
                },
                convertArray: function(e, t, i) {
                    return !e || !i && e.constructor === t ? e : "number" == typeof t.BYTES_PER_ELEMENT ? new t(e) : Array.prototype.slice.call(e)
                },
                isTypedArray: function(e) {
                    return ArrayBuffer.isView(e) && !(e instanceof DataView)
                },
                getKeyframeOrder: function(e) {
                    function t(t, i) {
                        return e[t] - e[i]
                    }
                    for (var i = e.length, r = new Array(i), n = 0; n !== i; ++n) r[n] = n;
                    return r.sort(t), r
                },
                sortedArray: function(e, t, i) {
                    for (var r = e.length, n = new e.constructor(r), o = 0, a = 0; a !== r; ++o)
                        for (var s = i[o] * t, l = 0; l !== t; ++l) n[a++] = e[s + l];
                    return n
                },
                flattenJSON: function(e, t, i, r) {
                    for (var n = 1, o = e[0]; void 0 !== o && void 0 === o[r];) o = e[n++];
                    if (void 0 !== o) {
                        var a = o[r];
                        if (void 0 !== a)
                            if (Array.isArray(a)) {
                                do a = o[r], void 0 !== a && (t.push(o.time), i.push.apply(i, a)), o = e[n++]; while (void 0 !== o)
                            } else if (void 0 !== a.toArray) {
                            do a = o[r], void 0 !== a && (t.push(o.time), a.toArray(i, i.length)), o = e[n++]; while (void 0 !== o)
                        } else
                            do a = o[r], void 0 !== a && (t.push(o.time), i.push(a)), o = e[n++]; while (void 0 !== o)
                    }
                }
            }, r.KeyframeTrack = function(e, t, i, n) {
                if (void 0 === e) throw new Error("track name is undefined");
                if (void 0 === t || 0 === t.length) throw new Error("no keyframes in track named " + e);
                this.name = e, this.times = r.AnimationUtils.convertArray(t, this.TimeBufferType), this.values = r.AnimationUtils.convertArray(i, this.ValueBufferType), this.setInterpolation(n || this.DefaultInterpolation), this.validate(), this.optimize()
            }, r.KeyframeTrack.prototype = {
                constructor: r.KeyframeTrack,
                TimeBufferType: Float32Array,
                ValueBufferType: Float32Array,
                DefaultInterpolation: r.InterpolateLinear,
                InterpolantFactoryMethodDiscrete: function(e) {
                    return new r.DiscreteInterpolant(this.times, this.values, this.getValueSize(), e)
                },
                InterpolantFactoryMethodLinear: function(e) {
                    return new r.LinearInterpolant(this.times, this.values, this.getValueSize(), e)
                },
                InterpolantFactoryMethodSmooth: function(e) {
                    return new r.CubicInterpolant(this.times, this.values, this.getValueSize(), e)
                },
                setInterpolation: function(e) {
                    var t = void 0;
                    switch (e) {
                        case r.InterpolateDiscrete:
                            t = this.InterpolantFactoryMethodDiscrete;
                            break;
                        case r.InterpolateLinear:
                            t = this.InterpolantFactoryMethodLinear;
                            break;
                        case r.InterpolateSmooth:
                            t = this.InterpolantFactoryMethodSmooth
                    }
                    if (void 0 === t) {
                        var i = "unsupported interpolation for " + this.ValueTypeName + " keyframe track named " + this.name;
                        if (void 0 === this.createInterpolant) {
                            if (e === this.DefaultInterpolation) throw new Error(i);
                            this.setInterpolation(this.DefaultInterpolation)
                        }
                        return void console.warn(i)
                    }
                    this.createInterpolant = t
                },
                getInterpolation: function() {
                    switch (this.createInterpolant) {
                        case this.InterpolantFactoryMethodDiscrete:
                            return r.InterpolateDiscrete;
                        case this.InterpolantFactoryMethodLinear:
                            return r.InterpolateLinear;
                        case this.InterpolantFactoryMethodSmooth:
                            return r.InterpolateSmooth
                    }
                },
                getValueSize: function() {
                    return this.values.length / this.times.length
                },
                shift: function(e) {
                    if (0 !== e)
                        for (var t = this.times, i = 0, r = t.length; i !== r; ++i) t[i] += e;
                    return this
                },
                scale: function(e) {
                    if (1 !== e)
                        for (var t = this.times, i = 0, r = t.length; i !== r; ++i) t[i] *= e;
                    return this
                },
                trim: function(e, t) {
                    for (var i = this.times, n = i.length, o = 0, a = n - 1; o !== n && i[o] < e;) ++o;
                    for (; - 1 !== a && i[a] > t;) --a;
                    if (++a, 0 !== o || a !== n) {
                        o >= a && (a = Math.max(a, 1), o = a - 1);
                        var s = this.getValueSize();
                        this.times = r.AnimationUtils.arraySlice(i, o, a), this.values = r.AnimationUtils.arraySlice(this.values, o * s, a * s)
                    }
                    return this
                },
                validate: function() {
                    var e = !0,
                        t = this.getValueSize();
                    t - Math.floor(t) !== 0 && (console.error("invalid value size in track", this), e = !1);
                    var i = this.times,
                        n = this.values,
                        o = i.length;
                    0 === o && (console.error("track is empty", this), e = !1);
                    for (var a = null, s = 0; s !== o; s++) {
                        var l = i[s];
                        if ("number" == typeof l && isNaN(l)) {
                            console.error("time is not a valid number", this, s, l), e = !1;
                            break
                        }
                        if (null !== a && a > l) {
                            console.error("out of order keys", this, s, l, a), e = !1;
                            break
                        }
                        a = l
                    }
                    if (void 0 !== n && r.AnimationUtils.isTypedArray(n))
                        for (var s = 0, c = n.length; s !== c; ++s) {
                            var h = n[s];
                            if (isNaN(h)) {
                                console.error("value is not a valid number", this, s, h), e = !1;
                                break
                            }
                        }
                    return e
                },
                optimize: function() {
                    for (var e = this.times, t = this.values, i = this.getValueSize(), n = 1, o = 1, a = e.length - 1; a >= o; ++o) {
                        var s = !1,
                            l = e[o],
                            c = e[o + 1];
                        if (l !== c && (1 !== o || l !== l[0]))
                            for (var h = o * i, u = h - i, p = h + i, f = 0; f !== i; ++f) {
                                var d = t[h + f];
                                if (d !== t[u + f] || d !== t[p + f]) {
                                    s = !0;
                                    break
                                }
                            }
                        if (s) {
                            if (o !== n) {
                                e[n] = e[o];
                                for (var m = o * i, g = n * i, f = 0; f !== i; ++f) t[g + f] = t[m + f]
                            }++n
                        }
                    }
                    return n !== e.length && (this.times = r.AnimationUtils.arraySlice(e, 0, n), this.values = r.AnimationUtils.arraySlice(t, 0, n * i)), this
                }
            }, Object.assign(r.KeyframeTrack, {
                parse: function(e) {
                    if (void 0 === e.type) throw new Error("track type undefined, can not parse");
                    var t = r.KeyframeTrack._getTrackTypeForValueTypeName(e.type);
                    if (void 0 === e.times) {
                        console.warn("legacy JSON format detected, converting");
                        var i = [],
                            n = [];
                        r.AnimationUtils.flattenJSON(e.keys, i, n, "value"), e.times = i, e.values = n
                    }
                    return void 0 !== t.parse ? t.parse(e) : new t(e.name, e.times, e.values, e.interpolation)
                },
                toJSON: function(e) {
                    var t, i = e.constructor;
                    if (void 0 !== i.toJSON) t = i.toJSON(e);
                    else {
                        t = {
                            name: e.name,
                            times: r.AnimationUtils.convertArray(e.times, Array),
                            values: r.AnimationUtils.convertArray(e.values, Array)
                        };
                        var n = e.getInterpolation();
                        n !== e.DefaultInterpolation && (t.interpolation = n)
                    }
                    return t.type = e.ValueTypeName, t
                },
                _getTrackTypeForValueTypeName: function(e) {
                    switch (e.toLowerCase()) {
                        case "scalar":
                        case "double":
                        case "float":
                        case "number":
                        case "integer":
                            return r.NumberKeyframeTrack;
                        case "vector":
                        case "vector2":
                        case "vector3":
                        case "vector4":
                            return r.VectorKeyframeTrack;
                        case "color":
                            return r.ColorKeyframeTrack;
                        case "quaternion":
                            return r.QuaternionKeyframeTrack;
                        case "bool":
                        case "boolean":
                            return r.BooleanKeyframeTrack;
                        case "string":
                            return r.StringKeyframeTrack
                    }
                    throw new Error("Unsupported typeName: " + e)
                }
            }), r.PropertyBinding = function(e, t, i) {
                this.path = t, this.parsedPath = i || r.PropertyBinding.parseTrackName(t), this.node = r.PropertyBinding.findNode(e, this.parsedPath.nodeName) || e, this.rootNode = e
            }, r.PropertyBinding.prototype = {
                constructor: r.PropertyBinding,
                getValue: function(e, t) {
                    this.bind(), this.getValue(e, t)
                },
                setValue: function(e, t) {
                    this.bind(), this.setValue(e, t)
                },
                bind: function() {
                    var e = this.node,
                        t = this.parsedPath,
                        i = t.objectName,
                        n = t.propertyName,
                        o = t.propertyIndex;
                    if (e || (e = r.PropertyBinding.findNode(this.rootNode, t.nodeName) || this.rootNode, this.node = e), this.getValue = this._getValue_unavailable, this.setValue = this._setValue_unavailable, !e) return void console.error("  trying to update node for track: " + this.path + " but it wasn't found.");
                    if (i) {
                        var a = t.objectIndex;
                        switch (i) {
                            case "materials":
                                if (!e.material) return void console.error("  can not bind to material as node does not have a material", this);
                                if (!e.material.materials) return void console.error("  can not bind to material.materials as node.material does not have a materials array", this);
                                e = e.material.materials;
                                break;
                            case "bones":
                                if (!e.skeleton) return void console.error("  can not bind to bones as node does not have a skeleton", this);
                                e = e.skeleton.bones;
                                for (var s = 0; s < e.length; s++)
                                    if (e[s].name === a) {
                                        a = s;
                                        break
                                    }
                                break;
                            default:
                                if (void 0 === e[i]) return void console.error("  can not bind to objectName of node, undefined", this);
                                e = e[i]
                        }
                        if (void 0 !== a) {
                            if (void 0 === e[a]) return void console.error("  trying to bind to objectIndex of objectName, but is undefined:", this, e);
                            e = e[a]
                        }
                    }
                    var l = e[n];
                    if (!l) {
                        var c = t.nodeName;
                        return void console.error("  trying to update property for track: " + c + "." + n + " but it wasn't found.", e)
                    }
                    var h = this.Versioning.None;
                    void 0 !== e.needsUpdate ? (h = this.Versioning.NeedsUpdate, this.targetObject = e) : void 0 !== e.matrixWorldNeedsUpdate && (h = this.Versioning.MatrixWorldNeedsUpdate, this.targetObject = e);
                    var u = this.BindingType.Direct;
                    if (void 0 !== o) {
                        if ("morphTargetInfluences" === n) {
                            if (!e.geometry) return void console.error("  can not bind to morphTargetInfluences becasuse node does not have a geometry", this);
                            if (!e.geometry.morphTargets) return void console.error("  can not bind to morphTargetInfluences becasuse node does not have a geometry.morphTargets", this);
                            for (var s = 0; s < this.node.geometry.morphTargets.length; s++)
                                if (e.geometry.morphTargets[s].name === o) {
                                    o = s;
                                    break
                                }
                        }
                        u = this.BindingType.ArrayElement, this.resolvedProperty = l, this.propertyIndex = o
                    } else void 0 !== l.fromArray && void 0 !== l.toArray ? (u = this.BindingType.HasFromToArray, this.resolvedProperty = l) : void 0 !== l.length ? (u = this.BindingType.EntireArray, this.resolvedProperty = l) : this.propertyName = n;
                    this.getValue = this.GetterByBindingType[u], this.setValue = this.SetterByBindingTypeAndVersioning[u][h]
                },
                unbind: function() {
                    this.node = null, this.getValue = this._getValue_unbound, this.setValue = this._setValue_unbound
                }
            }, Object.assign(r.PropertyBinding.prototype, {
                _getValue_unavailable: function() {},
                _setValue_unavailable: function() {},
                _getValue_unbound: r.PropertyBinding.prototype.getValue,
                _setValue_unbound: r.PropertyBinding.prototype.setValue,
                BindingType: {
                    Direct: 0,
                    EntireArray: 1,
                    ArrayElement: 2,
                    HasFromToArray: 3
                },
                Versioning: {
                    None: 0,
                    NeedsUpdate: 1,
                    MatrixWorldNeedsUpdate: 2
                },
                GetterByBindingType: [function(e, t) {
                    e[t] = this.node[this.propertyName]
                }, function(e, t) {
                    for (var i = this.resolvedProperty, r = 0, n = i.length; r !== n; ++r) e[t++] = i[r]
                }, function(e, t) {
                    e[t] = this.resolvedProperty[this.propertyIndex]
                }, function(e, t) {
                    this.resolvedProperty.toArray(e, t)
                }],
                SetterByBindingTypeAndVersioning: [
                    [function(e, t) {
                        this.node[this.propertyName] = e[t]
                    }, function(e, t) {
                        this.node[this.propertyName] = e[t], this.targetObject.needsUpdate = !0
                    }, function(e, t) {
                        this.node[this.propertyName] = e[t], this.targetObject.matrixWorldNeedsUpdate = !0
                    }],
                    [function(e, t) {
                        for (var i = this.resolvedProperty, r = 0, n = i.length; r !== n; ++r) i[r] = e[t++]
                    }, function(e, t) {
                        for (var i = this.resolvedProperty, r = 0, n = i.length; r !== n; ++r) i[r] = e[t++];
                        this.targetObject.needsUpdate = !0
                    }, function(e, t) {
                        for (var i = this.resolvedProperty, r = 0, n = i.length; r !== n; ++r) i[r] = e[t++];
                        this.targetObject.matrixWorldNeedsUpdate = !0
                    }],
                    [function(e, t) {
                        this.resolvedProperty[this.propertyIndex] = e[t]
                    }, function(e, t) {
                        this.resolvedProperty[this.propertyIndex] = e[t], this.targetObject.needsUpdate = !0
                    }, function(e, t) {
                        this.resolvedProperty[this.propertyIndex] = e[t], this.targetObject.matrixWorldNeedsUpdate = !0
                    }],
                    [function(e, t) {
                        this.resolvedProperty.fromArray(e, t)
                    }, function(e, t) {
                        this.resolvedProperty.fromArray(e, t), this.targetObject.needsUpdate = !0
                    }, function(e, t) {
                        this.resolvedProperty.fromArray(e, t), this.targetObject.matrixWorldNeedsUpdate = !0
                    }]
                ]
            }), r.PropertyBinding.Composite = function(e, t, i) {
                var n = i || r.PropertyBinding.parseTrackName(t);
                this._targetGroup = e, this._bindings = e.subscribe_(t, n)
            }, r.PropertyBinding.Composite.prototype = {
                constructor: r.PropertyBinding.Composite,
                getValue: function(e, t) {
                    this.bind();
                    var i = this._targetGroup.nCachedObjects_,
                        r = this._bindings[i];
                    void 0 !== r && r.getValue(e, t)
                },
                setValue: function(e, t) {
                    for (var i = this._bindings, r = this._targetGroup.nCachedObjects_, n = i.length; r !== n; ++r) i[r].setValue(e, t)
                },
                bind: function() {
                    for (var e = this._bindings, t = this._targetGroup.nCachedObjects_, i = e.length; t !== i; ++t) e[t].bind()
                },
                unbind: function() {
                    for (var e = this._bindings, t = this._targetGroup.nCachedObjects_, i = e.length; t !== i; ++t) e[t].unbind()
                }
            }, r.PropertyBinding.create = function(e, t, i) {
                return e instanceof r.AnimationObjectGroup ? new r.PropertyBinding.Composite(e, t, i) : new r.PropertyBinding(e, t, i)
            }, r.PropertyBinding.parseTrackName = function(e) {
                var t = /^(([\w]+\/)*)([\w-\d]+)?(\.([\w]+)(\[([\w\d\[\]\_.:\- ]+)\])?)?(\.([\w.]+)(\[([\w\d\[\]\_. ]+)\])?)$/,
                    i = t.exec(e);
                if (!i) throw new Error("cannot parse trackName at all: " + e);
                i.index === t.lastIndex && t.lastIndex++;
                var r = {
                    nodeName: i[3],
                    objectName: i[5],
                    objectIndex: i[7],
                    propertyName: i[9],
                    propertyIndex: i[11]
                };
                if (null === r.propertyName || 0 === r.propertyName.length) throw new Error("can not parse propertyName from trackName: " + e);
                return r
            }, r.PropertyBinding.findNode = function(e, t) {
                if (!t || "" === t || "root" === t || "." === t || -1 === t || t === e.name || t === e.uuid) return e;
                if (e.skeleton) {
                    var i = function(e) {
                            for (var i = 0; i < e.bones.length; i++) {
                                var r = e.bones[i];
                                if (r.name === t) return r
                            }
                            return null
                        },
                        r = i(e.skeleton);
                    if (r) return r
                }
                if (e.children) {
                    var n = function(e) {
                            for (var i = 0; i < e.length; i++) {
                                var r = e[i];
                                if (r.name === t || r.uuid === t) return r;
                                var o = n(r.children);
                                if (o) return o
                            }
                            return null
                        },
                        o = n(e.children);
                    if (o) return o
                }
                return null
            }, r.PropertyMixer = function(e, t, i) {
                this.binding = e, this.valueSize = i;
                var r, n = Float64Array;
                switch (t) {
                    case "quaternion":
                        r = this._slerp;
                        break;
                    case "string":
                    case "bool":
                        n = Array, r = this._select;
                        break;
                    default:
                        r = this._lerp
                }
                this.buffer = new n(4 * i), this._mixBufferRegion = r, this.cumulativeWeight = 0, this.useCount = 0, this.referenceCount = 0
            }, r.PropertyMixer.prototype = {
                constructor: r.PropertyMixer,
                accumulate: function(e, t) {
                    var i = this.buffer,
                        r = this.valueSize,
                        n = e * r + r,
                        o = this.cumulativeWeight;
                    if (0 === o) {
                        for (var a = 0; a !== r; ++a) i[n + a] = i[a];
                        o = t
                    } else {
                        o += t;
                        var s = t / o;
                        this._mixBufferRegion(i, n, 0, s, r)
                    }
                    this.cumulativeWeight = o
                },
                apply: function(e) {
                    var t = this.valueSize,
                        i = this.buffer,
                        r = e * t + t,
                        n = this.cumulativeWeight,
                        o = this.binding;
                    if (this.cumulativeWeight = 0, 1 > n) {
                        var a = 3 * t;
                        this._mixBufferRegion(i, r, a, 1 - n, t)
                    }
                    for (var s = t, l = t + t; s !== l; ++s)
                        if (i[s] !== i[s + t]) {
                            o.setValue(i, r);
                            break
                        }
                },
                saveOriginalState: function() {
                    var e = this.binding,
                        t = this.buffer,
                        i = this.valueSize,
                        r = 3 * i;
                    e.getValue(t, r);
                    for (var n = i, o = r; n !== o; ++n) t[n] = t[r + n % i];
                    this.cumulativeWeight = 0
                },
                restoreOriginalState: function() {
                    var e = 3 * this.valueSize;
                    this.binding.setValue(this.buffer, e)
                },
                _select: function(e, t, i, r, n) {
                    if (r >= .5)
                        for (var o = 0; o !== n; ++o) e[t + o] = e[i + o]
                },
                _slerp: function(e, t, i, n, o) {
                    r.Quaternion.slerpFlat(e, t, e, t, e, i, n)
                },
                _lerp: function(e, t, i, r, n) {
                    for (var o = 1 - r, a = 0; a !== n; ++a) {
                        var s = t + a;
                        e[s] = e[s] * o + e[i + a] * r
                    }
                }
            }, r.BooleanKeyframeTrack = function(e, t, i) {
                r.KeyframeTrack.call(this, e, t, i)
            }, r.BooleanKeyframeTrack.prototype = Object.assign(Object.create(r.KeyframeTrack.prototype), {
                constructor: r.BooleanKeyframeTrack,
                ValueTypeName: "bool",
                ValueBufferType: Array,
                DefaultInterpolation: r.IntepolateDiscrete,
                InterpolantFactoryMethodLinear: void 0,
                InterpolantFactoryMethodSmooth: void 0
            }), r.NumberKeyframeTrack = function(e, t, i, n) {
                r.KeyframeTrack.call(this, e, t, i, n)
            }, r.NumberKeyframeTrack.prototype = Object.assign(Object.create(r.KeyframeTrack.prototype), {
                constructor: r.NumberKeyframeTrack,
                ValueTypeName: "number"
            }), r.QuaternionKeyframeTrack = function(e, t, i, n) {
                r.KeyframeTrack.call(this, e, t, i, n)
            }, r.QuaternionKeyframeTrack.prototype = Object.assign(Object.create(r.KeyframeTrack.prototype), {
                constructor: r.QuaternionKeyframeTrack,
                ValueTypeName: "quaternion",
                DefaultInterpolation: r.InterpolateLinear,
                InterpolantFactoryMethodLinear: function(e) {
                    return new r.QuaternionLinearInterpolant(this.times, this.values, this.getValueSize(), e)
                },
                InterpolantFactoryMethodSmooth: void 0
            }), r.StringKeyframeTrack = function(e, t, i, n) {
                r.KeyframeTrack.call(this, e, t, i, n)
            }, r.StringKeyframeTrack.prototype = Object.assign(Object.create(r.KeyframeTrack.prototype), {
                constructor: r.StringKeyframeTrack,
                ValueTypeName: "string",
                ValueBufferType: Array,
                DefaultInterpolation: r.IntepolateDiscrete,
                InterpolantFactoryMethodLinear: void 0,
                InterpolantFactoryMethodSmooth: void 0
            }), r.VectorKeyframeTrack = function(e, t, i, n) {
                r.KeyframeTrack.call(this, e, t, i, n)
            }, r.VectorKeyframeTrack.prototype = Object.assign(Object.create(r.KeyframeTrack.prototype), {
                constructor: r.VectorKeyframeTrack,
                ValueTypeName: "vector"
            }), r.Audio = function(e) {
                r.Object3D.call(this), this.type = "Audio", this.context = e.context, this.source = this.context.createBufferSource(), this.source.onended = this.onEnded.bind(this), this.gain = this.context.createGain(), this.gain.connect(e.getInput()), this.autoplay = !1, this.startTime = 0, this.playbackRate = 1, this.isPlaying = !1, this.hasPlaybackControl = !0, this.sourceType = "empty", this.filter = null
            }, r.Audio.prototype = Object.create(r.Object3D.prototype), r.Audio.prototype.constructor = r.Audio, r.Audio.prototype.getOutput = function() {
                return this.gain
            }, r.Audio.prototype.load = function(e) {
                var t = new r.AudioBuffer(this.context);
                return t.load(e), this.setBuffer(t), this
            }, r.Audio.prototype.setNodeSource = function(e) {
                return this.hasPlaybackControl = !1, this.sourceType = "audioNode", this.source = e, this.connect(), this
            }, r.Audio.prototype.setBuffer = function(e) {
                var t = this;
                return e.onReady(function(e) {
                    t.source.buffer = e, t.sourceType = "buffer", t.autoplay && t.play()
                }), this
            }, r.Audio.prototype.play = function() {
                if (this.isPlaying === !0) return void console.warn("THREE.Audio: Audio is already playing.");
                if (this.hasPlaybackControl === !1) return void console.warn("THREE.Audio: this Audio has no playback control.");
                var e = this.context.createBufferSource();
                e.buffer = this.source.buffer, e.loop = this.source.loop, e.onended = this.source.onended, e.start(0, this.startTime), e.playbackRate.value = this.playbackRate, this.isPlaying = !0, this.source = e, this.connect()
            }, r.Audio.prototype.pause = function() {
                return this.hasPlaybackControl === !1 ? void console.warn("THREE.Audio: this Audio has no playback control.") : (this.source.stop(), void(this.startTime = this.context.currentTime))
            }, r.Audio.prototype.stop = function() {
                return this.hasPlaybackControl === !1 ? void console.warn("THREE.Audio: this Audio has no playback control.") : (this.source.stop(), void(this.startTime = 0))
            }, r.Audio.prototype.connect = function() {
                null !== this.filter ? (this.source.connect(this.filter), this.filter.connect(this.getOutput())) : this.source.connect(this.getOutput())
            }, r.Audio.prototype.disconnect = function() {
                null !== this.filter ? (this.source.disconnect(this.filter), this.filter.disconnect(this.getOutput())) : this.source.disconnect(this.getOutput())
            }, r.Audio.prototype.getFilter = function() {
                return this.filter
            }, r.Audio.prototype.setFilter = function(e) {
                void 0 === e && (e = null), this.isPlaying === !0 ? (this.disconnect(), this.filter = e, this.connect()) : this.filter = e
            }, r.Audio.prototype.setPlaybackRate = function(e) {
                return this.hasPlaybackControl === !1 ? void console.warn("THREE.Audio: this Audio has no playback control.") : (this.playbackRate = e, void(this.isPlaying === !0 && (this.source.playbackRate.value = this.playbackRate)))
            }, r.Audio.prototype.getPlaybackRate = function() {
                return this.playbackRate
            }, r.Audio.prototype.onEnded = function() {
                this.isPlaying = !1
            }, r.Audio.prototype.setLoop = function(e) {
                return this.hasPlaybackControl === !1 ? void console.warn("THREE.Audio: this Audio has no playback control.") : void(this.source.loop = e)
            }, r.Audio.prototype.getLoop = function() {
                return this.hasPlaybackControl === !1 ? (console.warn("THREE.Audio: this Audio has no playback control."), !1) : this.source.loop
            }, r.Audio.prototype.setVolume = function(e) {
                this.gain.gain.value = e
            }, r.Audio.prototype.getVolume = function() {
                return this.gain.gain.value
            }, r.AudioAnalyser = function(e, t) {
                this.analyser = e.context.createAnalyser(), this.analyser.fftSize = void 0 !== t ? t : 2048, this.data = new Uint8Array(this.analyser.frequencyBinCount), e.getOutput().connect(this.analyser)
            }, r.AudioAnalyser.prototype = {
                constructor: r.AudioAnalyser,
                getData: function() {
                    return this.analyser.getByteFrequencyData(this.data), this.data
                }
            }, r.AudioBuffer = function(e) {
                this.context = e, this.ready = !1, this.readyCallbacks = []
            }, r.AudioBuffer.prototype.load = function(e) {
                var t = this,
                    i = new XMLHttpRequest;
                return i.open("GET", e, !0), i.responseType = "arraybuffer", i.onload = function(e) {
                    t.context.decodeAudioData(this.response, function(e) {
                        t.buffer = e, t.ready = !0;
                        for (var i = 0; i < t.readyCallbacks.length; i++) t.readyCallbacks[i](t.buffer);
                        t.readyCallbacks = []
                    })
                }, i.send(), this
            }, r.AudioBuffer.prototype.onReady = function(e) {
                this.ready ? e(this.buffer) : this.readyCallbacks.push(e)
            }, r.PositionalAudio = function(e) {
                r.Audio.call(this, e), this.panner = this.context.createPanner(), this.panner.connect(this.gain)
            }, r.PositionalAudio.prototype = Object.create(r.Audio.prototype), r.PositionalAudio.prototype.constructor = r.PositionalAudio, r.PositionalAudio.prototype.getOutput = function() {
                return this.panner
            }, r.PositionalAudio.prototype.setRefDistance = function(e) {
                this.panner.refDistance = e
            }, r.PositionalAudio.prototype.getRefDistance = function() {
                return this.panner.refDistance
            }, r.PositionalAudio.prototype.setRolloffFactor = function(e) {
                this.panner.rolloffFactor = e
            }, r.PositionalAudio.prototype.getRolloffFactor = function() {
                return this.panner.rolloffFactor
            }, r.PositionalAudio.prototype.setDistanceModel = function(e) {
                this.panner.distanceModel = e
            }, r.PositionalAudio.prototype.getDistanceModel = function() {
                return this.panner.distanceModel
            }, r.PositionalAudio.prototype.setMaxDistance = function(e) {
                this.panner.maxDistance = e
            }, r.PositionalAudio.prototype.getMaxDistance = function() {
                return this.panner.maxDistance
            }, r.PositionalAudio.prototype.updateMatrixWorld = function() {
                var e = new r.Vector3;
                return function(t) {
                    r.Object3D.prototype.updateMatrixWorld.call(this, t), e.setFromMatrixPosition(this.matrixWorld), this.panner.setPosition(e.x, e.y, e.z)
                }
            }(), r.AudioListener = function() {
                r.Object3D.call(this), this.type = "AudioListener", this.context = new(window.AudioContext || window.webkitAudioContext), this.gain = this.context.createGain(), this.gain.connect(this.context.destination), this.filter = null
            }, r.AudioListener.prototype = Object.create(r.Object3D.prototype), r.AudioListener.prototype.constructor = r.AudioListener, r.AudioListener.prototype.getInput = function() {
                return this.gain
            }, r.AudioListener.prototype.removeFilter = function() {
                null !== this.filter && (this.gain.disconnect(this.filter), this.filter.disconnect(this.context.destination), this.gain.connect(this.context.destination), this.filter = null)
            }, r.AudioListener.prototype.setFilter = function(e) {
                null !== this.filter ? (this.gain.disconnect(this.filter), this.filter.disconnect(this.context.destination)) : this.gain.disconnect(this.context.destination), this.filter = e, this.gain.connect(this.filter), this.filter.connect(this.context.destination)
            }, r.AudioListener.prototype.getFilter = function() {
                return this.filter
            }, r.AudioListener.prototype.setMasterVolume = function(e) {
                this.gain.gain.value = e
            }, r.AudioListener.prototype.getMasterVolume = function() {
                return this.gain.gain.value
            }, r.AudioListener.prototype.updateMatrixWorld = function() {
                var e = new r.Vector3,
                    t = new r.Quaternion,
                    i = new r.Vector3,
                    n = new r.Vector3;
                return function(o) {
                    r.Object3D.prototype.updateMatrixWorld.call(this, o);
                    var a = this.context.listener,
                        s = this.up;
                    this.matrixWorld.decompose(e, t, i), n.set(0, 0, -1).applyQuaternion(t), a.setPosition(e.x, e.y, e.z), a.setOrientation(n.x, n.y, n.z, s.x, s.y, s.z)
                }
            }(), r.Camera = function() {
                r.Object3D.call(this), this.type = "Camera", this.matrixWorldInverse = new r.Matrix4, this.projectionMatrix = new r.Matrix4
            }, r.Camera.prototype = Object.create(r.Object3D.prototype), r.Camera.prototype.constructor = r.Camera, r.Camera.prototype.getWorldDirection = function() {
                var e = new r.Quaternion;
                return function(t) {
                    var i = t || new r.Vector3;
                    return this.getWorldQuaternion(e), i.set(0, 0, -1).applyQuaternion(e)
                }
            }(), r.Camera.prototype.lookAt = function() {
                var e = new r.Matrix4;
                return function(t) {
                    e.lookAt(this.position, t, this.up), this.quaternion.setFromRotationMatrix(e)
                }
            }(), r.Camera.prototype.clone = function() {
                return (new this.constructor).copy(this)
            }, r.Camera.prototype.copy = function(e) {
                return r.Object3D.prototype.copy.call(this, e), this.matrixWorldInverse.copy(e.matrixWorldInverse), this.projectionMatrix.copy(e.projectionMatrix), this
            }, r.CubeCamera = function(e, t, i) {
                r.Object3D.call(this), this.type = "CubeCamera";
                var n = 90,
                    o = 1,
                    a = new r.PerspectiveCamera(n, o, e, t);
                a.up.set(0, -1, 0), a.lookAt(new r.Vector3(1, 0, 0)), this.add(a);
                var s = new r.PerspectiveCamera(n, o, e, t);
                s.up.set(0, -1, 0), s.lookAt(new r.Vector3(-1, 0, 0)), this.add(s);
                var l = new r.PerspectiveCamera(n, o, e, t);
                l.up.set(0, 0, 1), l.lookAt(new r.Vector3(0, 1, 0)), this.add(l);
                var c = new r.PerspectiveCamera(n, o, e, t);
                c.up.set(0, 0, -1), c.lookAt(new r.Vector3(0, -1, 0)), this.add(c);
                var h = new r.PerspectiveCamera(n, o, e, t);
                h.up.set(0, -1, 0), h.lookAt(new r.Vector3(0, 0, 1)), this.add(h);
                var u = new r.PerspectiveCamera(n, o, e, t);
                u.up.set(0, -1, 0), u.lookAt(new r.Vector3(0, 0, -1)), this.add(u);
                var p = {
                    format: r.RGBFormat,
                    magFilter: r.LinearFilter,
                    minFilter: r.LinearFilter
                };
                this.renderTarget = new r.WebGLRenderTargetCube(i, i, p), this.updateCubeMap = function(e, t) {
                    null === this.parent && this.updateMatrixWorld();
                    var i = this.renderTarget,
                        r = i.texture.generateMipmaps;
                    i.texture.generateMipmaps = !1, i.activeCubeFace = 0, e.render(t, a, i), i.activeCubeFace = 1, e.render(t, s, i), i.activeCubeFace = 2, e.render(t, l, i), i.activeCubeFace = 3, e.render(t, c, i), i.activeCubeFace = 4, e.render(t, h, i), i.texture.generateMipmaps = r, i.activeCubeFace = 5, e.render(t, u, i), e.setRenderTarget(null)
                }
            }, r.CubeCamera.prototype = Object.create(r.Object3D.prototype), r.CubeCamera.prototype.constructor = r.CubeCamera, r.OrthographicCamera = function(e, t, i, n, o, a) {
                r.Camera.call(this), this.type = "OrthographicCamera", this.zoom = 1, this.left = e, this.right = t, this.top = i, this.bottom = n, this.near = void 0 !== o ? o : .1, this.far = void 0 !== a ? a : 2e3, this.updateProjectionMatrix()
            }, r.OrthographicCamera.prototype = Object.create(r.Camera.prototype), r.OrthographicCamera.prototype.constructor = r.OrthographicCamera, r.OrthographicCamera.prototype.updateProjectionMatrix = function() {
                var e = (this.right - this.left) / (2 * this.zoom),
                    t = (this.top - this.bottom) / (2 * this.zoom),
                    i = (this.right + this.left) / 2,
                    r = (this.top + this.bottom) / 2;
                this.projectionMatrix.makeOrthographic(i - e, i + e, r + t, r - t, this.near, this.far)
            }, r.OrthographicCamera.prototype.copy = function(e) {
                return r.Camera.prototype.copy.call(this, e), this.left = e.left, this.right = e.right, this.top = e.top, this.bottom = e.bottom, this.near = e.near, this.far = e.far, this.zoom = e.zoom, this
            }, r.OrthographicCamera.prototype.toJSON = function(e) {
                var t = r.Object3D.prototype.toJSON.call(this, e);
                return t.object.zoom = this.zoom, t.object.left = this.left, t.object.right = this.right, t.object.top = this.top, t.object.bottom = this.bottom, t.object.near = this.near, t.object.far = this.far, t
            }, r.PerspectiveCamera = function(e, t, i, n) {
                r.Camera.call(this), this.type = "PerspectiveCamera", this.focalLength = 10, this.zoom = 1, this.fov = void 0 !== e ? e : 50, this.aspect = void 0 !== t ? t : 1, this.near = void 0 !== i ? i : .1, this.far = void 0 !== n ? n : 2e3, this.updateProjectionMatrix()
            }, r.PerspectiveCamera.prototype = Object.create(r.Camera.prototype), r.PerspectiveCamera.prototype.constructor = r.PerspectiveCamera, r.PerspectiveCamera.prototype.setLens = function(e, t) {
                void 0 === t && (t = 24), this.fov = 2 * r.Math.radToDeg(Math.atan(t / (2 * e))), this.updateProjectionMatrix()
            }, r.PerspectiveCamera.prototype.setViewOffset = function(e, t, i, r, n, o) {
                this.fullWidth = e, this.fullHeight = t, this.x = i, this.y = r, this.width = n, this.height = o, this.updateProjectionMatrix()
            }, r.PerspectiveCamera.prototype.updateProjectionMatrix = function() {
                var e = r.Math.radToDeg(2 * Math.atan(Math.tan(.5 * r.Math.degToRad(this.fov)) / this.zoom));
                if (this.fullWidth) {
                    var t = this.fullWidth / this.fullHeight,
                        i = Math.tan(r.Math.degToRad(.5 * e)) * this.near,
                        n = -i,
                        o = t * n,
                        a = t * i,
                        s = Math.abs(a - o),
                        l = Math.abs(i - n);
                    this.projectionMatrix.makeFrustum(o + this.x * s / this.fullWidth, o + (this.x + this.width) * s / this.fullWidth, i - (this.y + this.height) * l / this.fullHeight, i - this.y * l / this.fullHeight, this.near, this.far)
                } else this.projectionMatrix.makePerspective(e, this.aspect, this.near, this.far)
            }, r.PerspectiveCamera.prototype.copy = function(e) {
                return r.Camera.prototype.copy.call(this, e), this.focalLength = e.focalLength, this.zoom = e.zoom, this.fov = e.fov, this.aspect = e.aspect, this.near = e.near, this.far = e.far, this
            }, r.PerspectiveCamera.prototype.toJSON = function(e) {
                var t = r.Object3D.prototype.toJSON.call(this, e);
                return t.object.focalLength = this.focalLength, t.object.zoom = this.zoom, t.object.fov = this.fov, t.object.aspect = this.aspect, t.object.near = this.near, t.object.far = this.far, t
            }, r.StereoCamera = function() {
                this.type = "StereoCamera", this.aspect = 1, this.cameraL = new r.PerspectiveCamera, this.cameraL.layers.enable(1), this.cameraL.matrixAutoUpdate = !1, this.cameraR = new r.PerspectiveCamera, this.cameraR.layers.enable(2), this.cameraR.matrixAutoUpdate = !1
            }, r.StereoCamera.prototype = {
                constructor: r.StereoCamera,
                update: function() {
                    var e, t, i, n, o, a = new r.Matrix4,
                        s = new r.Matrix4;
                    return function(l) {
                        var c = e !== l.focalLength || t !== l.fov || i !== l.aspect * this.aspect || n !== l.near || o !== l.far;
                        if (c) {
                            e = l.focalLength, t = l.fov, i = l.aspect * this.aspect, n = l.near, o = l.far;
                            var h, u, p = l.projectionMatrix.clone(),
                                f = .032,
                                d = f * n / e,
                                m = n * Math.tan(r.Math.degToRad(.5 * t));
                            s.elements[12] = -f, a.elements[12] = f, h = -m * i + d, u = m * i + d, p.elements[0] = 2 * n / (u - h), p.elements[8] = (u + h) / (u - h), this.cameraL.projectionMatrix.copy(p), h = -m * i - d, u = m * i - d, p.elements[0] = 2 * n / (u - h), p.elements[8] = (u + h) / (u - h), this.cameraR.projectionMatrix.copy(p)
                        }
                        this.cameraL.matrixWorld.copy(l.matrixWorld).multiply(s), this.cameraR.matrixWorld.copy(l.matrixWorld).multiply(a)
                    }
                }()
            }, r.Light = function(e, t) {
                r.Object3D.call(this), this.type = "Light", this.color = new r.Color(e), this.intensity = void 0 !== t ? t : 1, this.receiveShadow = void 0
            }, r.Light.prototype = Object.create(r.Object3D.prototype), r.Light.prototype.constructor = r.Light, r.Light.prototype.copy = function(e) {
                return r.Object3D.prototype.copy.call(this, e), this.color.copy(e.color), this.intensity = e.intensity, this
            }, r.Light.prototype.toJSON = function(e) {
                var t = r.Object3D.prototype.toJSON.call(this, e);
                return t.object.color = this.color.getHex(), t.object.intensity = this.intensity, void 0 !== this.groundColor && (t.object.groundColor = this.groundColor.getHex()), void 0 !== this.distance && (t.object.distance = this.distance), void 0 !== this.angle && (t.object.angle = this.angle), void 0 !== this.decay && (t.object.decay = this.decay), void 0 !== this.penumbra && (t.object.penumbra = this.penumbra), t
            }, r.LightShadow = function(e) {
                this.camera = e, this.bias = 0, this.radius = 1, this.mapSize = new r.Vector2(512, 512), this.map = null, this.matrix = new r.Matrix4
            }, r.LightShadow.prototype = {
                constructor: r.LightShadow,
                copy: function(e) {
                    return this.camera = e.camera.clone(), this.bias = e.bias, this.radius = e.radius, this.mapSize.copy(e.mapSize), this
                },
                clone: function() {
                    return (new this.constructor).copy(this)
                }
            }, r.AmbientLight = function(e, t) {
                r.Light.call(this, e, t), this.type = "AmbientLight", this.castShadow = void 0
            }, r.AmbientLight.prototype = Object.create(r.Light.prototype), r.AmbientLight.prototype.constructor = r.AmbientLight, r.DirectionalLight = function(e, t) {
                r.Light.call(this, e, t), this.type = "DirectionalLight", this.position.set(0, 1, 0), this.updateMatrix(), this.target = new r.Object3D, this.shadow = new r.LightShadow(new r.OrthographicCamera(-5, 5, 5, -5, .5, 500))
            }, r.DirectionalLight.prototype = Object.create(r.Light.prototype), r.DirectionalLight.prototype.constructor = r.DirectionalLight, r.DirectionalLight.prototype.copy = function(e) {
                return r.Light.prototype.copy.call(this, e), this.target = e.target.clone(), this.shadow = e.shadow.clone(), this
            }, r.HemisphereLight = function(e, t, i) {
                r.Light.call(this, e, i), this.type = "HemisphereLight", this.castShadow = void 0, this.position.set(0, 1, 0), this.updateMatrix(), this.groundColor = new r.Color(t)
            }, r.HemisphereLight.prototype = Object.create(r.Light.prototype), r.HemisphereLight.prototype.constructor = r.HemisphereLight, r.HemisphereLight.prototype.copy = function(e) {
                return r.Light.prototype.copy.call(this, e), this.groundColor.copy(e.groundColor), this
            }, r.PointLight = function(e, t, i, n) {
                r.Light.call(this, e, t), this.type = "PointLight", this.distance = void 0 !== i ? i : 0, this.decay = void 0 !== n ? n : 1, this.shadow = new r.LightShadow(new r.PerspectiveCamera(90, 1, .5, 500))
            }, r.PointLight.prototype = Object.create(r.Light.prototype), r.PointLight.prototype.constructor = r.PointLight, Object.defineProperty(r.PointLight.prototype, "power", {
                get: function() {
                    return 4 * this.intensity * Math.PI
                },
                set: function(e) {
                    this.intensity = e / (4 * Math.PI)
                }
            }), r.PointLight.prototype.copy = function(e) {
                return r.Light.prototype.copy.call(this, e), this.distance = e.distance, this.decay = e.decay, this.shadow = e.shadow.clone(), this
            }, r.SpotLight = function(e, t, i, n, o, a) {
                r.Light.call(this, e, t), this.type = "SpotLight", this.position.set(0, 1, 0), this.updateMatrix(), this.target = new r.Object3D, this.distance = void 0 !== i ? i : 0, this.angle = void 0 !== n ? n : Math.PI / 3, this.penumbra = void 0 !== o ? o : 0, this.decay = void 0 !== a ? a : 1, this.shadow = new r.LightShadow(new r.PerspectiveCamera(50, 1, .5, 500))
            }, r.SpotLight.prototype = Object.create(r.Light.prototype), r.SpotLight.prototype.constructor = r.SpotLight, Object.defineProperty(r.SpotLight.prototype, "power", {
                get: function() {
                    return this.intensity * Math.PI
                },
                set: function(e) {
                    this.intensity = e / Math.PI
                }
            }), r.SpotLight.prototype.copy = function(e) {
                return r.Light.prototype.copy.call(this, e), this.distance = e.distance, this.angle = e.angle, this.penumbra = e.penumbra, this.decay = e.decay, this.target = e.target.clone(), this.shadow = e.shadow.clone(), this
            }, r.Cache = {
                enabled: !1,
                files: {},
                add: function(e, t) {
                    this.enabled !== !1 && (this.files[e] = t)
                },
                get: function(e) {
                    return this.enabled !== !1 ? this.files[e] : void 0
                },
                remove: function(e) {
                    delete this.files[e]
                },
                clear: function() {
                    this.files = {}
                }
            }, r.Loader = function() {
                this.onLoadStart = function() {}, this.onLoadProgress = function() {}, this.onLoadComplete = function() {}
            }, r.Loader.prototype = {
                constructor: r.Loader,
                crossOrigin: void 0,
                extractUrlBase: function(e) {
                    var t = e.split("/");
                    return 1 === t.length ? "./" : (t.pop(), t.join("/") + "/")
                },
                initMaterials: function(e, t, i) {
                    for (var r = [], n = 0; n < e.length; ++n) r[n] = this.createMaterial(e[n], t, i);
                    return r
                },
                createMaterial: function() {
                    var e, t, i;
                    return function(n, o, a) {
                        function s(e, i, n, s, c) {
                            var h, u = o + e,
                                p = r.Loader.Handlers.get(u);
                            null !== p ? h = p.load(u) : (t.setCrossOrigin(a), h = t.load(u)), void 0 !== i && (h.repeat.fromArray(i), 1 !== i[0] && (h.wrapS = r.RepeatWrapping), 1 !== i[1] && (h.wrapT = r.RepeatWrapping)), void 0 !== n && h.offset.fromArray(n), void 0 !== s && ("repeat" === s[0] && (h.wrapS = r.RepeatWrapping), "mirror" === s[0] && (h.wrapS = r.MirroredRepeatWrapping), "repeat" === s[1] && (h.wrapT = r.RepeatWrapping), "mirror" === s[1] && (h.wrapT = r.MirroredRepeatWrapping)), void 0 !== c && (h.anisotropy = c);
                            var f = r.Math.generateUUID();
                            return l[f] = h, f
                        }
                        void 0 === e && (e = new r.Color), void 0 === t && (t = new r.TextureLoader), void 0 === i && (i = new r.MaterialLoader);
                        var l = {},
                            c = {
                                uuid: r.Math.generateUUID(),
                                type: "MeshLambertMaterial"
                            };
                        for (var h in n) {
                            var u = n[h];
                            switch (h) {
                                case "DbgColor":
                                case "DbgIndex":
                                case "opticalDensity":
                                case "illumination":
                                    break;
                                case "DbgName":
                                    c.name = u;
                                    break;
                                case "blending":
                                    c.blending = r[u];
                                    break;
                                case "colorAmbient":
                                case "mapAmbient":
                                    console.warn("THREE.Loader.createMaterial:", h, "is no longer supported.");
                                    break;
                                case "colorDiffuse":
                                    c.color = e.fromArray(u).getHex();
                                    break;
                                case "colorSpecular":
                                    c.specular = e.fromArray(u).getHex();
                                    break;
                                case "colorEmissive":
                                    c.emissive = e.fromArray(u).getHex();
                                    break;
                                case "specularCoef":
                                    c.shininess = u;
                                    break;
                                case "shading":
                                    "basic" === u.toLowerCase() && (c.type = "MeshBasicMaterial"), "phong" === u.toLowerCase() && (c.type = "MeshPhongMaterial");
                                    break;
                                case "mapDiffuse":
                                    c.map = s(u, n.mapDiffuseRepeat, n.mapDiffuseOffset, n.mapDiffuseWrap, n.mapDiffuseAnisotropy);
                                    break;
                                case "mapDiffuseRepeat":
                                case "mapDiffuseOffset":
                                case "mapDiffuseWrap":
                                case "mapDiffuseAnisotropy":
                                    break;
                                case "mapLight":
                                    c.lightMap = s(u, n.mapLightRepeat, n.mapLightOffset, n.mapLightWrap, n.mapLightAnisotropy);
                                    break;
                                case "mapLightRepeat":
                                case "mapLightOffset":
                                case "mapLightWrap":
                                case "mapLightAnisotropy":
                                    break;
                                case "mapAO":
                                    c.aoMap = s(u, n.mapAORepeat, n.mapAOOffset, n.mapAOWrap, n.mapAOAnisotropy);
                                    break;
                                case "mapAORepeat":
                                case "mapAOOffset":
                                case "mapAOWrap":
                                case "mapAOAnisotropy":
                                    break;
                                case "mapBump":
                                    c.bumpMap = s(u, n.mapBumpRepeat, n.mapBumpOffset, n.mapBumpWrap, n.mapBumpAnisotropy);
                                    break;
                                case "mapBumpScale":
                                    c.bumpScale = u;
                                    break;
                                case "mapBumpRepeat":
                                case "mapBumpOffset":
                                case "mapBumpWrap":
                                case "mapBumpAnisotropy":
                                    break;
                                case "mapNormal":
                                    c.normalMap = s(u, n.mapNormalRepeat, n.mapNormalOffset, n.mapNormalWrap, n.mapNormalAnisotropy);
                                    break;
                                case "mapNormalFactor":
                                    c.normalScale = [u, u];
                                    break;
                                case "mapNormalRepeat":
                                case "mapNormalOffset":
                                case "mapNormalWrap":
                                case "mapNormalAnisotropy":
                                    break;
                                case "mapSpecular":
                                    c.specularMap = s(u, n.mapSpecularRepeat, n.mapSpecularOffset, n.mapSpecularWrap, n.mapSpecularAnisotropy);
                                    break;
                                case "mapSpecularRepeat":
                                case "mapSpecularOffset":
                                case "mapSpecularWrap":
                                case "mapSpecularAnisotropy":
                                    break;
                                case "mapAlpha":
                                    c.alphaMap = s(u, n.mapAlphaRepeat, n.mapAlphaOffset, n.mapAlphaWrap, n.mapAlphaAnisotropy);
                                    break;
                                case "mapAlphaRepeat":
                                case "mapAlphaOffset":
                                case "mapAlphaWrap":
                                case "mapAlphaAnisotropy":
                                    break;
                                case "flipSided":
                                    c.side = r.BackSide;
                                    break;
                                case "doubleSided":
                                    c.side = r.DoubleSide;
                                    break;
                                case "transparency":
                                    console.warn("THREE.Loader.createMaterial: transparency has been renamed to opacity"), c.opacity = u;
                                    break;
                                case "depthTest":
                                case "depthWrite":
                                case "colorWrite":
                                case "opacity":
                                case "reflectivity":
                                case "transparent":
                                case "visible":
                                case "wireframe":
                                    c[h] = u;
                                    break;
                                case "vertexColors":
                                    u === !0 && (c.vertexColors = r.VertexColors), "face" === u && (c.vertexColors = r.FaceColors);
                                    break;
                                default:
                                    console.error("THREE.Loader.createMaterial: Unsupported", h, u)
                            }
                        }
                        return "MeshBasicMaterial" === c.type && delete c.emissive, "MeshPhongMaterial" !== c.type && delete c.specular, c.opacity < 1 && (c.transparent = !0), i.setTextures(l), i.parse(c)
                    }
                }()
            }, r.Loader.Handlers = {
                handlers: [],
                add: function(e, t) {
                    this.handlers.push(e, t)
                },
                get: function(e) {
                    for (var t = this.handlers, i = 0, r = t.length; r > i; i += 2) {
                        var n = t[i],
                            o = t[i + 1];
                        if (n.test(e)) return o
                    }
                    return null
                }
            }, r.XHRLoader = function(e) {
                this.manager = void 0 !== e ? e : r.DefaultLoadingManager
            }, r.XHRLoader.prototype = {
                constructor: r.XHRLoader,
                load: function(e, t, i, n) {
                    void 0 !== this.path && (e = this.path + e);
                    var o = this,
                        a = r.Cache.get(e);
                    if (void 0 !== a) return t && setTimeout(function() {
                        t(a)
                    }, 0), a;
                    var s = new XMLHttpRequest;
                    return s.overrideMimeType("text/plain"), s.open("GET", e, !0), s.addEventListener("load", function(i) {
                        var a = i.target.response;
                        r.Cache.add(e, a), 200 === this.status ? (t && t(a), o.manager.itemEnd(e)) : 0 === this.status ? (console.warn("THREE.XHRLoader: HTTP Status 0 received."), t && t(a), o.manager.itemEnd(e)) : (n && n(i), o.manager.itemError(e))
                    }, !1), void 0 !== i && s.addEventListener("progress", function(e) {
                        i(e)
                    }, !1), s.addEventListener("error", function(t) {
                        n && n(t), o.manager.itemError(e)
                    }, !1), void 0 !== this.responseType && (s.responseType = this.responseType), void 0 !== this.withCredentials && (s.withCredentials = this.withCredentials), s.send(null), o.manager.itemStart(e), s
                },
                setPath: function(e) {
                    this.path = e
                },
                setResponseType: function(e) {
                    this.responseType = e
                },
                setWithCredentials: function(e) {
                    this.withCredentials = e
                }
            }, r.FontLoader = function(e) {
                this.manager = void 0 !== e ? e : r.DefaultLoadingManager
            }, r.FontLoader.prototype = {
                constructor: r.FontLoader,
                load: function(e, t, i, n) {
                    var o = new r.XHRLoader(this.manager);
                    o.load(e, function(e) {
                        t(new r.Font(JSON.parse(e.substring(65, e.length - 2))))
                    }, i, n)
                }
            }, r.ImageLoader = function(e) {
                this.manager = void 0 !== e ? e : r.DefaultLoadingManager
            }, r.ImageLoader.prototype = {
                constructor: r.ImageLoader,
                load: function(e, t, i, n) {
                    void 0 !== this.path && (e = this.path + e);
                    var o = this,
                        a = r.Cache.get(e);
                    if (void 0 !== a) return o.manager.itemStart(e), t ? setTimeout(function() {
                        t(a), o.manager.itemEnd(e)
                    }, 0) : o.manager.itemEnd(e), a;
                    var s = document.createElement("img");
                    return s.addEventListener("load", function(i) {
                        r.Cache.add(e, this), t && t(this), o.manager.itemEnd(e)
                    }, !1), void 0 !== i && s.addEventListener("progress", function(e) {
                        i(e)
                    }, !1), s.addEventListener("error", function(t) {
                        n && n(t), o.manager.itemError(e)
                    }, !1), void 0 !== this.crossOrigin && (s.crossOrigin = this.crossOrigin), o.manager.itemStart(e), s.src = e, s
                },
                setCrossOrigin: function(e) {
                    this.crossOrigin = e
                },
                setPath: function(e) {
                    this.path = e
                }
            }, r.JSONLoader = function(e) {
                "boolean" == typeof e && (console.warn("THREE.JSONLoader: showStatus parameter has been removed from constructor."), e = void 0), this.manager = void 0 !== e ? e : r.DefaultLoadingManager, this.withCredentials = !1
            }, r.JSONLoader.prototype = {
                constructor: r.JSONLoader,
                get statusDomElement() {
                    return void 0 === this._statusDomElement && (this._statusDomElement = document.createElement("div")), console.warn("THREE.JSONLoader: .statusDomElement has been removed."), this._statusDomElement
                },
                load: function(e, t, i, n) {
                    var o = this,
                        a = this.texturePath && "string" == typeof this.texturePath ? this.texturePath : r.Loader.prototype.extractUrlBase(e),
                        s = new r.XHRLoader(this.manager);
                    s.setWithCredentials(this.withCredentials), s.load(e, function(i) {
                        var r = JSON.parse(i),
                            n = r.metadata;
                        if (void 0 !== n) {
                            var s = n.type;
                            if (void 0 !== s) {
                                if ("object" === s.toLowerCase()) return void console.error("THREE.JSONLoader: " + e + " should be loaded with THREE.ObjectLoader instead.");
                                if ("scene" === s.toLowerCase()) return void console.error("THREE.JSONLoader: " + e + " should be loaded with THREE.SceneLoader instead.")
                            }
                        }
                        var l = o.parse(r, a);
                        t(l.geometry, l.materials)
                    }, i, n)
                },
                setTexturePath: function(e) {
                    this.texturePath = e
                },
                parse: function(e, t) {
                    function i(t) {
                        function i(e, t) {
                            return e & 1 << t
                        }
                        var n, o, a, l, c, h, u, p, f, d, m, g, v, y, _, x, b, w, T, M, S, E, A, C, L, P, R, D = e.faces,
                            O = e.vertices,
                            I = e.normals,
                            F = e.colors,
                            N = 0;
                        if (void 0 !== e.uvs) {
                            for (n = 0; n < e.uvs.length; n++) e.uvs[n].length && N++;
                            for (n = 0; N > n; n++) s.faceVertexUvs[n] = []
                        }
                        for (l = 0, c = O.length; c > l;) w = new r.Vector3, w.x = O[l++] * t, w.y = O[l++] * t, w.z = O[l++] * t, s.vertices.push(w);
                        for (l = 0, c = D.length; c > l;)
                            if (d = D[l++], m = i(d, 0), g = i(d, 1), v = i(d, 3), y = i(d, 4), _ = i(d, 5), x = i(d, 6), b = i(d, 7), m) {
                                if (M = new r.Face3, M.a = D[l], M.b = D[l + 1], M.c = D[l + 3], S = new r.Face3, S.a = D[l + 1], S.b = D[l + 2], S.c = D[l + 3], l += 4, g && (f = D[l++], M.materialIndex = f, S.materialIndex = f), a = s.faces.length, v)
                                    for (n = 0; N > n; n++)
                                        for (C = e.uvs[n], s.faceVertexUvs[n][a] = [], s.faceVertexUvs[n][a + 1] = [], o = 0; 4 > o; o++) p = D[l++], P = C[2 * p], R = C[2 * p + 1], L = new r.Vector2(P, R), 2 !== o && s.faceVertexUvs[n][a].push(L), 0 !== o && s.faceVertexUvs[n][a + 1].push(L);
                                if (y && (u = 3 * D[l++], M.normal.set(I[u++], I[u++], I[u]), S.normal.copy(M.normal)), _)
                                    for (n = 0; 4 > n; n++) u = 3 * D[l++], A = new r.Vector3(I[u++], I[u++], I[u]), 2 !== n && M.vertexNormals.push(A), 0 !== n && S.vertexNormals.push(A);
                                if (x && (h = D[l++], E = F[h], M.color.setHex(E), S.color.setHex(E)), b)
                                    for (n = 0; 4 > n; n++) h = D[l++], E = F[h], 2 !== n && M.vertexColors.push(new r.Color(E)), 0 !== n && S.vertexColors.push(new r.Color(E));
                                s.faces.push(M), s.faces.push(S)
                            } else {
                                if (T = new r.Face3, T.a = D[l++], T.b = D[l++], T.c = D[l++], g && (f = D[l++], T.materialIndex = f), a = s.faces.length, v)
                                    for (n = 0; N > n; n++)
                                        for (C = e.uvs[n], s.faceVertexUvs[n][a] = [], o = 0; 3 > o; o++) p = D[l++], P = C[2 * p], R = C[2 * p + 1], L = new r.Vector2(P, R), s.faceVertexUvs[n][a].push(L);
                                if (y && (u = 3 * D[l++], T.normal.set(I[u++], I[u++], I[u])), _)
                                    for (n = 0; 3 > n; n++) u = 3 * D[l++], A = new r.Vector3(I[u++], I[u++], I[u]), T.vertexNormals.push(A);
                                if (x && (h = D[l++], T.color.setHex(F[h])), b)
                                    for (n = 0; 3 > n; n++) h = D[l++], T.vertexColors.push(new r.Color(F[h]));
                                s.faces.push(T)
                            }
                    }

                    function n() {
                        var t = void 0 !== e.influencesPerVertex ? e.influencesPerVertex : 2;
                        if (e.skinWeights)
                            for (var i = 0, n = e.skinWeights.length; n > i; i += t) {
                                var o = e.skinWeights[i],
                                    a = t > 1 ? e.skinWeights[i + 1] : 0,
                                    l = t > 2 ? e.skinWeights[i + 2] : 0,
                                    c = t > 3 ? e.skinWeights[i + 3] : 0;
                                s.skinWeights.push(new r.Vector4(o, a, l, c))
                            }
                        if (e.skinIndices)
                            for (var i = 0, n = e.skinIndices.length; n > i; i += t) {
                                var h = e.skinIndices[i],
                                    u = t > 1 ? e.skinIndices[i + 1] : 0,
                                    p = t > 2 ? e.skinIndices[i + 2] : 0,
                                    f = t > 3 ? e.skinIndices[i + 3] : 0;
                                s.skinIndices.push(new r.Vector4(h, u, p, f))
                            }
                        s.bones = e.bones, s.bones && s.bones.length > 0 && (s.skinWeights.length !== s.skinIndices.length || s.skinIndices.length !== s.vertices.length) && console.warn("When skinning, number of vertices (" + s.vertices.length + "), skinIndices (" + s.skinIndices.length + "), and skinWeights (" + s.skinWeights.length + ") should match.")
                    }

                    function o(t) {
                        if (void 0 !== e.morphTargets)
                            for (var i = 0, n = e.morphTargets.length; n > i; i++) {
                                s.morphTargets[i] = {}, s.morphTargets[i].name = e.morphTargets[i].name, s.morphTargets[i].vertices = [];
                                for (var o = s.morphTargets[i].vertices, a = e.morphTargets[i].vertices, l = 0, c = a.length; c > l; l += 3) {
                                    var h = new r.Vector3;
                                    h.x = a[l] * t, h.y = a[l + 1] * t, h.z = a[l + 2] * t, o.push(h)
                                }
                            }
                        if (void 0 !== e.morphColors && e.morphColors.length > 0) {
                            console.warn('THREE.JSONLoader: "morphColors" no longer supported. Using them as face colors.');
                            for (var u = s.faces, p = e.morphColors[0].colors, i = 0, n = u.length; n > i; i++) u[i].color.fromArray(p, 3 * i)
                        }
                    }

                    function a() {
                        var t = [],
                            i = [];
                        void 0 !== e.animation && i.push(e.animation), void 0 !== e.animations && (e.animations.length ? i = i.concat(e.animations) : i.push(e.animations));
                        for (var n = 0; n < i.length; n++) {
                            var o = r.AnimationClip.parseAnimation(i[n], s.bones);
                            o && t.push(o)
                        }
                        if (s.morphTargets) {
                            var a = r.AnimationClip.CreateClipsFromMorphTargetSequences(s.morphTargets, 10);
                            t = t.concat(a)
                        }
                        t.length > 0 && (s.animations = t)
                    }
                    var s = new r.Geometry,
                        l = void 0 !== e.scale ? 1 / e.scale : 1;
                    if (i(l), n(), o(l), a(), s.computeFaceNormals(), s.computeBoundingSphere(), void 0 === e.materials || 0 === e.materials.length) return {
                        geometry: s
                    };
                    var c = r.Loader.prototype.initMaterials(e.materials, t, this.crossOrigin);
                    return {
                        geometry: s,
                        materials: c
                    }
                }
            }, r.LoadingManager = function(e, t, i) {
                var r = this,
                    n = !1,
                    o = 0,
                    a = 0;
                this.onStart = void 0, this.onLoad = e, this.onProgress = t, this.onError = i, this.itemStart = function(e) {
                    a++, n === !1 && void 0 !== r.onStart && r.onStart(e, o, a), n = !0
                }, this.itemEnd = function(e) {
                    o++, void 0 !== r.onProgress && r.onProgress(e, o, a), o === a && (n = !1, void 0 !== r.onLoad && r.onLoad())
                }, this.itemError = function(e) {
                    void 0 !== r.onError && r.onError(e)
                }
            }, r.DefaultLoadingManager = new r.LoadingManager, r.BufferGeometryLoader = function(e) {
                this.manager = void 0 !== e ? e : r.DefaultLoadingManager
            }, r.BufferGeometryLoader.prototype = {
                constructor: r.BufferGeometryLoader,
                load: function(e, t, i, n) {
                    var o = this,
                        a = new r.XHRLoader(o.manager);
                    a.load(e, function(e) {
                        t(o.parse(JSON.parse(e)))
                    }, i, n)
                },
                parse: function(e) {
                    var t = new r.BufferGeometry,
                        i = e.data.index,
                        n = {
                            Int8Array: Int8Array,
                            Uint8Array: Uint8Array,
                            Uint8ClampedArray: Uint8ClampedArray,
                            Int16Array: Int16Array,
                            Uint16Array: Uint16Array,
                            Int32Array: Int32Array,
                            Uint32Array: Uint32Array,
                            Float32Array: Float32Array,
                            Float64Array: Float64Array
                        };
                    if (void 0 !== i) {
                        var o = new n[i.type](i.array);
                        t.setIndex(new r.BufferAttribute(o, 1))
                    }
                    var a = e.data.attributes;
                    for (var s in a) {
                        var l = a[s],
                            o = new n[l.type](l.array);
                        t.addAttribute(s, new r.BufferAttribute(o, l.itemSize))
                    }
                    var c = e.data.groups || e.data.drawcalls || e.data.offsets;
                    if (void 0 !== c)
                        for (var h = 0, u = c.length; h !== u; ++h) {
                            var p = c[h];
                            t.addGroup(p.start, p.count, p.materialIndex)
                        }
                    var f = e.data.boundingSphere;
                    if (void 0 !== f) {
                        var d = new r.Vector3;
                        void 0 !== f.center && d.fromArray(f.center), t.boundingSphere = new r.Sphere(d, f.radius)
                    }
                    return t
                }
            }, r.MaterialLoader = function(e) {
                this.manager = void 0 !== e ? e : r.DefaultLoadingManager, this.textures = {}
            }, r.MaterialLoader.prototype = {
                constructor: r.MaterialLoader,
                load: function(e, t, i, n) {
                    var o = this,
                        a = new r.XHRLoader(o.manager);
                    a.load(e, function(e) {
                        t(o.parse(JSON.parse(e)))
                    }, i, n)
                },
                setTextures: function(e) {
                    this.textures = e
                },
                getTexture: function(e) {
                    var t = this.textures;
                    return void 0 === t[e] && console.warn("THREE.MaterialLoader: Undefined texture", e), t[e]
                },
                parse: function(e) {
                    var t = new r[e.type];
                    if (void 0 !== e.uuid && (t.uuid = e.uuid), void 0 !== e.name && (t.name = e.name), void 0 !== e.color && t.color.setHex(e.color), void 0 !== e.roughness && (t.roughness = e.roughness), void 0 !== e.metalness && (t.metalness = e.metalness), void 0 !== e.emissive && t.emissive.setHex(e.emissive), void 0 !== e.specular && t.specular.setHex(e.specular), void 0 !== e.shininess && (t.shininess = e.shininess), void 0 !== e.uniforms && (t.uniforms = e.uniforms), void 0 !== e.vertexShader && (t.vertexShader = e.vertexShader), void 0 !== e.fragmentShader && (t.fragmentShader = e.fragmentShader), void 0 !== e.vertexColors && (t.vertexColors = e.vertexColors), void 0 !== e.shading && (t.shading = e.shading), void 0 !== e.blending && (t.blending = e.blending), void 0 !== e.side && (t.side = e.side), void 0 !== e.opacity && (t.opacity = e.opacity), void 0 !== e.transparent && (t.transparent = e.transparent), void 0 !== e.alphaTest && (t.alphaTest = e.alphaTest), void 0 !== e.depthTest && (t.depthTest = e.depthTest), void 0 !== e.depthWrite && (t.depthWrite = e.depthWrite), void 0 !== e.colorWrite && (t.colorWrite = e.colorWrite), void 0 !== e.wireframe && (t.wireframe = e.wireframe), void 0 !== e.wireframeLinewidth && (t.wireframeLinewidth = e.wireframeLinewidth), void 0 !== e.size && (t.size = e.size), void 0 !== e.sizeAttenuation && (t.sizeAttenuation = e.sizeAttenuation), void 0 !== e.map && (t.map = this.getTexture(e.map)), void 0 !== e.alphaMap && (t.alphaMap = this.getTexture(e.alphaMap), t.transparent = !0), void 0 !== e.bumpMap && (t.bumpMap = this.getTexture(e.bumpMap)), void 0 !== e.bumpScale && (t.bumpScale = e.bumpScale), void 0 !== e.normalMap && (t.normalMap = this.getTexture(e.normalMap)), void 0 !== e.normalScale) {
                        var i = e.normalScale;
                        Array.isArray(i) === !1 && (i = [i, i]), t.normalScale = (new r.Vector2).fromArray(i)
                    }
                    if (void 0 !== e.displacementMap && (t.displacementMap = this.getTexture(e.displacementMap)), void 0 !== e.displacementScale && (t.displacementScale = e.displacementScale), void 0 !== e.displacementBias && (t.displacementBias = e.displacementBias), void 0 !== e.roughnessMap && (t.roughnessMap = this.getTexture(e.roughnessMap)), void 0 !== e.metalnessMap && (t.metalnessMap = this.getTexture(e.metalnessMap)), void 0 !== e.emissiveMap && (t.emissiveMap = this.getTexture(e.emissiveMap)), void 0 !== e.emissiveIntensity && (t.emissiveIntensity = e.emissiveIntensity), void 0 !== e.specularMap && (t.specularMap = this.getTexture(e.specularMap)), void 0 !== e.envMap && (t.envMap = this.getTexture(e.envMap), t.combine = r.MultiplyOperation), e.reflectivity && (t.reflectivity = e.reflectivity), void 0 !== e.lightMap && (t.lightMap = this.getTexture(e.lightMap)), void 0 !== e.lightMapIntensity && (t.lightMapIntensity = e.lightMapIntensity), void 0 !== e.aoMap && (t.aoMap = this.getTexture(e.aoMap)), void 0 !== e.aoMapIntensity && (t.aoMapIntensity = e.aoMapIntensity), void 0 !== e.materials)
                        for (var n = 0, o = e.materials.length; o > n; n++) t.materials.push(this.parse(e.materials[n]));
                    return t
                }
            }, r.ObjectLoader = function(e) {
                this.manager = void 0 !== e ? e : r.DefaultLoadingManager, this.texturePath = ""
            }, r.ObjectLoader.prototype = {
                constructor: r.ObjectLoader,
                load: function(e, t, i, n) {
                    "" === this.texturePath && (this.texturePath = e.substring(0, e.lastIndexOf("/") + 1));
                    var o = this,
                        a = new r.XHRLoader(o.manager);
                    a.load(e, function(e) {
                        o.parse(JSON.parse(e), t)
                    }, i, n)
                },
                setTexturePath: function(e) {
                    this.texturePath = e
                },
                setCrossOrigin: function(e) {
                    this.crossOrigin = e
                },
                parse: function(e, t) {
                    var i = this.parseGeometries(e.geometries),
                        r = this.parseImages(e.images, function() {
                            void 0 !== t && t(a)
                        }),
                        n = this.parseTextures(e.textures, r),
                        o = this.parseMaterials(e.materials, n),
                        a = this.parseObject(e.object, i, o);
                    return e.animations && (a.animations = this.parseAnimations(e.animations)), void 0 !== e.images && 0 !== e.images.length || void 0 !== t && t(a), a
                },
                parseGeometries: function(e) {
                    var t = {};
                    if (void 0 !== e)
                        for (var i = new r.JSONLoader, n = new r.BufferGeometryLoader, o = 0, a = e.length; a > o; o++) {
                            var s, l = e[o];
                            switch (l.type) {
                                case "PlaneGeometry":
                                case "PlaneBufferGeometry":
                                    s = new r[l.type](l.width, l.height, l.widthSegments, l.heightSegments);
                                    break;
                                case "BoxGeometry":
                                case "BoxBufferGeometry":
                                case "CubeGeometry":
                                    s = new r[l.type](l.width, l.height, l.depth, l.widthSegments, l.heightSegments, l.depthSegments);
                                    break;
                                case "CircleGeometry":
                                case "CircleBufferGeometry":
                                    s = new r[l.type](l.radius, l.segments, l.thetaStart, l.thetaLength);
                                    break;
                                case "CylinderGeometry":
                                case "CylinderBufferGeometry":
                                    s = new r[l.type](l.radiusTop, l.radiusBottom, l.height, l.radialSegments, l.heightSegments, l.openEnded, l.thetaStart, l.thetaLength);
                                    break;
                                case "SphereGeometry":
                                case "SphereBufferGeometry":
                                    s = new r[l.type](l.radius, l.widthSegments, l.heightSegments, l.phiStart, l.phiLength, l.thetaStart, l.thetaLength);
                                    break;
                                case "DodecahedronGeometry":
                                    s = new r.DodecahedronGeometry(l.radius, l.detail);
                                    break;
                                case "IcosahedronGeometry":
                                    s = new r.IcosahedronGeometry(l.radius, l.detail);
                                    break;
                                case "OctahedronGeometry":
                                    s = new r.OctahedronGeometry(l.radius, l.detail);
                                    break;
                                case "TetrahedronGeometry":
                                    s = new r.TetrahedronGeometry(l.radius, l.detail);
                                    break;
                                case "RingGeometry":
                                case "RingBufferGeometry":
                                    s = new r[l.type](l.innerRadius, l.outerRadius, l.thetaSegments, l.phiSegments, l.thetaStart, l.thetaLength);
                                    break;
                                case "TorusGeometry":
                                case "TorusBufferGeometry":
                                    s = new r[l.type](l.radius, l.tube, l.radialSegments, l.tubularSegments, l.arc);
                                    break;
                                case "TorusKnotGeometry":
                                case "TorusKnotBufferGeometry":
                                    s = new r[l.type](l.radius, l.tube, l.tubularSegments, l.radialSegments, l.p, l.q);
                                    break;
                                case "LatheGeometry":
                                    s = new r.LatheGeometry(l.points, l.segments, l.phiStart, l.phiLength);
                                    break;
                                case "BufferGeometry":
                                    s = n.parse(l);
                                    break;
                                case "Geometry":
                                    s = i.parse(l.data, this.texturePath).geometry;
                                    break;
                                default:
                                    console.warn('THREE.ObjectLoader: Unsupported geometry type "' + l.type + '"');
                                    continue
                            }
                            s.uuid = l.uuid, void 0 !== l.name && (s.name = l.name), t[l.uuid] = s
                        }
                    return t
                },
                parseMaterials: function(e, t) {
                    var i = {};
                    if (void 0 !== e) {
                        var n = new r.MaterialLoader;
                        n.setTextures(t);
                        for (var o = 0, a = e.length; a > o; o++) {
                            var s = n.parse(e[o]);
                            i[s.uuid] = s
                        }
                    }
                    return i
                },
                parseAnimations: function(e) {
                    for (var t = [], i = 0; i < e.length; i++) {
                        var n = r.AnimationClip.parse(e[i]);
                        t.push(n)
                    }
                    return t
                },
                parseImages: function(e, t) {
                    function i(e) {
                        return n.manager.itemStart(e), s.load(e, function() {
                            n.manager.itemEnd(e)
                        })
                    }
                    var n = this,
                        o = {};
                    if (void 0 !== e && e.length > 0) {
                        var a = new r.LoadingManager(t),
                            s = new r.ImageLoader(a);
                        s.setCrossOrigin(this.crossOrigin);
                        for (var l = 0, c = e.length; c > l; l++) {
                            var h = e[l],
                                u = /^(\/\/)|([a-z]+:(\/\/)?)/i.test(h.url) ? h.url : n.texturePath + h.url;
                            o[h.uuid] = i(u)
                        }
                    }
                    return o
                },
                parseTextures: function(e, t) {
                    function i(e) {
                        return "number" == typeof e ? e : (console.warn("THREE.ObjectLoader.parseTexture: Constant should be in numeric form.", e), r[e])
                    }
                    var n = {};
                    if (void 0 !== e)
                        for (var o = 0, a = e.length; a > o; o++) {
                            var s = e[o];
                            void 0 === s.image && console.warn('THREE.ObjectLoader: No "image" specified for', s.uuid), void 0 === t[s.image] && console.warn("THREE.ObjectLoader: Undefined image", s.image);
                            var l = new r.Texture(t[s.image]);
                            l.needsUpdate = !0, l.uuid = s.uuid, void 0 !== s.name && (l.name = s.name), void 0 !== s.mapping && (l.mapping = i(s.mapping)), void 0 !== s.offset && (l.offset = new r.Vector2(s.offset[0], s.offset[1])), void 0 !== s.repeat && (l.repeat = new r.Vector2(s.repeat[0], s.repeat[1])), void 0 !== s.minFilter && (l.minFilter = i(s.minFilter)), void 0 !== s.magFilter && (l.magFilter = i(s.magFilter)), void 0 !== s.anisotropy && (l.anisotropy = s.anisotropy), Array.isArray(s.wrap) && (l.wrapS = i(s.wrap[0]), l.wrapT = i(s.wrap[1])), n[s.uuid] = l
                        }
                    return n
                },
                parseObject: function() {
                    var e = new r.Matrix4;
                    return function(t, i, n) {
                        function o(e) {
                            return void 0 === i[e] && console.warn("THREE.ObjectLoader: Undefined geometry", e), i[e]
                        }

                        function a(e) {
                            return void 0 !== e ? (void 0 === n[e] && console.warn("THREE.ObjectLoader: Undefined material", e), n[e]) : void 0
                        }
                        var s;
                        switch (t.type) {
                            case "Scene":
                                s = new r.Scene;
                                break;
                            case "PerspectiveCamera":
                                s = new r.PerspectiveCamera(t.fov, t.aspect, t.near, t.far);
                                break;
                            case "OrthographicCamera":
                                s = new r.OrthographicCamera(t.left, t.right, t.top, t.bottom, t.near, t.far);
                                break;
                            case "AmbientLight":
                                s = new r.AmbientLight(t.color, t.intensity);
                                break;
                            case "DirectionalLight":
                                s = new r.DirectionalLight(t.color, t.intensity);
                                break;
                            case "PointLight":
                                s = new r.PointLight(t.color, t.intensity, t.distance, t.decay);
                                break;
                            case "SpotLight":
                                s = new r.SpotLight(t.color, t.intensity, t.distance, t.angle, t.penumbra, t.decay);
                                break;
                            case "HemisphereLight":
                                s = new r.HemisphereLight(t.color, t.groundColor, t.intensity);
                                break;
                            case "Mesh":
                                var l = o(t.geometry),
                                    c = a(t.material);
                                s = l.bones && l.bones.length > 0 ? new r.SkinnedMesh(l, c) : new r.Mesh(l, c);
                                break;
                            case "LOD":
                                s = new r.LOD;
                                break;
                            case "Line":
                                s = new r.Line(o(t.geometry), a(t.material), t.mode);
                                break;
                            case "PointCloud":
                            case "Points":
                                s = new r.Points(o(t.geometry), a(t.material));
                                break;
                            case "Sprite":
                                s = new r.Sprite(a(t.material));
                                break;
                            case "Group":
                                s = new r.Group;
                                break;
                            default:
                                s = new r.Object3D
                        }
                        if (s.uuid = t.uuid, void 0 !== t.name && (s.name = t.name), void 0 !== t.matrix ? (e.fromArray(t.matrix), e.decompose(s.position, s.quaternion, s.scale)) : (void 0 !== t.position && s.position.fromArray(t.position), void 0 !== t.rotation && s.rotation.fromArray(t.rotation), void 0 !== t.scale && s.scale.fromArray(t.scale)), void 0 !== t.castShadow && (s.castShadow = t.castShadow), void 0 !== t.receiveShadow && (s.receiveShadow = t.receiveShadow), void 0 !== t.visible && (s.visible = t.visible), void 0 !== t.userData && (s.userData = t.userData), void 0 !== t.children)
                            for (var h in t.children) s.add(this.parseObject(t.children[h], i, n));
                        if ("LOD" === t.type)
                            for (var u = t.levels, p = 0; p < u.length; p++) {
                                var f = u[p],
                                    h = s.getObjectByProperty("uuid", f.object);
                                void 0 !== h && s.addLevel(h, f.distance)
                            }
                        return s
                    }
                }()
            }, r.TextureLoader = function(e) {
                this.manager = void 0 !== e ? e : r.DefaultLoadingManager
            }, r.TextureLoader.prototype = {
                constructor: r.TextureLoader,
                load: function(e, t, i, n) {
                    var o = new r.Texture,
                        a = new r.ImageLoader(this.manager);
                    return a.setCrossOrigin(this.crossOrigin), a.setPath(this.path), a.load(e, function(e) {
                        o.image = e, o.needsUpdate = !0, void 0 !== t && t(o)
                    }, i, n), o
                },
                setCrossOrigin: function(e) {
                    this.crossOrigin = e
                },
                setPath: function(e) {
                    this.path = e
                }
            }, r.CubeTextureLoader = function(e) {
                this.manager = void 0 !== e ? e : r.DefaultLoadingManager
            }, r.CubeTextureLoader.prototype = {
                constructor: r.CubeTextureLoader,
                load: function(e, t, i, n) {
                    function o(i) {
                        s.load(e[i], function(e) {
                            a.images[i] = e, l++, 6 === l && (a.needsUpdate = !0, t && t(a))
                        }, void 0, n)
                    }
                    var a = new r.CubeTexture,
                        s = new r.ImageLoader(this.manager);
                    s.setCrossOrigin(this.crossOrigin), s.setPath(this.path);
                    for (var l = 0, c = 0; c < e.length; ++c) o(c);
                    return a
                },
                setCrossOrigin: function(e) {
                    this.crossOrigin = e
                },
                setPath: function(e) {
                    this.path = e
                }
            }, r.DataTextureLoader = r.BinaryTextureLoader = function(e) {
                this.manager = void 0 !== e ? e : r.DefaultLoadingManager, this._parser = null
            }, r.BinaryTextureLoader.prototype = {
                constructor: r.BinaryTextureLoader,
                load: function(e, t, i, n) {
                    var o = this,
                        a = new r.DataTexture,
                        s = new r.XHRLoader(this.manager);
                    return s.setResponseType("arraybuffer"), s.load(e, function(e) {
                        var i = o._parser(e);
                        i && (void 0 !== i.image ? a.image = i.image : void 0 !== i.data && (a.image.width = i.width, a.image.height = i.height, a.image.data = i.data), a.wrapS = void 0 !== i.wrapS ? i.wrapS : r.ClampToEdgeWrapping, a.wrapT = void 0 !== i.wrapT ? i.wrapT : r.ClampToEdgeWrapping, a.magFilter = void 0 !== i.magFilter ? i.magFilter : r.LinearFilter, a.minFilter = void 0 !== i.minFilter ? i.minFilter : r.LinearMipMapLinearFilter, a.anisotropy = void 0 !== i.anisotropy ? i.anisotropy : 1, void 0 !== i.format && (a.format = i.format), void 0 !== i.type && (a.type = i.type), void 0 !== i.mipmaps && (a.mipmaps = i.mipmaps), 1 === i.mipmapCount && (a.minFilter = r.LinearFilter), a.needsUpdate = !0, t && t(a, i))
                    }, i, n), a
                }
            }, r.CompressedTextureLoader = function(e) {
                this.manager = void 0 !== e ? e : r.DefaultLoadingManager, this._parser = null
            }, r.CompressedTextureLoader.prototype = {
                constructor: r.CompressedTextureLoader,
                load: function(e, t, i, n) {
                    function o(o) {
                        c.load(e[o], function(e) {
                            var i = a._parser(e, !0);
                            s[o] = {
                                width: i.width,
                                height: i.height,
                                format: i.format,
                                mipmaps: i.mipmaps
                            }, h += 1, 6 === h && (1 === i.mipmapCount && (l.minFilter = r.LinearFilter), l.format = i.format, l.needsUpdate = !0, t && t(l))
                        }, i, n)
                    }
                    var a = this,
                        s = [],
                        l = new r.CompressedTexture;
                    l.image = s;
                    var c = new r.XHRLoader(this.manager);
                    if (c.setPath(this.path), c.setResponseType("arraybuffer"), Array.isArray(e))
                        for (var h = 0, u = 0, p = e.length; p > u; ++u) o(u);
                    else c.load(e, function(e) {
                        var i = a._parser(e, !0);
                        if (i.isCubemap)
                            for (var n = i.mipmaps.length / i.mipmapCount, o = 0; n > o; o++) {
                                s[o] = {
                                    mipmaps: []
                                };
                                for (var c = 0; c < i.mipmapCount; c++) s[o].mipmaps.push(i.mipmaps[o * i.mipmapCount + c]), s[o].format = i.format, s[o].width = i.width, s[o].height = i.height
                            } else l.image.width = i.width, l.image.height = i.height, l.mipmaps = i.mipmaps;
                        1 === i.mipmapCount && (l.minFilter = r.LinearFilter), l.format = i.format, l.needsUpdate = !0, t && t(l)
                    }, i, n);
                    return l
                },
                setPath: function(e) {
                    this.path = e
                }
            }, r.Material = function() {
                Object.defineProperty(this, "id", {
                    value: r.MaterialIdCount++
                }), this.uuid = r.Math.generateUUID(), this.name = "", this.type = "Material", this.side = r.FrontSide, this.opacity = 1, this.transparent = !1, this.blending = r.NormalBlending, this.blendSrc = r.SrcAlphaFactor, this.blendDst = r.OneMinusSrcAlphaFactor, this.blendEquation = r.AddEquation, this.blendSrcAlpha = null, this.blendDstAlpha = null, this.blendEquationAlpha = null, this.depthFunc = r.LessEqualDepth, this.depthTest = !0, this.depthWrite = !0, this.colorWrite = !0, this.precision = null, this.polygonOffset = !1, this.polygonOffsetFactor = 0, this.polygonOffsetUnits = 0, this.alphaTest = 0, this.premultipliedAlpha = !1, this.overdraw = 0, this.visible = !0, this._needsUpdate = !0
            }, r.Material.prototype = {
                constructor: r.Material,
                get needsUpdate() {
                    return this._needsUpdate
                },
                set needsUpdate(e) {
                    e === !0 && this.update(), this._needsUpdate = e
                },
                setValues: function(e) {
                    if (void 0 !== e)
                        for (var t in e) {
                            var i = e[t];
                            if (void 0 !== i) {
                                var n = this[t];
                                void 0 !== n ? n instanceof r.Color ? n.set(i) : n instanceof r.Vector3 && i instanceof r.Vector3 ? n.copy(i) : "overdraw" === t ? this[t] = Number(i) : this[t] = i : console.warn("THREE." + this.type + ": '" + t + "' is not a property of this material.")
                            } else console.warn("THREE.Material: '" + t + "' parameter is undefined.")
                        }
                },
                toJSON: function(e) {
                    function t(e) {
                        var t = [];
                        for (var i in e) {
                            var r = e[i];
                            delete r.metadata, t.push(r)
                        }
                        return t
                    }
                    var i = void 0 === e;
                    i && (e = {
                        textures: {},
                        images: {}
                    });
                    var n = {
                        metadata: {
                            version: 4.4,
                            type: "Material",
                            generator: "Material.toJSON"
                        }
                    };
                    if (n.uuid = this.uuid, n.type = this.type, "" !== this.name && (n.name = this.name), this.color instanceof r.Color && (n.color = this.color.getHex()), .5 !== this.roughness && (n.roughness = this.roughness), .5 !== this.metalness && (n.metalness = this.metalness), this.emissive instanceof r.Color && (n.emissive = this.emissive.getHex()), this.specular instanceof r.Color && (n.specular = this.specular.getHex()), void 0 !== this.shininess && (n.shininess = this.shininess), this.map instanceof r.Texture && (n.map = this.map.toJSON(e).uuid), this.alphaMap instanceof r.Texture && (n.alphaMap = this.alphaMap.toJSON(e).uuid), this.lightMap instanceof r.Texture && (n.lightMap = this.lightMap.toJSON(e).uuid), this.bumpMap instanceof r.Texture && (n.bumpMap = this.bumpMap.toJSON(e).uuid, n.bumpScale = this.bumpScale), this.normalMap instanceof r.Texture && (n.normalMap = this.normalMap.toJSON(e).uuid, n.normalScale = this.normalScale.toArray()), this.displacementMap instanceof r.Texture && (n.displacementMap = this.displacementMap.toJSON(e).uuid, n.displacementScale = this.displacementScale, n.displacementBias = this.displacementBias), this.roughnessMap instanceof r.Texture && (n.roughnessMap = this.roughnessMap.toJSON(e).uuid), this.metalnessMap instanceof r.Texture && (n.metalnessMap = this.metalnessMap.toJSON(e).uuid), this.emissiveMap instanceof r.Texture && (n.emissiveMap = this.emissiveMap.toJSON(e).uuid), this.specularMap instanceof r.Texture && (n.specularMap = this.specularMap.toJSON(e).uuid), this.envMap instanceof r.Texture && (n.envMap = this.envMap.toJSON(e).uuid, n.reflectivity = this.reflectivity), void 0 !== this.size && (n.size = this.size), void 0 !== this.sizeAttenuation && (n.sizeAttenuation = this.sizeAttenuation), void 0 !== this.vertexColors && this.vertexColors !== r.NoColors && (n.vertexColors = this.vertexColors), void 0 !== this.shading && this.shading !== r.SmoothShading && (n.shading = this.shading), void 0 !== this.blending && this.blending !== r.NormalBlending && (n.blending = this.blending), void 0 !== this.side && this.side !== r.FrontSide && (n.side = this.side), this.opacity < 1 && (n.opacity = this.opacity), this.transparent === !0 && (n.transparent = this.transparent), this.alphaTest > 0 && (n.alphaTest = this.alphaTest), this.premultipliedAlpha === !0 && (n.premultipliedAlpha = this.premultipliedAlpha), this.wireframe === !0 && (n.wireframe = this.wireframe), this.wireframeLinewidth > 1 && (n.wireframeLinewidth = this.wireframeLinewidth), i) {
                        var o = t(e.textures),
                            a = t(e.images);
                        o.length > 0 && (n.textures = o), a.length > 0 && (n.images = a)
                    }
                    return n
                },
                clone: function() {
                    return (new this.constructor).copy(this)
                },
                copy: function(e) {
                    return this.name = e.name, this.side = e.side, this.opacity = e.opacity, this.transparent = e.transparent, this.blending = e.blending, this.blendSrc = e.blendSrc, this.blendDst = e.blendDst, this.blendEquation = e.blendEquation, this.blendSrcAlpha = e.blendSrcAlpha, this.blendDstAlpha = e.blendDstAlpha, this.blendEquationAlpha = e.blendEquationAlpha, this.depthFunc = e.depthFunc, this.depthTest = e.depthTest, this.depthWrite = e.depthWrite, this.colorWrite = e.colorWrite, this.precision = e.precision, this.polygonOffset = e.polygonOffset, this.polygonOffsetFactor = e.polygonOffsetFactor, this.polygonOffsetUnits = e.polygonOffsetUnits, this.alphaTest = e.alphaTest, this.premultipliedAlpha = e.premultipliedAlpha, this.overdraw = e.overdraw, this.visible = e.visible, this
                },
                update: function() {
                    this.dispatchEvent({
                        type: "update"
                    })
                },
                dispose: function() {
                    this.dispatchEvent({
                        type: "dispose"
                    })
                }
            }, r.EventDispatcher.prototype.apply(r.Material.prototype), r.MaterialIdCount = 0, r.LineBasicMaterial = function(e) {
                r.Material.call(this), this.type = "LineBasicMaterial", this.color = new r.Color(16777215), this.linewidth = 1, this.linecap = "round", this.linejoin = "round", this.blending = r.NormalBlending, this.vertexColors = r.NoColors, this.fog = !0, this.setValues(e)
            }, r.LineBasicMaterial.prototype = Object.create(r.Material.prototype), r.LineBasicMaterial.prototype.constructor = r.LineBasicMaterial, r.LineBasicMaterial.prototype.copy = function(e) {
                return r.Material.prototype.copy.call(this, e), this.color.copy(e.color), this.linewidth = e.linewidth, this.linecap = e.linecap, this.linejoin = e.linejoin, this.vertexColors = e.vertexColors, this.fog = e.fog, this
            }, r.LineDashedMaterial = function(e) {
                r.Material.call(this), this.type = "LineDashedMaterial", this.color = new r.Color(16777215), this.linewidth = 1, this.scale = 1, this.dashSize = 3, this.gapSize = 1, this.blending = r.NormalBlending, this.vertexColors = r.NoColors, this.fog = !0, this.setValues(e)
            }, r.LineDashedMaterial.prototype = Object.create(r.Material.prototype), r.LineDashedMaterial.prototype.constructor = r.LineDashedMaterial, r.LineDashedMaterial.prototype.copy = function(e) {
                return r.Material.prototype.copy.call(this, e), this.color.copy(e.color), this.linewidth = e.linewidth, this.scale = e.scale, this.dashSize = e.dashSize, this.gapSize = e.gapSize, this.vertexColors = e.vertexColors, this.fog = e.fog, this
            }, r.MeshBasicMaterial = function(e) {
                r.Material.call(this), this.type = "MeshBasicMaterial", this.color = new r.Color(16777215), this.map = null, this.aoMap = null, this.aoMapIntensity = 1, this.specularMap = null, this.alphaMap = null, this.envMap = null, this.combine = r.MultiplyOperation, this.reflectivity = 1, this.refractionRatio = .98, this.fog = !0, this.shading = r.SmoothShading, this.blending = r.NormalBlending, this.wireframe = !1, this.wireframeLinewidth = 1, this.wireframeLinecap = "round", this.wireframeLinejoin = "round", this.vertexColors = r.NoColors, this.skinning = !1, this.morphTargets = !1, this.setValues(e)
            }, r.MeshBasicMaterial.prototype = Object.create(r.Material.prototype), r.MeshBasicMaterial.prototype.constructor = r.MeshBasicMaterial, r.MeshBasicMaterial.prototype.copy = function(e) {
                return r.Material.prototype.copy.call(this, e), this.color.copy(e.color), this.map = e.map, this.aoMap = e.aoMap, this.aoMapIntensity = e.aoMapIntensity, this.specularMap = e.specularMap, this.alphaMap = e.alphaMap, this.envMap = e.envMap, this.combine = e.combine, this.reflectivity = e.reflectivity, this.refractionRatio = e.refractionRatio, this.fog = e.fog, this.shading = e.shading, this.wireframe = e.wireframe, this.wireframeLinewidth = e.wireframeLinewidth, this.wireframeLinecap = e.wireframeLinecap, this.wireframeLinejoin = e.wireframeLinejoin, this.vertexColors = e.vertexColors, this.skinning = e.skinning, this.morphTargets = e.morphTargets, this
            }, r.MeshLambertMaterial = function(e) {
                r.Material.call(this), this.type = "MeshLambertMaterial", this.color = new r.Color(16777215), this.map = null, this.lightMap = null, this.lightMapIntensity = 1, this.aoMap = null, this.aoMapIntensity = 1, this.emissive = new r.Color(0), this.emissiveIntensity = 1, this.emissiveMap = null, this.specularMap = null, this.alphaMap = null, this.envMap = null, this.combine = r.MultiplyOperation, this.reflectivity = 1, this.refractionRatio = .98, this.fog = !0, this.blending = r.NormalBlending, this.wireframe = !1, this.wireframeLinewidth = 1, this.wireframeLinecap = "round", this.wireframeLinejoin = "round", this.vertexColors = r.NoColors, this.skinning = !1, this.morphTargets = !1, this.morphNormals = !1, this.setValues(e)
            }, r.MeshLambertMaterial.prototype = Object.create(r.Material.prototype), r.MeshLambertMaterial.prototype.constructor = r.MeshLambertMaterial, r.MeshLambertMaterial.prototype.copy = function(e) {
                return r.Material.prototype.copy.call(this, e), this.color.copy(e.color), this.map = e.map, this.lightMap = e.lightMap, this.lightMapIntensity = e.lightMapIntensity, this.aoMap = e.aoMap, this.aoMapIntensity = e.aoMapIntensity, this.emissive.copy(e.emissive), this.emissiveMap = e.emissiveMap, this.emissiveIntensity = e.emissiveIntensity, this.specularMap = e.specularMap, this.alphaMap = e.alphaMap, this.envMap = e.envMap, this.combine = e.combine, this.reflectivity = e.reflectivity, this.refractionRatio = e.refractionRatio, this.fog = e.fog, this.wireframe = e.wireframe, this.wireframeLinewidth = e.wireframeLinewidth, this.wireframeLinecap = e.wireframeLinecap, this.wireframeLinejoin = e.wireframeLinejoin, this.vertexColors = e.vertexColors, this.skinning = e.skinning, this.morphTargets = e.morphTargets, this.morphNormals = e.morphNormals, this
            }, r.MeshPhongMaterial = function(e) {
                r.Material.call(this), this.type = "MeshPhongMaterial", this.color = new r.Color(16777215), this.specular = new r.Color(1118481), this.shininess = 30, this.map = null, this.lightMap = null, this.lightMapIntensity = 1, this.aoMap = null, this.aoMapIntensity = 1, this.emissive = new r.Color(0), this.emissiveIntensity = 1, this.emissiveMap = null, this.bumpMap = null, this.bumpScale = 1, this.normalMap = null, this.normalScale = new r.Vector2(1, 1), this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.specularMap = null, this.alphaMap = null, this.envMap = null, this.combine = r.MultiplyOperation, this.reflectivity = 1, this.refractionRatio = .98, this.fog = !0, this.shading = r.SmoothShading, this.blending = r.NormalBlending, this.wireframe = !1, this.wireframeLinewidth = 1, this.wireframeLinecap = "round", this.wireframeLinejoin = "round", this.vertexColors = r.NoColors, this.skinning = !1, this.morphTargets = !1, this.morphNormals = !1, this.setValues(e)
            }, r.MeshPhongMaterial.prototype = Object.create(r.Material.prototype), r.MeshPhongMaterial.prototype.constructor = r.MeshPhongMaterial, r.MeshPhongMaterial.prototype.copy = function(e) {
                return r.Material.prototype.copy.call(this, e), this.color.copy(e.color), this.specular.copy(e.specular), this.shininess = e.shininess, this.map = e.map, this.lightMap = e.lightMap, this.lightMapIntensity = e.lightMapIntensity, this.aoMap = e.aoMap, this.aoMapIntensity = e.aoMapIntensity, this.emissive.copy(e.emissive), this.emissiveMap = e.emissiveMap, this.emissiveIntensity = e.emissiveIntensity, this.bumpMap = e.bumpMap, this.bumpScale = e.bumpScale, this.normalMap = e.normalMap, this.normalScale.copy(e.normalScale), this.displacementMap = e.displacementMap, this.displacementScale = e.displacementScale, this.displacementBias = e.displacementBias, this.specularMap = e.specularMap, this.alphaMap = e.alphaMap, this.envMap = e.envMap, this.combine = e.combine, this.reflectivity = e.reflectivity, this.refractionRatio = e.refractionRatio, this.fog = e.fog, this.shading = e.shading, this.wireframe = e.wireframe, this.wireframeLinewidth = e.wireframeLinewidth, this.wireframeLinecap = e.wireframeLinecap, this.wireframeLinejoin = e.wireframeLinejoin, this.vertexColors = e.vertexColors, this.skinning = e.skinning, this.morphTargets = e.morphTargets, this.morphNormals = e.morphNormals, this
            }, r.MeshStandardMaterial = function(e) {
                r.Material.call(this), this.type = "MeshStandardMaterial", this.color = new r.Color(16777215), this.roughness = .5, this.metalness = .5, this.map = null, this.lightMap = null, this.lightMapIntensity = 1, this.aoMap = null, this.aoMapIntensity = 1, this.emissive = new r.Color(0), this.emissiveIntensity = 1, this.emissiveMap = null, this.bumpMap = null, this.bumpScale = 1, this.normalMap = null, this.normalScale = new r.Vector2(1, 1), this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.roughnessMap = null, this.metalnessMap = null, this.alphaMap = null, this.envMap = null, this.envMapIntensity = 1, this.refractionRatio = .98, this.fog = !0, this.shading = r.SmoothShading, this.blending = r.NormalBlending, this.wireframe = !1, this.wireframeLinewidth = 1, this.wireframeLinecap = "round", this.wireframeLinejoin = "round", this.vertexColors = r.NoColors, this.skinning = !1, this.morphTargets = !1, this.morphNormals = !1, this.setValues(e)
            }, r.MeshStandardMaterial.prototype = Object.create(r.Material.prototype), r.MeshStandardMaterial.prototype.constructor = r.MeshStandardMaterial, r.MeshStandardMaterial.prototype.copy = function(e) {
                return r.Material.prototype.copy.call(this, e), this.color.copy(e.color), this.roughness = e.roughness, this.metalness = e.metalness, this.map = e.map, this.lightMap = e.lightMap, this.lightMapIntensity = e.lightMapIntensity, this.aoMap = e.aoMap, this.aoMapIntensity = e.aoMapIntensity, this.emissive.copy(e.emissive), this.emissiveMap = e.emissiveMap, this.emissiveIntensity = e.emissiveIntensity, this.bumpMap = e.bumpMap, this.bumpScale = e.bumpScale, this.normalMap = e.normalMap, this.normalScale.copy(e.normalScale), this.displacementMap = e.displacementMap, this.displacementScale = e.displacementScale, this.displacementBias = e.displacementBias, this.roughnessMap = e.roughnessMap, this.metalnessMap = e.metalnessMap, this.alphaMap = e.alphaMap, this.envMap = e.envMap, this.envMapIntensity = e.envMapIntensity, this.refractionRatio = e.refractionRatio, this.fog = e.fog, this.shading = e.shading, this.wireframe = e.wireframe, this.wireframeLinewidth = e.wireframeLinewidth, this.wireframeLinecap = e.wireframeLinecap, this.wireframeLinejoin = e.wireframeLinejoin, this.vertexColors = e.vertexColors, this.skinning = e.skinning, this.morphTargets = e.morphTargets, this.morphNormals = e.morphNormals, this
            }, r.MeshDepthMaterial = function(e) {
                r.Material.call(this), this.type = "MeshDepthMaterial", this.morphTargets = !1, this.wireframe = !1, this.wireframeLinewidth = 1, this.setValues(e)
            }, r.MeshDepthMaterial.prototype = Object.create(r.Material.prototype), r.MeshDepthMaterial.prototype.constructor = r.MeshDepthMaterial, r.MeshDepthMaterial.prototype.copy = function(e) {
                return r.Material.prototype.copy.call(this, e), this.wireframe = e.wireframe, this.wireframeLinewidth = e.wireframeLinewidth, this
            }, r.MeshNormalMaterial = function(e) {
                r.Material.call(this, e), this.type = "MeshNormalMaterial",
                    this.wireframe = !1, this.wireframeLinewidth = 1, this.morphTargets = !1, this.setValues(e)
            }, r.MeshNormalMaterial.prototype = Object.create(r.Material.prototype), r.MeshNormalMaterial.prototype.constructor = r.MeshNormalMaterial, r.MeshNormalMaterial.prototype.copy = function(e) {
                return r.Material.prototype.copy.call(this, e), this.wireframe = e.wireframe, this.wireframeLinewidth = e.wireframeLinewidth, this
            }, r.MultiMaterial = function(e) {
                this.uuid = r.Math.generateUUID(), this.type = "MultiMaterial", this.materials = e instanceof Array ? e : [], this.visible = !0
            }, r.MultiMaterial.prototype = {
                constructor: r.MultiMaterial,
                toJSON: function(e) {
                    for (var t = {
                            metadata: {
                                version: 4.2,
                                type: "material",
                                generator: "MaterialExporter"
                            },
                            uuid: this.uuid,
                            type: this.type,
                            materials: []
                        }, i = this.materials, r = 0, n = i.length; n > r; r++) {
                        var o = i[r].toJSON(e);
                        delete o.metadata, t.materials.push(o)
                    }
                    return t.visible = this.visible, t
                },
                clone: function() {
                    for (var e = new this.constructor, t = 0; t < this.materials.length; t++) e.materials.push(this.materials[t].clone());
                    return e.visible = this.visible, e
                }
            }, r.PointsMaterial = function(e) {
                r.Material.call(this), this.type = "PointsMaterial", this.color = new r.Color(16777215), this.map = null, this.size = 1, this.sizeAttenuation = !0, this.blending = r.NormalBlending, this.vertexColors = r.NoColors, this.fog = !0, this.setValues(e)
            }, r.PointsMaterial.prototype = Object.create(r.Material.prototype), r.PointsMaterial.prototype.constructor = r.PointsMaterial, r.PointsMaterial.prototype.copy = function(e) {
                return r.Material.prototype.copy.call(this, e), this.color.copy(e.color), this.map = e.map, this.size = e.size, this.sizeAttenuation = e.sizeAttenuation, this.vertexColors = e.vertexColors, this.fog = e.fog, this
            }, r.ShaderMaterial = function(e) {
                r.Material.call(this), this.type = "ShaderMaterial", this.defines = {}, this.uniforms = {}, this.vertexShader = "void main() {\n	gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n}", this.fragmentShader = "void main() {\n	gl_FragColor = vec4( 1.0, 0.0, 0.0, 1.0 );\n}", this.shading = r.SmoothShading, this.linewidth = 1, this.wireframe = !1, this.wireframeLinewidth = 1, this.fog = !1, this.lights = !1, this.vertexColors = r.NoColors, this.skinning = !1, this.morphTargets = !1, this.morphNormals = !1, this.extensions = {
                    derivatives: !1,
                    fragDepth: !1,
                    drawBuffers: !1,
                    shaderTextureLOD: !1
                }, this.defaultAttributeValues = {
                    color: [1, 1, 1],
                    uv: [0, 0],
                    uv2: [0, 0]
                }, this.index0AttributeName = void 0, void 0 !== e && (void 0 !== e.attributes && console.error("THREE.ShaderMaterial: attributes should now be defined in THREE.BufferGeometry instead."), this.setValues(e))
            }, r.ShaderMaterial.prototype = Object.create(r.Material.prototype), r.ShaderMaterial.prototype.constructor = r.ShaderMaterial, r.ShaderMaterial.prototype.copy = function(e) {
                return r.Material.prototype.copy.call(this, e), this.fragmentShader = e.fragmentShader, this.vertexShader = e.vertexShader, this.uniforms = r.UniformsUtils.clone(e.uniforms), this.defines = e.defines, this.shading = e.shading, this.wireframe = e.wireframe, this.wireframeLinewidth = e.wireframeLinewidth, this.fog = e.fog, this.lights = e.lights, this.vertexColors = e.vertexColors, this.skinning = e.skinning, this.morphTargets = e.morphTargets, this.morphNormals = e.morphNormals, this.extensions = e.extensions, this
            }, r.ShaderMaterial.prototype.toJSON = function(e) {
                var t = r.Material.prototype.toJSON.call(this, e);
                return t.uniforms = this.uniforms, t.vertexShader = this.vertexShader, t.fragmentShader = this.fragmentShader, t
            }, r.RawShaderMaterial = function(e) {
                r.ShaderMaterial.call(this, e), this.type = "RawShaderMaterial"
            }, r.RawShaderMaterial.prototype = Object.create(r.ShaderMaterial.prototype), r.RawShaderMaterial.prototype.constructor = r.RawShaderMaterial, r.SpriteMaterial = function(e) {
                r.Material.call(this), this.type = "SpriteMaterial", this.color = new r.Color(16777215), this.map = null, this.rotation = 0, this.fog = !1, this.setValues(e)
            }, r.SpriteMaterial.prototype = Object.create(r.Material.prototype), r.SpriteMaterial.prototype.constructor = r.SpriteMaterial, r.SpriteMaterial.prototype.copy = function(e) {
                return r.Material.prototype.copy.call(this, e), this.color.copy(e.color), this.map = e.map, this.rotation = e.rotation, this.fog = e.fog, this
            }, r.Texture = function(e, t, i, n, o, a, s, l, c) {
                Object.defineProperty(this, "id", {
                    value: r.TextureIdCount++
                }), this.uuid = r.Math.generateUUID(), this.name = "", this.sourceFile = "", this.image = void 0 !== e ? e : r.Texture.DEFAULT_IMAGE, this.mipmaps = [], this.mapping = void 0 !== t ? t : r.Texture.DEFAULT_MAPPING, this.wrapS = void 0 !== i ? i : r.ClampToEdgeWrapping, this.wrapT = void 0 !== n ? n : r.ClampToEdgeWrapping, this.magFilter = void 0 !== o ? o : r.LinearFilter, this.minFilter = void 0 !== a ? a : r.LinearMipMapLinearFilter, this.anisotropy = void 0 !== c ? c : 1, this.format = void 0 !== s ? s : r.RGBAFormat, this.type = void 0 !== l ? l : r.UnsignedByteType, this.offset = new r.Vector2(0, 0), this.repeat = new r.Vector2(1, 1), this.generateMipmaps = !0, this.premultiplyAlpha = !1, this.flipY = !0, this.unpackAlignment = 4, this.encoding = r.LinearEncoding, this.version = 0, this.onUpdate = null
            }, r.Texture.DEFAULT_IMAGE = void 0, r.Texture.DEFAULT_MAPPING = r.UVMapping, r.Texture.prototype = {
                constructor: r.Texture,
                set needsUpdate(e) {
                    e === !0 && this.version++
                },
                clone: function() {
                    return (new this.constructor).copy(this)
                },
                copy: function(e) {
                    return this.image = e.image, this.mipmaps = e.mipmaps.slice(0), this.mapping = e.mapping, this.wrapS = e.wrapS, this.wrapT = e.wrapT, this.magFilter = e.magFilter, this.minFilter = e.minFilter, this.anisotropy = e.anisotropy, this.format = e.format, this.type = e.type, this.offset.copy(e.offset), this.repeat.copy(e.repeat), this.generateMipmaps = e.generateMipmaps, this.premultiplyAlpha = e.premultiplyAlpha, this.flipY = e.flipY, this.unpackAlignment = e.unpackAlignment, this.encoding = e.encoding, this
                },
                toJSON: function(e) {
                    function t(e) {
                        var t;
                        return void 0 !== e.toDataURL ? t = e : (t = document.createElement("canvas"), t.width = e.width, t.height = e.height, t.getContext("2d").drawImage(e, 0, 0, e.width, e.height)), t.width > 2048 || t.height > 2048 ? t.toDataURL("image/jpeg", .6) : t.toDataURL("image/png")
                    }
                    if (void 0 !== e.textures[this.uuid]) return e.textures[this.uuid];
                    var i = {
                        metadata: {
                            version: 4.4,
                            type: "Texture",
                            generator: "Texture.toJSON"
                        },
                        uuid: this.uuid,
                        name: this.name,
                        mapping: this.mapping,
                        repeat: [this.repeat.x, this.repeat.y],
                        offset: [this.offset.x, this.offset.y],
                        wrap: [this.wrapS, this.wrapT],
                        minFilter: this.minFilter,
                        magFilter: this.magFilter,
                        anisotropy: this.anisotropy
                    };
                    if (void 0 !== this.image) {
                        var n = this.image;
                        void 0 === n.uuid && (n.uuid = r.Math.generateUUID()), void 0 === e.images[n.uuid] && (e.images[n.uuid] = {
                            uuid: n.uuid,
                            url: t(n)
                        }), i.image = n.uuid
                    }
                    return e.textures[this.uuid] = i, i
                },
                dispose: function() {
                    this.dispatchEvent({
                        type: "dispose"
                    })
                },
                transformUv: function(e) {
                    if (this.mapping === r.UVMapping) {
                        if (e.multiply(this.repeat), e.add(this.offset), e.x < 0 || e.x > 1) switch (this.wrapS) {
                            case r.RepeatWrapping:
                                e.x = e.x - Math.floor(e.x);
                                break;
                            case r.ClampToEdgeWrapping:
                                e.x = e.x < 0 ? 0 : 1;
                                break;
                            case r.MirroredRepeatWrapping:
                                1 === Math.abs(Math.floor(e.x) % 2) ? e.x = Math.ceil(e.x) - e.x : e.x = e.x - Math.floor(e.x)
                        }
                        if (e.y < 0 || e.y > 1) switch (this.wrapT) {
                            case r.RepeatWrapping:
                                e.y = e.y - Math.floor(e.y);
                                break;
                            case r.ClampToEdgeWrapping:
                                e.y = e.y < 0 ? 0 : 1;
                                break;
                            case r.MirroredRepeatWrapping:
                                1 === Math.abs(Math.floor(e.y) % 2) ? e.y = Math.ceil(e.y) - e.y : e.y = e.y - Math.floor(e.y)
                        }
                        this.flipY && (e.y = 1 - e.y)
                    }
                }
            }, r.EventDispatcher.prototype.apply(r.Texture.prototype), r.TextureIdCount = 0, r.CanvasTexture = function(e, t, i, n, o, a, s, l, c) {
                r.Texture.call(this, e, t, i, n, o, a, s, l, c), this.needsUpdate = !0
            }, r.CanvasTexture.prototype = Object.create(r.Texture.prototype), r.CanvasTexture.prototype.constructor = r.CanvasTexture, r.CubeTexture = function(e, t, i, n, o, a, s, l, c) {
                e = void 0 !== e ? e : [], t = void 0 !== t ? t : r.CubeReflectionMapping, r.Texture.call(this, e, t, i, n, o, a, s, l, c), this.flipY = !1
            }, r.CubeTexture.prototype = Object.create(r.Texture.prototype), r.CubeTexture.prototype.constructor = r.CubeTexture, Object.defineProperty(r.CubeTexture.prototype, "images", {
                get: function() {
                    return this.image
                },
                set: function(e) {
                    this.image = e
                }
            }), r.CompressedTexture = function(e, t, i, n, o, a, s, l, c, h, u) {
                r.Texture.call(this, null, a, s, l, c, h, n, o, u), this.image = {
                    width: t,
                    height: i
                }, this.mipmaps = e, this.flipY = !1, this.generateMipmaps = !1
            }, r.CompressedTexture.prototype = Object.create(r.Texture.prototype), r.CompressedTexture.prototype.constructor = r.CompressedTexture, r.DataTexture = function(e, t, i, n, o, a, s, l, c, h, u) {
                r.Texture.call(this, null, a, s, l, c, h, n, o, u), this.image = {
                    data: e,
                    width: t,
                    height: i
                }, this.magFilter = void 0 !== c ? c : r.NearestFilter, this.minFilter = void 0 !== h ? h : r.NearestFilter, this.flipY = !1, this.generateMipmaps = !1
            }, r.DataTexture.prototype = Object.create(r.Texture.prototype), r.DataTexture.prototype.constructor = r.DataTexture, r.VideoTexture = function(e, t, i, n, o, a, s, l, c) {
                function h() {
                    requestAnimationFrame(h), e.readyState === e.HAVE_ENOUGH_DATA && (u.needsUpdate = !0)
                }
                r.Texture.call(this, e, t, i, n, o, a, s, l, c), this.generateMipmaps = !1;
                var u = this;
                h()
            }, r.VideoTexture.prototype = Object.create(r.Texture.prototype), r.VideoTexture.prototype.constructor = r.VideoTexture, r.Group = function() {
                r.Object3D.call(this), this.type = "Group"
            }, r.Group.prototype = Object.create(r.Object3D.prototype), r.Group.prototype.constructor = r.Group, r.Points = function(e, t) {
                r.Object3D.call(this), this.type = "Points", this.geometry = void 0 !== e ? e : new r.Geometry, this.material = void 0 !== t ? t : new r.PointsMaterial({
                    color: 16777215 * Math.random()
                })
            }, r.Points.prototype = Object.create(r.Object3D.prototype), r.Points.prototype.constructor = r.Points, r.Points.prototype.raycast = function() {
                var e = new r.Matrix4,
                    t = new r.Ray,
                    i = new r.Sphere;
                return function(n, o) {
                    function a(e, i) {
                        var r = t.distanceSqToPoint(e);
                        if (p > r) {
                            var a = t.closestPointToPoint(e);
                            a.applyMatrix4(c);
                            var l = n.ray.origin.distanceTo(a);
                            if (l < n.near || l > n.far) return;
                            o.push({
                                distance: l,
                                distanceToRay: Math.sqrt(r),
                                point: a.clone(),
                                index: i,
                                face: null,
                                object: s
                            })
                        }
                    }
                    var s = this,
                        l = this.geometry,
                        c = this.matrixWorld,
                        h = n.params.Points.threshold;
                    if (null === l.boundingSphere && l.computeBoundingSphere(), i.copy(l.boundingSphere), i.applyMatrix4(c), n.ray.intersectsSphere(i) !== !1) {
                        e.getInverse(c), t.copy(n.ray).applyMatrix4(e);
                        var u = h / ((this.scale.x + this.scale.y + this.scale.z) / 3),
                            p = u * u,
                            f = new r.Vector3;
                        if (l instanceof r.BufferGeometry) {
                            var d = l.index,
                                m = l.attributes,
                                g = m.position.array;
                            if (null !== d)
                                for (var v = d.array, y = 0, _ = v.length; _ > y; y++) {
                                    var x = v[y];
                                    f.fromArray(g, 3 * x), a(f, x)
                                } else
                                    for (var y = 0, b = g.length / 3; b > y; y++) f.fromArray(g, 3 * y), a(f, y)
                        } else
                            for (var w = l.vertices, y = 0, b = w.length; b > y; y++) a(w[y], y)
                    }
                }
            }(), r.Points.prototype.clone = function() {
                return new this.constructor(this.geometry, this.material).copy(this)
            }, r.Line = function(e, t, i) {
                return 1 === i ? (console.warn("THREE.Line: parameter THREE.LinePieces no longer supported. Created THREE.LineSegments instead."), new r.LineSegments(e, t)) : (r.Object3D.call(this), this.type = "Line", this.geometry = void 0 !== e ? e : new r.Geometry, void(this.material = void 0 !== t ? t : new r.LineBasicMaterial({
                    color: 16777215 * Math.random()
                })))
            }, r.Line.prototype = Object.create(r.Object3D.prototype), r.Line.prototype.constructor = r.Line, r.Line.prototype.raycast = function() {
                var e = new r.Matrix4,
                    t = new r.Ray,
                    i = new r.Sphere;
                return function(n, o) {
                    var a = n.linePrecision,
                        s = a * a,
                        l = this.geometry,
                        c = this.matrixWorld;
                    if (null === l.boundingSphere && l.computeBoundingSphere(), i.copy(l.boundingSphere), i.applyMatrix4(c), n.ray.intersectsSphere(i) !== !1) {
                        e.getInverse(c), t.copy(n.ray).applyMatrix4(e);
                        var h = new r.Vector3,
                            u = new r.Vector3,
                            p = new r.Vector3,
                            f = new r.Vector3,
                            d = this instanceof r.LineSegments ? 2 : 1;
                        if (l instanceof r.BufferGeometry) {
                            var m = l.index,
                                g = l.attributes,
                                v = g.position.array;
                            if (null !== m)
                                for (var y = m.array, _ = 0, x = y.length - 1; x > _; _ += d) {
                                    var b = y[_],
                                        w = y[_ + 1];
                                    h.fromArray(v, 3 * b), u.fromArray(v, 3 * w);
                                    var T = t.distanceSqToSegment(h, u, f, p);
                                    if (!(T > s)) {
                                        f.applyMatrix4(this.matrixWorld);
                                        var M = n.ray.origin.distanceTo(f);
                                        M < n.near || M > n.far || o.push({
                                            distance: M,
                                            point: p.clone().applyMatrix4(this.matrixWorld),
                                            index: _,
                                            face: null,
                                            faceIndex: null,
                                            object: this
                                        })
                                    }
                                } else
                                    for (var _ = 0, x = v.length / 3 - 1; x > _; _ += d) {
                                        h.fromArray(v, 3 * _), u.fromArray(v, 3 * _ + 3);
                                        var T = t.distanceSqToSegment(h, u, f, p);
                                        if (!(T > s)) {
                                            f.applyMatrix4(this.matrixWorld);
                                            var M = n.ray.origin.distanceTo(f);
                                            M < n.near || M > n.far || o.push({
                                                distance: M,
                                                point: p.clone().applyMatrix4(this.matrixWorld),
                                                index: _,
                                                face: null,
                                                faceIndex: null,
                                                object: this
                                            })
                                        }
                                    }
                        } else if (l instanceof r.Geometry)
                            for (var S = l.vertices, E = S.length, _ = 0; E - 1 > _; _ += d) {
                                var T = t.distanceSqToSegment(S[_], S[_ + 1], f, p);
                                if (!(T > s)) {
                                    f.applyMatrix4(this.matrixWorld);
                                    var M = n.ray.origin.distanceTo(f);
                                    M < n.near || M > n.far || o.push({
                                        distance: M,
                                        point: p.clone().applyMatrix4(this.matrixWorld),
                                        index: _,
                                        face: null,
                                        faceIndex: null,
                                        object: this
                                    })
                                }
                            }
                    }
                }
            }(), r.Line.prototype.clone = function() {
                return new this.constructor(this.geometry, this.material).copy(this)
            }, r.LineStrip = 0, r.LinePieces = 1, r.LineSegments = function(e, t) {
                r.Line.call(this, e, t), this.type = "LineSegments"
            }, r.LineSegments.prototype = Object.create(r.Line.prototype), r.LineSegments.prototype.constructor = r.LineSegments, r.Mesh = function(e, t) {
                r.Object3D.call(this), this.type = "Mesh", this.geometry = void 0 !== e ? e : new r.Geometry, this.material = void 0 !== t ? t : new r.MeshBasicMaterial({
                    color: 16777215 * Math.random()
                }), this.drawMode = r.TrianglesDrawMode, this.updateMorphTargets()
            }, r.Mesh.prototype = Object.create(r.Object3D.prototype), r.Mesh.prototype.constructor = r.Mesh, r.Mesh.prototype.setDrawMode = function(e) {
                this.drawMode = e
            }, r.Mesh.prototype.updateMorphTargets = function() {
                if (void 0 !== this.geometry.morphTargets && this.geometry.morphTargets.length > 0) {
                    this.morphTargetBase = -1, this.morphTargetInfluences = [], this.morphTargetDictionary = {};
                    for (var e = 0, t = this.geometry.morphTargets.length; t > e; e++) this.morphTargetInfluences.push(0), this.morphTargetDictionary[this.geometry.morphTargets[e].name] = e
                }
            }, r.Mesh.prototype.getMorphTargetIndexByName = function(e) {
                return void 0 !== this.morphTargetDictionary[e] ? this.morphTargetDictionary[e] : (console.warn("THREE.Mesh.getMorphTargetIndexByName: morph target " + e + " does not exist. Returning 0."), 0)
            }, r.Mesh.prototype.raycast = function() {
                function e(e, t, i, n, o, a, s) {
                    return r.Triangle.barycoordFromPoint(e, t, i, n, g), o.multiplyScalar(g.x), a.multiplyScalar(g.y), s.multiplyScalar(g.z), o.add(a).add(s), o.clone()
                }

                function t(e, t, i, n, o, a, s) {
                    var l, c = e.material;
                    if (l = c.side === r.BackSide ? i.intersectTriangle(a, o, n, !0, s) : i.intersectTriangle(n, o, a, c.side !== r.DoubleSide, s), null === l) return null;
                    y.copy(s), y.applyMatrix4(e.matrixWorld);
                    var h = t.ray.origin.distanceTo(y);
                    return h < t.near || h > t.far ? null : {
                        distance: h,
                        point: y.clone(),
                        object: e
                    }
                }

                function i(i, n, o, a, h, u, p, g) {
                    s.fromArray(a, 3 * u), l.fromArray(a, 3 * p), c.fromArray(a, 3 * g);
                    var y = t(i, n, o, s, l, c, v);
                    return y && (h && (f.fromArray(h, 2 * u), d.fromArray(h, 2 * p), m.fromArray(h, 2 * g), y.uv = e(v, s, l, c, f, d, m)), y.face = new r.Face3(u, p, g, r.Triangle.normal(s, l, c)), y.faceIndex = u), y
                }
                var n = new r.Matrix4,
                    o = new r.Ray,
                    a = new r.Sphere,
                    s = new r.Vector3,
                    l = new r.Vector3,
                    c = new r.Vector3,
                    h = new r.Vector3,
                    u = new r.Vector3,
                    p = new r.Vector3,
                    f = new r.Vector2,
                    d = new r.Vector2,
                    m = new r.Vector2,
                    g = new r.Vector3,
                    v = new r.Vector3,
                    y = new r.Vector3;
                return function(g, y) {
                    var _ = this.geometry,
                        x = this.material,
                        b = this.matrixWorld;
                    if (void 0 !== x && (null === _.boundingSphere && _.computeBoundingSphere(), a.copy(_.boundingSphere), a.applyMatrix4(b), g.ray.intersectsSphere(a) !== !1 && (n.getInverse(b), o.copy(g.ray).applyMatrix4(n), null === _.boundingBox || o.intersectsBox(_.boundingBox) !== !1))) {
                        var w, T;
                        if (_ instanceof r.BufferGeometry) {
                            var M, S, E, A = _.index,
                                C = _.attributes,
                                L = C.position.array;
                            if (void 0 !== C.uv && (w = C.uv.array), null !== A)
                                for (var P = A.array, R = 0, D = P.length; D > R; R += 3) M = P[R], S = P[R + 1], E = P[R + 2], T = i(this, g, o, L, w, M, S, E), T && (T.faceIndex = Math.floor(R / 3), y.push(T));
                            else
                                for (var R = 0, D = L.length; D > R; R += 9) M = R / 3, S = M + 1, E = M + 2, T = i(this, g, o, L, w, M, S, E), T && (T.index = M, y.push(T))
                        } else if (_ instanceof r.Geometry) {
                            var O, I, F, N = x instanceof r.MultiMaterial,
                                B = N === !0 ? x.materials : null,
                                k = _.vertices,
                                U = _.faces,
                                V = _.faceVertexUvs[0];
                            V.length > 0 && (w = V);
                            for (var z = 0, G = U.length; G > z; z++) {
                                var H = U[z],
                                    j = N === !0 ? B[H.materialIndex] : x;
                                if (void 0 !== j) {
                                    if (O = k[H.a], I = k[H.b], F = k[H.c], j.morphTargets === !0) {
                                        var W = _.morphTargets,
                                            X = this.morphTargetInfluences;
                                        s.set(0, 0, 0), l.set(0, 0, 0), c.set(0, 0, 0);
                                        for (var q = 0, Y = W.length; Y > q; q++) {
                                            var Z = X[q];
                                            if (0 !== Z) {
                                                var Q = W[q].vertices;
                                                s.addScaledVector(h.subVectors(Q[H.a], O), Z), l.addScaledVector(u.subVectors(Q[H.b], I), Z), c.addScaledVector(p.subVectors(Q[H.c], F), Z)
                                            }
                                        }
                                        s.add(O), l.add(I), c.add(F), O = s, I = l, F = c
                                    }
                                    if (T = t(this, g, o, O, I, F, v)) {
                                        if (w) {
                                            var K = w[z];
                                            f.copy(K[0]), d.copy(K[1]), m.copy(K[2]), T.uv = e(v, O, I, F, f, d, m)
                                        }
                                        T.face = H, T.faceIndex = z, y.push(T)
                                    }
                                }
                            }
                        }
                    }
                }
            }(), r.Mesh.prototype.clone = function() {
                return new this.constructor(this.geometry, this.material).copy(this)
            }, r.Bone = function(e) {
                r.Object3D.call(this), this.type = "Bone", this.skin = e
            }, r.Bone.prototype = Object.create(r.Object3D.prototype), r.Bone.prototype.constructor = r.Bone, r.Bone.prototype.copy = function(e) {
                return r.Object3D.prototype.copy.call(this, e), this.skin = e.skin, this
            }, r.Skeleton = function(e, t, i) {
                if (this.useVertexTexture = void 0 !== i ? i : !0, this.identityMatrix = new r.Matrix4, e = e || [], this.bones = e.slice(0), this.useVertexTexture) {
                    var n = Math.sqrt(4 * this.bones.length);
                    n = r.Math.nextPowerOfTwo(Math.ceil(n)), n = Math.max(n, 4), this.boneTextureWidth = n, this.boneTextureHeight = n, this.boneMatrices = new Float32Array(this.boneTextureWidth * this.boneTextureHeight * 4), this.boneTexture = new r.DataTexture(this.boneMatrices, this.boneTextureWidth, this.boneTextureHeight, r.RGBAFormat, r.FloatType)
                } else this.boneMatrices = new Float32Array(16 * this.bones.length);
                if (void 0 === t) this.calculateInverses();
                else if (this.bones.length === t.length) this.boneInverses = t.slice(0);
                else {
                    console.warn("THREE.Skeleton bonInverses is the wrong length."), this.boneInverses = [];
                    for (var o = 0, a = this.bones.length; a > o; o++) this.boneInverses.push(new r.Matrix4)
                }
            }, r.Skeleton.prototype.calculateInverses = function() {
                this.boneInverses = [];
                for (var e = 0, t = this.bones.length; t > e; e++) {
                    var i = new r.Matrix4;
                    this.bones[e] && i.getInverse(this.bones[e].matrixWorld), this.boneInverses.push(i)
                }
            }, r.Skeleton.prototype.pose = function() {
                for (var e, t = 0, i = this.bones.length; i > t; t++) e = this.bones[t], e && e.matrixWorld.getInverse(this.boneInverses[t]);
                for (var t = 0, i = this.bones.length; i > t; t++) e = this.bones[t], e && (e.parent ? (e.matrix.getInverse(e.parent.matrixWorld), e.matrix.multiply(e.matrixWorld)) : e.matrix.copy(e.matrixWorld), e.matrix.decompose(e.position, e.quaternion, e.scale))
            }, r.Skeleton.prototype.update = function() {
                var e = new r.Matrix4;
                return function() {
                    for (var t = 0, i = this.bones.length; i > t; t++) {
                        var r = this.bones[t] ? this.bones[t].matrixWorld : this.identityMatrix;
                        e.multiplyMatrices(r, this.boneInverses[t]), e.flattenToArrayOffset(this.boneMatrices, 16 * t)
                    }
                    this.useVertexTexture && (this.boneTexture.needsUpdate = !0)
                }
            }(), r.Skeleton.prototype.clone = function() {
                return new r.Skeleton(this.bones, this.boneInverses, this.useVertexTexture)
            }, r.SkinnedMesh = function(e, t, i) {
                r.Mesh.call(this, e, t), this.type = "SkinnedMesh", this.bindMode = "attached", this.bindMatrix = new r.Matrix4, this.bindMatrixInverse = new r.Matrix4;
                var n = [];
                if (this.geometry && void 0 !== this.geometry.bones) {
                    for (var o, a, s = 0, l = this.geometry.bones.length; l > s; ++s) a = this.geometry.bones[s], o = new r.Bone(this), n.push(o), o.name = a.name, o.position.fromArray(a.pos), o.quaternion.fromArray(a.rotq), void 0 !== a.scl && o.scale.fromArray(a.scl);
                    for (var s = 0, l = this.geometry.bones.length; l > s; ++s) a = this.geometry.bones[s], -1 !== a.parent && null !== a.parent ? n[a.parent].add(n[s]) : this.add(n[s])
                }
                this.normalizeSkinWeights(), this.updateMatrixWorld(!0), this.bind(new r.Skeleton(n, void 0, i), this.matrixWorld)
            }, r.SkinnedMesh.prototype = Object.create(r.Mesh.prototype), r.SkinnedMesh.prototype.constructor = r.SkinnedMesh, r.SkinnedMesh.prototype.bind = function(e, t) {
                this.skeleton = e, void 0 === t && (this.updateMatrixWorld(!0), this.skeleton.calculateInverses(), t = this.matrixWorld), this.bindMatrix.copy(t), this.bindMatrixInverse.getInverse(t)
            }, r.SkinnedMesh.prototype.pose = function() {
                this.skeleton.pose()
            }, r.SkinnedMesh.prototype.normalizeSkinWeights = function() {
                if (this.geometry instanceof r.Geometry)
                    for (var e = 0; e < this.geometry.skinWeights.length; e++) {
                        var t = this.geometry.skinWeights[e],
                            i = 1 / t.lengthManhattan();
                        i !== 1 / 0 ? t.multiplyScalar(i) : t.set(1, 0, 0, 0)
                    } else if (this.geometry instanceof r.BufferGeometry)
                        for (var n = new r.Vector4, o = this.geometry.attributes.skinWeight, e = 0; e < o.count; e++) {
                            n.x = o.getX(e), n.y = o.getY(e), n.z = o.getZ(e), n.w = o.getW(e);
                            var i = 1 / n.lengthManhattan();
                            i !== 1 / 0 ? n.multiplyScalar(i) : n.set(1, 0, 0, 0), o.setXYZW(e, n.x, n.y, n.z, n.w)
                        }
            }, r.SkinnedMesh.prototype.updateMatrixWorld = function(e) {
                r.Mesh.prototype.updateMatrixWorld.call(this, !0), "attached" === this.bindMode ? this.bindMatrixInverse.getInverse(this.matrixWorld) : "detached" === this.bindMode ? this.bindMatrixInverse.getInverse(this.bindMatrix) : console.warn("THREE.SkinnedMesh unrecognized bindMode: " + this.bindMode)
            }, r.SkinnedMesh.prototype.clone = function() {
                return new this.constructor(this.geometry, this.material, this.useVertexTexture).copy(this)
            }, r.LOD = function() {
                r.Object3D.call(this), this.type = "LOD", Object.defineProperties(this, {
                    levels: {
                        enumerable: !0,
                        value: []
                    },
                    objects: {
                        get: function() {
                            return console.warn("THREE.LOD: .objects has been renamed to .levels."), this.levels
                        }
                    }
                })
            }, r.LOD.prototype = Object.create(r.Object3D.prototype), r.LOD.prototype.constructor = r.LOD, r.LOD.prototype.addLevel = function(e, t) {
                void 0 === t && (t = 0), t = Math.abs(t);
                for (var i = this.levels, r = 0; r < i.length && !(t < i[r].distance); r++);
                i.splice(r, 0, {
                    distance: t,
                    object: e
                }), this.add(e)
            }, r.LOD.prototype.getObjectForDistance = function(e) {
                for (var t = this.levels, i = 1, r = t.length; r > i && !(e < t[i].distance); i++);
                return t[i - 1].object
            }, r.LOD.prototype.raycast = function() {
                var e = new r.Vector3;
                return function(t, i) {
                    e.setFromMatrixPosition(this.matrixWorld);
                    var r = t.ray.origin.distanceTo(e);
                    this.getObjectForDistance(r).raycast(t, i)
                }
            }(), r.LOD.prototype.update = function() {
                var e = new r.Vector3,
                    t = new r.Vector3;
                return function(i) {
                    var r = this.levels;
                    if (r.length > 1) {
                        e.setFromMatrixPosition(i.matrixWorld), t.setFromMatrixPosition(this.matrixWorld);
                        var n = e.distanceTo(t);
                        r[0].object.visible = !0;
                        for (var o = 1, a = r.length; a > o && n >= r[o].distance; o++) r[o - 1].object.visible = !1, r[o].object.visible = !0;
                        for (; a > o; o++) r[o].object.visible = !1
                    }
                }
            }(), r.LOD.prototype.copy = function(e) {
                r.Object3D.prototype.copy.call(this, e, !1);
                for (var t = e.levels, i = 0, n = t.length; n > i; i++) {
                    var o = t[i];
                    this.addLevel(o.object.clone(), o.distance)
                }
                return this
            }, r.LOD.prototype.toJSON = function(e) {
                var t = r.Object3D.prototype.toJSON.call(this, e);
                t.object.levels = [];
                for (var i = this.levels, n = 0, o = i.length; o > n; n++) {
                    var a = i[n];
                    t.object.levels.push({
                        object: a.object.uuid,
                        distance: a.distance
                    })
                }
                return t
            }, r.Sprite = function() {
                var e = new Uint16Array([0, 1, 2, 0, 2, 3]),
                    t = new Float32Array([-.5, -.5, 0, .5, -.5, 0, .5, .5, 0, -.5, .5, 0]),
                    i = new Float32Array([0, 0, 1, 0, 1, 1, 0, 1]),
                    n = new r.BufferGeometry;
                return n.setIndex(new r.BufferAttribute(e, 1)), n.addAttribute("position", new r.BufferAttribute(t, 3)), n.addAttribute("uv", new r.BufferAttribute(i, 2)),
                    function(e) {
                        r.Object3D.call(this), this.type = "Sprite", this.geometry = n, this.material = void 0 !== e ? e : new r.SpriteMaterial
                    }
            }(), r.Sprite.prototype = Object.create(r.Object3D.prototype), r.Sprite.prototype.constructor = r.Sprite, r.Sprite.prototype.raycast = function() {
                var e = new r.Vector3;
                return function(t, i) {
                    e.setFromMatrixPosition(this.matrixWorld);
                    var r = t.ray.distanceSqToPoint(e),
                        n = this.scale.x * this.scale.y;
                    r > n || i.push({
                        distance: Math.sqrt(r),
                        point: this.position,
                        face: null,
                        object: this
                    })
                }
            }(), r.Sprite.prototype.clone = function() {
                return new this.constructor(this.material).copy(this)
            }, r.Particle = r.Sprite, r.LensFlare = function(e, t, i, n, o) {
                r.Object3D.call(this), this.lensFlares = [], this.positionScreen = new r.Vector3, this.customUpdateCallback = void 0, void 0 !== e && this.add(e, t, i, n, o)
            }, r.LensFlare.prototype = Object.create(r.Object3D.prototype), r.LensFlare.prototype.constructor = r.LensFlare, r.LensFlare.prototype.add = function(e, t, i, n, o, a) {
                void 0 === t && (t = -1), void 0 === i && (i = 0), void 0 === a && (a = 1), void 0 === o && (o = new r.Color(16777215)), void 0 === n && (n = r.NormalBlending), i = Math.min(i, Math.max(0, i)), this.lensFlares.push({
                    texture: e,
                    size: t,
                    distance: i,
                    x: 0,
                    y: 0,
                    z: 0,
                    scale: 1,
                    rotation: 0,
                    opacity: a,
                    color: o,
                    blending: n
                })
            }, r.LensFlare.prototype.updateLensFlares = function() {
                var e, t, i = this.lensFlares.length,
                    r = 2 * -this.positionScreen.x,
                    n = 2 * -this.positionScreen.y;
                for (e = 0; i > e; e++) t = this.lensFlares[e], t.x = this.positionScreen.x + r * t.distance, t.y = this.positionScreen.y + n * t.distance, t.wantedRotation = t.x * Math.PI * .25, t.rotation += .25 * (t.wantedRotation - t.rotation)
            }, r.LensFlare.prototype.copy = function(e) {
                r.Object3D.prototype.copy.call(this, e), this.positionScreen.copy(e.positionScreen), this.customUpdateCallback = e.customUpdateCallback;
                for (var t = 0, i = e.lensFlares.length; i > t; t++) this.lensFlares.push(e.lensFlares[t]);
                return this
            }, r.Scene = function() {
                r.Object3D.call(this), this.type = "Scene", this.fog = null, this.overrideMaterial = null, this.autoUpdate = !0
            }, r.Scene.prototype = Object.create(r.Object3D.prototype), r.Scene.prototype.constructor = r.Scene, r.Scene.prototype.copy = function(e, t) {
                return r.Object3D.prototype.copy.call(this, e, t), null !== e.fog && (this.fog = e.fog.clone()), null !== e.overrideMaterial && (this.overrideMaterial = e.overrideMaterial.clone()), this.autoUpdate = e.autoUpdate, this.matrixAutoUpdate = e.matrixAutoUpdate, this
            }, r.Fog = function(e, t, i) {
                this.name = "", this.color = new r.Color(e), this.near = void 0 !== t ? t : 1, this.far = void 0 !== i ? i : 1e3
            }, r.Fog.prototype.clone = function() {
                return new r.Fog(this.color.getHex(), this.near, this.far)
            }, r.FogExp2 = function(e, t) {
                this.name = "", this.color = new r.Color(e), this.density = void 0 !== t ? t : 25e-5
            }, r.FogExp2.prototype.clone = function() {
                return new r.FogExp2(this.color.getHex(), this.density)
            }, r.ShaderChunk = {}, r.ShaderChunk.alphamap_fragment = "#ifdef USE_ALPHAMAP\n	diffuseColor.a *= texture2D( alphaMap, vUv ).g;\n#endif\n", r.ShaderChunk.alphamap_pars_fragment = "#ifdef USE_ALPHAMAP\n	uniform sampler2D alphaMap;\n#endif\n", r.ShaderChunk.alphatest_fragment = "#ifdef ALPHATEST\n	if ( diffuseColor.a < ALPHATEST ) discard;\n#endif\n", r.ShaderChunk.aomap_fragment = "#ifdef USE_AOMAP\n	float ambientOcclusion = ( texture2D( aoMap, vUv2 ).r - 1.0 ) * aoMapIntensity + 1.0;\n	reflectedLight.indirectDiffuse *= ambientOcclusion;\n	#if defined( USE_ENVMAP ) && defined( STANDARD )\n		float dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );\n		reflectedLight.indirectSpecular *= computeSpecularOcclusion( dotNV, ambientOcclusion, material.specularRoughness );\n	#endif\n#endif\n", r.ShaderChunk.aomap_pars_fragment = "#ifdef USE_AOMAP\n	uniform sampler2D aoMap;\n	uniform float aoMapIntensity;\n#endif", r.ShaderChunk.begin_vertex = "\nvec3 transformed = vec3( position );\n", r.ShaderChunk.beginnormal_vertex = "\nvec3 objectNormal = vec3( normal );\n", r.ShaderChunk.bsdfs = "bool testLightInRange( const in float lightDistance, const in float cutoffDistance ) {\n	return any( bvec2( cutoffDistance == 0.0, lightDistance < cutoffDistance ) );\n}\nfloat punctualLightIntensityToIrradianceFactor( const in float lightDistance, const in float cutoffDistance, const in float decayExponent ) {\n		if( decayExponent > 0.0 ) {\n#if defined ( PHYSICALLY_CORRECT_LIGHTS )\n			float distanceFalloff = 1.0 / max( pow( lightDistance, decayExponent ), 0.01 );\n			float maxDistanceCutoffFactor = pow2( saturate( 1.0 - pow4( lightDistance / cutoffDistance ) ) );\n			return distanceFalloff * maxDistanceCutoffFactor;\n#else\n			return pow( saturate( -lightDistance / cutoffDistance + 1.0 ), decayExponent );\n#endif\n		}\n		return 1.0;\n}\nvec3 BRDF_Diffuse_Lambert( const in vec3 diffuseColor ) {\n	return RECIPROCAL_PI * diffuseColor;\n}\nvec3 F_Schlick( const in vec3 specularColor, const in float dotLH ) {\n	float fresnel = exp2( ( -5.55473 * dotLH - 6.98316 ) * dotLH );\n	return ( 1.0 - specularColor ) * fresnel + specularColor;\n}\nfloat G_GGX_Smith( const in float alpha, const in float dotNL, const in float dotNV ) {\n	float a2 = pow2( alpha );\n	float gl = dotNL + sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNL ) );\n	float gv = dotNV + sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNV ) );\n	return 1.0 / ( gl * gv );\n}\nfloat D_GGX( const in float alpha, const in float dotNH ) {\n	float a2 = pow2( alpha );\n	float denom = pow2( dotNH ) * ( a2 - 1.0 ) + 1.0;\n	return RECIPROCAL_PI * a2 / pow2( denom );\n}\nvec3 BRDF_Specular_GGX( const in IncidentLight incidentLight, const in GeometricContext geometry, const in vec3 specularColor, const in float roughness ) {\n	float alpha = pow2( roughness );\n	vec3 halfDir = normalize( incidentLight.direction + geometry.viewDir );\n	float dotNL = saturate( dot( geometry.normal, incidentLight.direction ) );\n	float dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );\n	float dotNH = saturate( dot( geometry.normal, halfDir ) );\n	float dotLH = saturate( dot( incidentLight.direction, halfDir ) );\n	vec3 F = F_Schlick( specularColor, dotLH );\n	float G = G_GGX_Smith( alpha, dotNL, dotNV );\n	float D = D_GGX( alpha, dotNH );\n	return F * ( G * D );\n}\nvec3 BRDF_Specular_GGX_Environment( const in GeometricContext geometry, const in vec3 specularColor, const in float roughness ) {\n	float dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );\n	const vec4 c0 = vec4( - 1, - 0.0275, - 0.572, 0.022 );\n	const vec4 c1 = vec4( 1, 0.0425, 1.04, - 0.04 );\n	vec4 r = roughness * c0 + c1;\n	float a004 = min( r.x * r.x, exp2( - 9.28 * dotNV ) ) * r.x + r.y;\n	vec2 AB = vec2( -1.04, 1.04 ) * a004 + r.zw;\n	return specularColor * AB.x + AB.y;\n}\nfloat G_BlinnPhong_Implicit( ) {\n	return 0.25;\n}\nfloat D_BlinnPhong( const in float shininess, const in float dotNH ) {\n	return RECIPROCAL_PI * ( shininess * 0.5 + 1.0 ) * pow( dotNH, shininess );\n}\nvec3 BRDF_Specular_BlinnPhong( const in IncidentLight incidentLight, const in GeometricContext geometry, const in vec3 specularColor, const in float shininess ) {\n	vec3 halfDir = normalize( incidentLight.direction + geometry.viewDir );\n	float dotNH = saturate( dot( geometry.normal, halfDir ) );\n	float dotLH = saturate( dot( incidentLight.direction, halfDir ) );\n	vec3 F = F_Schlick( specularColor, dotLH );\n	float G = G_BlinnPhong_Implicit( );\n	float D = D_BlinnPhong( shininess, dotNH );\n	return F * ( G * D );\n}\nfloat GGXRoughnessToBlinnExponent( const in float ggxRoughness ) {\n	return ( 2.0 / pow2( ggxRoughness + 0.0001 ) - 2.0 );\n}\nfloat BlinnExponentToGGXRoughness( const in float blinnExponent ) {\n	return sqrt( 2.0 / ( blinnExponent + 2.0 ) );\n}\n", r.ShaderChunk.bumpmap_pars_fragment = "#ifdef USE_BUMPMAP\n	uniform sampler2D bumpMap;\n	uniform float bumpScale;\n	vec2 dHdxy_fwd() {\n		vec2 dSTdx = dFdx( vUv );\n		vec2 dSTdy = dFdy( vUv );\n		float Hll = bumpScale * texture2D( bumpMap, vUv ).x;\n		float dBx = bumpScale * texture2D( bumpMap, vUv + dSTdx ).x - Hll;\n		float dBy = bumpScale * texture2D( bumpMap, vUv + dSTdy ).x - Hll;\n		return vec2( dBx, dBy );\n	}\n	vec3 perturbNormalArb( vec3 surf_pos, vec3 surf_norm, vec2 dHdxy ) {\n		vec3 vSigmaX = dFdx( surf_pos );\n		vec3 vSigmaY = dFdy( surf_pos );\n		vec3 vN = surf_norm;\n		vec3 R1 = cross( vSigmaY, vN );\n		vec3 R2 = cross( vN, vSigmaX );\n		float fDet = dot( vSigmaX, R1 );\n		vec3 vGrad = sign( fDet ) * ( dHdxy.x * R1 + dHdxy.y * R2 );\n		return normalize( abs( fDet ) * surf_norm - vGrad );\n	}\n#endif\n", r.ShaderChunk.color_fragment = "#ifdef USE_COLOR\n	diffuseColor.rgb *= vColor;\n#endif", r.ShaderChunk.color_pars_fragment = "#ifdef USE_COLOR\n	varying vec3 vColor;\n#endif\n", r.ShaderChunk.color_pars_vertex = "#ifdef USE_COLOR\n	varying vec3 vColor;\n#endif", r.ShaderChunk.color_vertex = "#ifdef USE_COLOR\n	vColor.xyz = color.xyz;\n#endif", r.ShaderChunk.common = "#define PI 3.14159\n#define PI2 6.28318\n#define RECIPROCAL_PI 0.31830988618\n#define RECIPROCAL_PI2 0.15915494\n#define LOG2 1.442695\n#define EPSILON 1e-6\n#define saturate(a) clamp( a, 0.0, 1.0 )\n#define whiteCompliment(a) ( 1.0 - saturate( a ) )\nfloat pow2( const in float x ) { return x*x; }\nfloat pow3( const in float x ) { return x*x*x; }\nfloat pow4( const in float x ) { float x2 = x*x; return x2*x2; }\nfloat average( const in vec3 color ) { return dot( color, vec3( 0.3333 ) ); }\nstruct IncidentLight {\n	vec3 color;\n	vec3 direction;\n	bool visible;\n};\nstruct ReflectedLight {\n	vec3 directDiffuse;\n	vec3 directSpecular;\n	vec3 indirectDiffuse;\n	vec3 indirectSpecular;\n};\nstruct GeometricContext {\n	vec3 position;\n	vec3 normal;\n	vec3 viewDir;\n};\nvec3 transformDirection( in vec3 dir, in mat4 matrix ) {\n	return normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );\n}\nvec3 inverseTransformDirection( in vec3 dir, in mat4 matrix ) {\n	return normalize( ( vec4( dir, 0.0 ) * matrix ).xyz );\n}\nvec3 projectOnPlane(in vec3 point, in vec3 pointOnPlane, in vec3 planeNormal ) {\n	float distance = dot( planeNormal, point - pointOnPlane );\n	return - distance * planeNormal + point;\n}\nfloat sideOfPlane( in vec3 point, in vec3 pointOnPlane, in vec3 planeNormal ) {\n	return sign( dot( point - pointOnPlane, planeNormal ) );\n}\nvec3 linePlaneIntersect( in vec3 pointOnLine, in vec3 lineDirection, in vec3 pointOnPlane, in vec3 planeNormal ) {\n	return lineDirection * ( dot( planeNormal, pointOnPlane - pointOnLine ) / dot( planeNormal, lineDirection ) ) + pointOnLine;\n}\n",
            r.ShaderChunk.cube_uv_reflection_fragment = "#ifdef ENVMAP_TYPE_CUBE_UV\nconst float cubeUV_textureSize = 1024.0;\nint getFaceFromDirection(vec3 direction) {\n    vec3 absDirection = abs(direction);\n    int face = -1;\n    if( absDirection.x > absDirection.z ) {\n        if(absDirection.x > absDirection.y )\n            face = direction.x > 0.0 ? 0 : 3;\n        else\n            face = direction.y > 0.0 ? 1 : 4;\n    }\n    else {\n        if(absDirection.z > absDirection.y )\n            face = direction.z > 0.0 ? 2 : 5;\n        else\n            face = direction.y > 0.0 ? 1 : 4;\n    }\n    return face;\n}\nconst float cubeUV_maxLods1 = log2(cubeUV_textureSize*0.25) - 1.0;\nconst float cubeUV_rangeClamp = exp2((6.0 - 1.0) * 2.0);\nvec2 MipLevelInfo( vec3 vec, float roughnessLevel, float roughness ) {\n    float scale = exp2(cubeUV_maxLods1 - roughnessLevel);\n    float dxRoughness = dFdx(roughness);\n    float dyRoughness = dFdy(roughness);\n    vec3 dx = dFdx( vec * scale * dxRoughness );\n    vec3 dy = dFdy( vec * scale * dyRoughness );\n    float d = max( dot( dx, dx ), dot( dy, dy ) );\n    d = clamp(d, 1.0, cubeUV_rangeClamp);\n    float mipLevel = 0.5 * log2(d);\n    return vec2(floor(mipLevel), fract(mipLevel));\n}\nconst float cubeUV_maxLods2 = log2(cubeUV_textureSize*0.25) - 2.0;\nconst float cubeUV_rcpTextureSize = 1.0 / cubeUV_textureSize;\nvec2 getCubeUV(vec3 direction, float roughnessLevel, float mipLevel) {\n    mipLevel = roughnessLevel > cubeUV_maxLods2 - 3.0 ? 0.0 : mipLevel;\n    float a = 16.0 * cubeUV_rcpTextureSize;\n    vec2 exp2_packed = exp2( vec2( roughnessLevel, mipLevel ) );\n    vec2 rcp_exp2_packed = vec2( 1.0 ) / exp2_packed;\n    float powScale = exp2_packed.x * exp2_packed.y;\n    float scale = rcp_exp2_packed.x * rcp_exp2_packed.y * 0.25;\n    float mipOffset = 0.75*(1.0 - rcp_exp2_packed.y) * rcp_exp2_packed.x;\n    bool bRes = mipLevel == 0.0;\n    scale =  bRes && (scale < a) ? a : scale;\n    vec3 r;\n    vec2 offset;\n    int face = getFaceFromDirection(direction);\n    float rcpPowScale = 1.0 / powScale;\n    if( face == 0) {\n        r = vec3(direction.x, -direction.z, direction.y);\n        offset = vec2(0.0+mipOffset,0.75 * rcpPowScale);\n        offset.y = bRes && (offset.y < 2.0*a) ?  a : offset.y;\n    }\n    else if( face == 1) {\n        r = vec3(direction.y, direction.x, direction.z);\n        offset = vec2(scale+mipOffset, 0.75 * rcpPowScale);\n        offset.y = bRes && (offset.y < 2.0*a) ?  a : offset.y;\n    }\n    else if( face == 2) {\n        r = vec3(direction.z, direction.x, direction.y);\n        offset = vec2(2.0*scale+mipOffset, 0.75 * rcpPowScale);\n        offset.y = bRes && (offset.y < 2.0*a) ?  a : offset.y;\n    }\n    else if( face == 3) {\n        r = vec3(direction.x, direction.z, direction.y);\n        offset = vec2(0.0+mipOffset,0.5 * rcpPowScale);\n        offset.y = bRes && (offset.y < 2.0*a) ?  0.0 : offset.y;\n    }\n    else if( face == 4) {\n        r = vec3(direction.y, direction.x, -direction.z);\n        offset = vec2(scale+mipOffset, 0.5 * rcpPowScale);\n        offset.y = bRes && (offset.y < 2.0*a) ?  0.0 : offset.y;\n    }\n    else {\n        r = vec3(direction.z, -direction.x, direction.y);\n        offset = vec2(2.0*scale+mipOffset, 0.5 * rcpPowScale);\n        offset.y = bRes && (offset.y < 2.0*a) ?  0.0 : offset.y;\n    }\n    r = normalize(r);\n    float texelOffset = 0.5 * cubeUV_rcpTextureSize;\n    vec2 s = ( r.yz / abs( r.x ) + vec2( 1.0 ) ) * 0.5;\n    vec2 base = offset + vec2( texelOffset );\n    return base + s * ( scale - 2.0 * texelOffset );\n}\nconst float cubeUV_maxLods3 = log2(cubeUV_textureSize*0.25) - 3.0;\nvec4 textureCubeUV(vec3 reflectedDirection, float roughness ) {\n    float roughnessVal = roughness* cubeUV_maxLods3;\n    float r1 = floor(roughnessVal);\n    float r2 = r1 + 1.0;\n    float t = fract(roughnessVal);\n    vec2 mipInfo = MipLevelInfo(reflectedDirection, r1, roughness);\n    float s = mipInfo.y;\n    float level0 = mipInfo.x;\n    float level1 = level0 + 1.0;\n    level1 = level1 > 5.0 ? 5.0 : level1;\n    level0 += min( floor( s + 0.5 ), 5.0 );\n    vec2 uv_10 = getCubeUV(reflectedDirection, r1, level0);\n    vec4 color10 = envMapTexelToLinear(texture2D(envMap, uv_10));\n    vec2 uv_20 = getCubeUV(reflectedDirection, r2, level0);\n    vec4 color20 = envMapTexelToLinear(texture2D(envMap, uv_20));\n    vec4 result = mix(color10, color20, t);\n    return vec4(result.rgb, 1.0);\n}\n#endif\n", r.ShaderChunk.defaultnormal_vertex = "#ifdef FLIP_SIDED\n	objectNormal = -objectNormal;\n#endif\nvec3 transformedNormal = normalMatrix * objectNormal;\n", r.ShaderChunk.displacementmap_vertex = "#ifdef USE_DISPLACEMENTMAP\n	transformed += normal * ( texture2D( displacementMap, uv ).x * displacementScale + displacementBias );\n#endif\n", r.ShaderChunk.displacementmap_pars_vertex = "#ifdef USE_DISPLACEMENTMAP\n	uniform sampler2D displacementMap;\n	uniform float displacementScale;\n	uniform float displacementBias;\n#endif\n", r.ShaderChunk.emissivemap_fragment = "#ifdef USE_EMISSIVEMAP\n	vec4 emissiveColor = texture2D( emissiveMap, vUv );\n	emissiveColor.rgb = emissiveMapTexelToLinear( emissiveColor ).rgb;\n	totalEmissiveRadiance *= emissiveColor.rgb;\n#endif\n", r.ShaderChunk.emissivemap_pars_fragment = "#ifdef USE_EMISSIVEMAP\n	uniform sampler2D emissiveMap;\n#endif\n", r.ShaderChunk.encodings_pars_fragment = "\nvec4 LinearToLinear( in vec4 value ) {\n  return value;\n}\nvec4 GammaToLinear( in vec4 value, in float gammaFactor ) {\n  return vec4( pow( value.xyz, vec3( gammaFactor ) ), value.w );\n}\nvec4 LinearToGamma( in vec4 value, in float gammaFactor ) {\n  return vec4( pow( value.xyz, vec3( 1.0 / gammaFactor ) ), value.w );\n}\nvec4 sRGBToLinear( in vec4 value ) {\n  return vec4( mix( pow( value.rgb * 0.9478672986 + vec3( 0.0521327014 ), vec3( 2.4 ) ), value.rgb * 0.0773993808, vec3( lessThanEqual( value.rgb, vec3( 0.04045 ) ) ) ), value.w );\n}\nvec4 LinearTosRGB( in vec4 value ) {\n  return vec4( mix( pow( value.rgb, vec3( 0.41666 ) ) * 1.055 - vec3( 0.055 ), value.rgb * 12.92, vec3( lessThanEqual( value.rgb, vec3( 0.0031308 ) ) ) ), value.w );\n}\nvec4 RGBEToLinear( in vec4 value ) {\n  return vec4( value.rgb * exp2( value.a * 255.0 - 128.0 ), 1.0 );\n}\nvec4 LinearToRGBE( in vec4 value ) {\n  float maxComponent = max( max( value.r, value.g ), value.b );\n  float fExp = clamp( ceil( log2( maxComponent ) ), -128.0, 127.0 );\n  return vec4( value.rgb / exp2( fExp ), ( fExp + 128.0 ) / 255.0 );\n}\nvec4 RGBMToLinear( in vec4 value, in float maxRange ) {\n  return vec4( value.xyz * value.w * maxRange, 1.0 );\n}\nvec4 LinearToRGBM( in vec4 value, in float maxRange ) {\n  float maxRGB = max( value.x, max( value.g, value.b ) );\n  float M      = clamp( maxRGB / maxRange, 0.0, 1.0 );\n  M            = ceil( M * 255.0 ) / 255.0;\n  return vec4( value.rgb / ( M * maxRange ), M );\n}\nvec4 RGBDToLinear( in vec4 value, in float maxRange ) {\n    return vec4( value.rgb * ( ( maxRange / 255.0 ) / value.a ), 1.0 );\n}\nvec4 LinearToRGBD( in vec4 value, in float maxRange ) {\n    float maxRGB = max( value.x, max( value.g, value.b ) );\n    float D      = max( maxRange / maxRGB, 1.0 );\n    D            = min( floor( D ) / 255.0, 1.0 );\n    return vec4( value.rgb * ( D * ( 255.0 / maxRange ) ), D );\n}\nconst mat3 cLogLuvM = mat3( 0.2209, 0.3390, 0.4184, 0.1138, 0.6780, 0.7319, 0.0102, 0.1130, 0.2969 );\nvec4 LinearToLogLuv( in vec4 value )  {\n  vec3 Xp_Y_XYZp = value.rgb * cLogLuvM;\n  Xp_Y_XYZp = max(Xp_Y_XYZp, vec3(1e-6, 1e-6, 1e-6));\n  vec4 vResult;\n  vResult.xy = Xp_Y_XYZp.xy / Xp_Y_XYZp.z;\n  float Le = 2.0 * log2(Xp_Y_XYZp.y) + 127.0;\n  vResult.w = fract(Le);\n  vResult.z = (Le - (floor(vResult.w*255.0))/255.0)/255.0;\n  return vResult;\n}\nconst mat3 cLogLuvInverseM = mat3( 6.0014, -2.7008, -1.7996, -1.3320, 3.1029, -5.7721, 0.3008, -1.0882, 5.6268 );\nvec4 LogLuvToLinear( in vec4 value ) {\n  float Le = value.z * 255.0 + value.w;\n  vec3 Xp_Y_XYZp;\n  Xp_Y_XYZp.y = exp2((Le - 127.0) / 2.0);\n  Xp_Y_XYZp.z = Xp_Y_XYZp.y / value.y;\n  Xp_Y_XYZp.x = value.x * Xp_Y_XYZp.z;\n  vec3 vRGB = Xp_Y_XYZp.rgb * cLogLuvInverseM;\n  return vec4( max(vRGB, 0.0), 1.0 );\n}\n", r.ShaderChunk.encodings_fragment = "  gl_FragColor = linearToOutputTexel( gl_FragColor );\n", r.ShaderChunk.envmap_fragment = "#ifdef USE_ENVMAP\n	#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG )\n		vec3 cameraToVertex = normalize( vWorldPosition - cameraPosition );\n		vec3 worldNormal = inverseTransformDirection( normal, viewMatrix );\n		#ifdef ENVMAP_MODE_REFLECTION\n			vec3 reflectVec = reflect( cameraToVertex, worldNormal );\n		#else\n			vec3 reflectVec = refract( cameraToVertex, worldNormal, refractionRatio );\n		#endif\n	#else\n		vec3 reflectVec = vReflect;\n	#endif\n	#ifdef DOUBLE_SIDED\n		float flipNormal = ( float( gl_FrontFacing ) * 2.0 - 1.0 );\n	#else\n		float flipNormal = 1.0;\n	#endif\n	#ifdef ENVMAP_TYPE_CUBE\n		vec4 envColor = textureCube( envMap, flipNormal * vec3( flipEnvMap * reflectVec.x, reflectVec.yz ) );\n	#elif defined( ENVMAP_TYPE_EQUIREC )\n		vec2 sampleUV;\n		sampleUV.y = saturate( flipNormal * reflectVec.y * 0.5 + 0.5 );\n		sampleUV.x = atan( flipNormal * reflectVec.z, flipNormal * reflectVec.x ) * RECIPROCAL_PI2 + 0.5;\n		vec4 envColor = texture2D( envMap, sampleUV );\n	#elif defined( ENVMAP_TYPE_SPHERE )\n		vec3 reflectView = flipNormal * normalize((viewMatrix * vec4( reflectVec, 0.0 )).xyz + vec3(0.0,0.0,1.0));\n		vec4 envColor = texture2D( envMap, reflectView.xy * 0.5 + 0.5 );\n	#endif\n	envColor = envMapTexelToLinear( envColor );\n	#ifdef ENVMAP_BLENDING_MULTIPLY\n		outgoingLight = mix( outgoingLight, outgoingLight * envColor.xyz, specularStrength * reflectivity );\n	#elif defined( ENVMAP_BLENDING_MIX )\n		outgoingLight = mix( outgoingLight, envColor.xyz, specularStrength * reflectivity );\n	#elif defined( ENVMAP_BLENDING_ADD )\n		outgoingLight += envColor.xyz * specularStrength * reflectivity;\n	#endif\n#endif\n", r.ShaderChunk.envmap_pars_fragment = "#if defined( USE_ENVMAP ) || defined( STANDARD )\n	uniform float reflectivity;\n	uniform float envMapIntenstiy;\n#endif\n#ifdef USE_ENVMAP\n	#ifdef ENVMAP_TYPE_CUBE\n		uniform samplerCube envMap;\n	#else\n		uniform sampler2D envMap;\n	#endif\n	uniform float flipEnvMap;\n	#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG ) || defined( STANDARD )\n		uniform float refractionRatio;\n	#else\n		varying vec3 vReflect;\n	#endif\n#endif\n", r.ShaderChunk.envmap_pars_vertex = "#if defined( USE_ENVMAP ) && ! defined( USE_BUMPMAP ) && ! defined( USE_NORMALMAP ) && ! defined( PHONG ) && ! defined( STANDARD )\n	varying vec3 vReflect;\n	uniform float refractionRatio;\n#endif\n", r.ShaderChunk.envmap_vertex = "#if defined( USE_ENVMAP ) && ! defined( USE_BUMPMAP ) && ! defined( USE_NORMALMAP ) && ! defined( PHONG ) && ! defined( STANDARD )\n	vec3 cameraToVertex = normalize( worldPosition.xyz - cameraPosition );\n	vec3 worldNormal = inverseTransformDirection( transformedNormal, viewMatrix );\n	#ifdef ENVMAP_MODE_REFLECTION\n		vReflect = reflect( cameraToVertex, worldNormal );\n	#else\n		vReflect = refract( cameraToVertex, worldNormal, refractionRatio );\n	#endif\n#endif\n", r.ShaderChunk.fog_fragment = "#ifdef USE_FOG\n	#ifdef USE_LOGDEPTHBUF_EXT\n		float depth = gl_FragDepthEXT / gl_FragCoord.w;\n	#else\n		float depth = gl_FragCoord.z / gl_FragCoord.w;\n	#endif\n	#ifdef FOG_EXP2\n		float fogFactor = whiteCompliment( exp2( - fogDensity * fogDensity * depth * depth * LOG2 ) );\n	#else\n		float fogFactor = smoothstep( fogNear, fogFar, depth );\n	#endif\n	gl_FragColor.rgb = mix( gl_FragColor.rgb, fogColor, fogFactor );\n#endif\n", r.ShaderChunk.fog_pars_fragment = "#ifdef USE_FOG\n	uniform vec3 fogColor;\n	#ifdef FOG_EXP2\n		uniform float fogDensity;\n	#else\n		uniform float fogNear;\n		uniform float fogFar;\n	#endif\n#endif", r.ShaderChunk.lightmap_fragment = "#ifdef USE_LIGHTMAP\n	reflectedLight.indirectDiffuse += PI * texture2D( lightMap, vUv2 ).xyz * lightMapIntensity;\n#endif\n", r.ShaderChunk.lightmap_pars_fragment = "#ifdef USE_LIGHTMAP\n	uniform sampler2D lightMap;\n	uniform float lightMapIntensity;\n#endif", r.ShaderChunk.lights_lambert_vertex = "vec3 diffuse = vec3( 1.0 );\nGeometricContext geometry;\ngeometry.position = mvPosition.xyz;\ngeometry.normal = normalize( transformedNormal );\ngeometry.viewDir = normalize( -mvPosition.xyz );\nGeometricContext backGeometry;\nbackGeometry.position = geometry.position;\nbackGeometry.normal = -geometry.normal;\nbackGeometry.viewDir = geometry.viewDir;\nvLightFront = vec3( 0.0 );\n#ifdef DOUBLE_SIDED\n	vLightBack = vec3( 0.0 );\n#endif\nIncidentLight directLight;\nfloat dotNL;\nvec3 directLightColor_Diffuse;\n#if NUM_POINT_LIGHTS > 0\n	for ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\n		directLight = getPointDirectLightIrradiance( pointLights[ i ], geometry );\n		dotNL = dot( geometry.normal, directLight.direction );\n		directLightColor_Diffuse = PI * directLight.color;\n		vLightFront += saturate( dotNL ) * directLightColor_Diffuse;\n		#ifdef DOUBLE_SIDED\n			vLightBack += saturate( -dotNL ) * directLightColor_Diffuse;\n		#endif\n	}\n#endif\n#if NUM_SPOT_LIGHTS > 0\n	for ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\n		directLight = getSpotDirectLightIrradiance( spotLights[ i ], geometry );\n		dotNL = dot( geometry.normal, directLight.direction );\n		directLightColor_Diffuse = PI * directLight.color;\n		vLightFront += saturate( dotNL ) * directLightColor_Diffuse;\n		#ifdef DOUBLE_SIDED\n			vLightBack += saturate( -dotNL ) * directLightColor_Diffuse;\n		#endif\n	}\n#endif\n#if NUM_DIR_LIGHTS > 0\n	for ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\n		directLight = getDirectionalDirectLightIrradiance( directionalLights[ i ], geometry );\n		dotNL = dot( geometry.normal, directLight.direction );\n		directLightColor_Diffuse = PI * directLight.color;\n		vLightFront += saturate( dotNL ) * directLightColor_Diffuse;\n		#ifdef DOUBLE_SIDED\n			vLightBack += saturate( -dotNL ) * directLightColor_Diffuse;\n		#endif\n	}\n#endif\n#if NUM_HEMI_LIGHTS > 0\n	for ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {\n		vLightFront += getHemisphereLightIrradiance( hemisphereLights[ i ], geometry );\n		#ifdef DOUBLE_SIDED\n			vLightBack += getHemisphereLightIrradiance( hemisphereLights[ i ], backGeometry );\n		#endif\n	}\n#endif\n", r.ShaderChunk.lights_pars = "uniform vec3 ambientLightColor;\nvec3 getAmbientLightIrradiance( const in vec3 ambientLightColor ) {\n	vec3 irradiance = ambientLightColor;\n	#ifndef PHYSICALLY_CORRECT_LIGHTS\n		irradiance *= PI;\n	#endif\n	return irradiance;\n}\n#if NUM_DIR_LIGHTS > 0\n	struct DirectionalLight {\n		vec3 direction;\n		vec3 color;\n		int shadow;\n		float shadowBias;\n		float shadowRadius;\n		vec2 shadowMapSize;\n	};\n	uniform DirectionalLight directionalLights[ NUM_DIR_LIGHTS ];\n	IncidentLight getDirectionalDirectLightIrradiance( const in DirectionalLight directionalLight, const in GeometricContext geometry ) {\n		IncidentLight directLight;\n		directLight.color = directionalLight.color;\n		directLight.direction = directionalLight.direction;\n		directLight.visible = true;\n		return directLight;\n	}\n#endif\n#if NUM_POINT_LIGHTS > 0\n	struct PointLight {\n		vec3 position;\n		vec3 color;\n		float distance;\n		float decay;\n		int shadow;\n		float shadowBias;\n		float shadowRadius;\n		vec2 shadowMapSize;\n	};\n	uniform PointLight pointLights[ NUM_POINT_LIGHTS ];\n	IncidentLight getPointDirectLightIrradiance( const in PointLight pointLight, const in GeometricContext geometry ) {\n		IncidentLight directLight;\n		vec3 lVector = pointLight.position - geometry.position;\n		directLight.direction = normalize( lVector );\n		float lightDistance = length( lVector );\n		if ( testLightInRange( lightDistance, pointLight.distance ) ) {\n			directLight.color = pointLight.color;\n			directLight.color *= punctualLightIntensityToIrradianceFactor( lightDistance, pointLight.distance, pointLight.decay );\n			directLight.visible = true;\n		} else {\n			directLight.color = vec3( 0.0 );\n			directLight.visible = false;\n		}\n		return directLight;\n	}\n#endif\n#if NUM_SPOT_LIGHTS > 0\n	struct SpotLight {\n		vec3 position;\n		vec3 direction;\n		vec3 color;\n		float distance;\n		float decay;\n		float coneCos;\n		float penumbraCos;\n		int shadow;\n		float shadowBias;\n		float shadowRadius;\n		vec2 shadowMapSize;\n	};\n	uniform SpotLight spotLights[ NUM_SPOT_LIGHTS ];\n	IncidentLight getSpotDirectLightIrradiance( const in SpotLight spotLight, const in GeometricContext geometry ) {\n		IncidentLight directLight;\n		vec3 lVector = spotLight.position - geometry.position;\n		directLight.direction = normalize( lVector );\n		float lightDistance = length( lVector );\n		float angleCos = dot( directLight.direction, spotLight.direction );\n		if ( all( bvec2( angleCos > spotLight.coneCos, testLightInRange( lightDistance, spotLight.distance ) ) ) ) {\n			float spotEffect = smoothstep( spotLight.coneCos, spotLight.penumbraCos, angleCos );\n			directLight.color = spotLight.color;\n			directLight.color *= spotEffect * punctualLightIntensityToIrradianceFactor( lightDistance, spotLight.distance, spotLight.decay );\n			directLight.visible = true;\n		} else {\n			directLight.color = vec3( 0.0 );\n			directLight.visible = false;\n		}\n		return directLight;\n	}\n#endif\n#if NUM_HEMI_LIGHTS > 0\n	struct HemisphereLight {\n		vec3 direction;\n		vec3 skyColor;\n		vec3 groundColor;\n	};\n	uniform HemisphereLight hemisphereLights[ NUM_HEMI_LIGHTS ];\n	vec3 getHemisphereLightIrradiance( const in HemisphereLight hemiLight, const in GeometricContext geometry ) {\n		float dotNL = dot( geometry.normal, hemiLight.direction );\n		float hemiDiffuseWeight = 0.5 * dotNL + 0.5;\n		vec3 irradiance = mix( hemiLight.groundColor, hemiLight.skyColor, hemiDiffuseWeight );\n		#ifndef PHYSICALLY_CORRECT_LIGHTS\n			irradiance *= PI;\n		#endif\n		return irradiance;\n	}\n#endif\n#if defined( USE_ENVMAP ) && defined( STANDARD )\n	vec3 getLightProbeIndirectIrradiance( const in GeometricContext geometry, const in int maxMIPLevel ) {\n		#ifdef DOUBLE_SIDED\n			float flipNormal = ( float( gl_FrontFacing ) * 2.0 - 1.0 );\n		#else\n			float flipNormal = 1.0;\n		#endif\n		vec3 worldNormal = inverseTransformDirection( geometry.normal, viewMatrix );\n		#ifdef ENVMAP_TYPE_CUBE\n			vec3 queryVec = flipNormal * vec3( flipEnvMap * worldNormal.x, worldNormal.yz );\n			#ifdef TEXTURE_LOD_EXT\n				vec4 envMapColor = textureCubeLodEXT( envMap, queryVec, float( maxMIPLevel ) );\n			#else\n				vec4 envMapColor = textureCube( envMap, queryVec, float( maxMIPLevel ) );\n			#endif\n		#elif defined( ENVMAP_TYPE_CUBE_UV )\n			vec3 queryVec = flipNormal * vec3( flipEnvMap * worldNormal.x, worldNormal.yz );\n			vec4 envMapColor = textureCubeUV( queryVec, 1.0 );\n		#else\n			vec4 envMapColor = vec4( 0.0 );\n		#endif\n		envMapColor.rgb = envMapTexelToLinear( envMapColor ).rgb;\n		return PI * envMapColor.rgb * envMapIntensity;\n	}\n	float getSpecularMIPLevel( const in float blinnShininessExponent, const in int maxMIPLevel ) {\n		float maxMIPLevelScalar = float( maxMIPLevel );\n		float desiredMIPLevel = maxMIPLevelScalar - 0.79248 - 0.5 * log2( pow2( blinnShininessExponent ) + 1.0 );\n		return clamp( desiredMIPLevel, 0.0, maxMIPLevelScalar );\n	}\n	vec3 getLightProbeIndirectRadiance( const in GeometricContext geometry, const in float blinnShininessExponent, const in int maxMIPLevel ) {\n		#ifdef ENVMAP_MODE_REFLECTION\n			vec3 reflectVec = reflect( -geometry.viewDir, geometry.normal );\n		#else\n			vec3 reflectVec = refract( -geometry.viewDir, geometry.normal, refractionRatio );\n		#endif\n		#ifdef DOUBLE_SIDED\n			float flipNormal = ( float( gl_FrontFacing ) * 2.0 - 1.0 );\n		#else\n			float flipNormal = 1.0;\n		#endif\n		reflectVec = inverseTransformDirection( reflectVec, viewMatrix );\n		float specularMIPLevel = getSpecularMIPLevel( blinnShininessExponent, maxMIPLevel );\n		#ifdef ENVMAP_TYPE_CUBE\n			vec3 queryReflectVec = flipNormal * vec3( flipEnvMap * reflectVec.x, reflectVec.yz );\n			#ifdef TEXTURE_LOD_EXT\n				vec4 envMapColor = textureCubeLodEXT( envMap, queryReflectVec, specularMIPLevel );\n			#else\n				vec4 envMapColor = textureCube( envMap, queryReflectVec, specularMIPLevel );\n			#endif\n		#elif defined( ENVMAP_TYPE_CUBE_UV )\n			vec3 queryReflectVec = flipNormal * vec3( flipEnvMap * reflectVec.x, reflectVec.yz );\n			vec4 envMapColor = textureCubeUV(queryReflectVec, BlinnExponentToGGXRoughness(blinnShininessExponent));\n		#elif defined( ENVMAP_TYPE_EQUIREC )\n			vec2 sampleUV;\n			sampleUV.y = saturate( flipNormal * reflectVec.y * 0.5 + 0.5 );\n			sampleUV.x = atan( flipNormal * reflectVec.z, flipNormal * reflectVec.x ) * RECIPROCAL_PI2 + 0.5;\n			#ifdef TEXTURE_LOD_EXT\n				vec4 envMapColor = texture2DLodEXT( envMap, sampleUV, specularMIPLevel );\n			#else\n				vec4 envMapColor = texture2D( envMap, sampleUV, specularMIPLevel );\n			#endif\n		#elif defined( ENVMAP_TYPE_SPHERE )\n			vec3 reflectView = flipNormal * normalize((viewMatrix * vec4( reflectVec, 0.0 )).xyz + vec3(0.0,0.0,1.0));\n			#ifdef TEXTURE_LOD_EXT\n				vec4 envMapColor = texture2DLodEXT( envMap, reflectView.xy * 0.5 + 0.5, specularMIPLevel );\n			#else\n				vec4 envMapColor = texture2D( envMap, reflectView.xy * 0.5 + 0.5, specularMIPLevel );\n			#endif\n		#endif\n		envMapColor.rgb = envMapTexelToLinear( envMapColor ).rgb;\n		return envMapColor.rgb * envMapIntensity;\n	}\n#endif\n", r.ShaderChunk.lights_phong_fragment = "BlinnPhongMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb;\nmaterial.specularColor = specular;\nmaterial.specularShininess = shininess;\nmaterial.specularStrength = specularStrength;\n", r.ShaderChunk.lights_phong_pars_fragment = "#ifdef USE_ENVMAP\n	varying vec3 vWorldPosition;\n#endif\nvarying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n	varying vec3 vNormal;\n#endif\nstruct BlinnPhongMaterial {\n	vec3	diffuseColor;\n	vec3	specularColor;\n	float	specularShininess;\n	float	specularStrength;\n};\nvoid RE_Direct_BlinnPhong( const in IncidentLight directLight, const in GeometricContext geometry, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {\n	float dotNL = saturate( dot( geometry.normal, directLight.direction ) );\n	vec3 irradiance = dotNL * directLight.color;\n	#ifndef PHYSICALLY_CORRECT_LIGHTS\n		irradiance *= PI;\n	#endif\n	reflectedLight.directDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n	reflectedLight.directSpecular += irradiance * BRDF_Specular_BlinnPhong( directLight, geometry, material.specularColor, material.specularShininess ) * material.specularStrength;\n}\nvoid RE_IndirectDiffuse_BlinnPhong( const in vec3 irradiance, const in GeometricContext geometry, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {\n	reflectedLight.indirectDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n}\n#define RE_Direct				RE_Direct_BlinnPhong\n#define RE_IndirectDiffuse		RE_IndirectDiffuse_BlinnPhong\n#define Material_LightProbeLOD( material )	(0)\n", r.ShaderChunk.lights_phong_pars_vertex = "#ifdef USE_ENVMAP\n	varying vec3 vWorldPosition;\n#endif\n", r.ShaderChunk.lights_phong_vertex = "#ifdef USE_ENVMAP\n	vWorldPosition = worldPosition.xyz;\n#endif\n", r.ShaderChunk.lights_standard_fragment = "StandardMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb * ( 1.0 - metalnessFactor );\nmaterial.specularRoughness = clamp( roughnessFactor, 0.04, 1.0 );\nmaterial.specularColor = mix( vec3( 0.04 ), diffuseColor.rgb, metalnessFactor );\n", r.ShaderChunk.lights_standard_pars_fragment = "struct StandardMaterial {\n	vec3	diffuseColor;\n	float	specularRoughness;\n	vec3	specularColor;\n};\nvoid RE_Direct_Standard( const in IncidentLight directLight, const in GeometricContext geometry, const in StandardMaterial material, inout ReflectedLight reflectedLight ) {\n	float dotNL = saturate( dot( geometry.normal, directLight.direction ) );\n	vec3 irradiance = dotNL * directLight.color;\n	#ifndef PHYSICALLY_CORRECT_LIGHTS\n		irradiance *= PI;\n	#endif\n	reflectedLight.directDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n	reflectedLight.directSpecular += irradiance * BRDF_Specular_GGX( directLight, geometry, material.specularColor, material.specularRoughness );\n}\nvoid RE_IndirectDiffuse_Standard( const in vec3 irradiance, const in GeometricContext geometry, const in StandardMaterial material, inout ReflectedLight reflectedLight ) {\n	reflectedLight.indirectDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n}\nvoid RE_IndirectSpecular_Standard( const in vec3 radiance, const in GeometricContext geometry, const in StandardMaterial material, inout ReflectedLight reflectedLight ) {\n	reflectedLight.indirectSpecular += radiance * BRDF_Specular_GGX_Environment( geometry, material.specularColor, material.specularRoughness );\n}\n#define RE_Direct				RE_Direct_Standard\n#define RE_IndirectDiffuse		RE_IndirectDiffuse_Standard\n#define RE_IndirectSpecular		RE_IndirectSpecular_Standard\n#define Material_BlinnShininessExponent( material )   GGXRoughnessToBlinnExponent( material.specularRoughness )\nfloat computeSpecularOcclusion( const in float dotNV, const in float ambientOcclusion, const in float roughness ) {\n	return saturate( pow( dotNV + ambientOcclusion, exp2( - 16.0 * roughness - 1.0 ) ) - 1.0 + ambientOcclusion );\n}\n", r.ShaderChunk.lights_template = "\nGeometricContext geometry;\ngeometry.position = - vViewPosition;\ngeometry.normal = normal;\ngeometry.viewDir = normalize( vViewPosition );\nIncidentLight directLight;\n#if ( NUM_POINT_LIGHTS > 0 ) && defined( RE_Direct )\n	PointLight pointLight;\n	for ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\n		pointLight = pointLights[ i ];\n		directLight = getPointDirectLightIrradiance( pointLight, geometry );\n		#ifdef USE_SHADOWMAP\n		directLight.color *= all( bvec2( pointLight.shadow, directLight.visible ) ) ? getPointShadow( pointShadowMap[ i ], pointLight.shadowMapSize, pointLight.shadowBias, pointLight.shadowRadius, vPointShadowCoord[ i ] ) : 1.0;\n		#endif\n		RE_Direct( directLight, geometry, material, reflectedLight );\n	}\n#endif\n#if ( NUM_SPOT_LIGHTS > 0 ) && defined( RE_Direct )\n	SpotLight spotLight;\n	for ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\n		spotLight = spotLights[ i ];\n		directLight = getSpotDirectLightIrradiance( spotLight, geometry );\n		#ifdef USE_SHADOWMAP\n		directLight.color *= all( bvec2( spotLight.shadow, directLight.visible ) ) ? getShadow( spotShadowMap[ i ], spotLight.shadowMapSize, spotLight.shadowBias, spotLight.shadowRadius, vSpotShadowCoord[ i ] ) : 1.0;\n		#endif\n		RE_Direct( directLight, geometry, material, reflectedLight );\n	}\n#endif\n#if ( NUM_DIR_LIGHTS > 0 ) && defined( RE_Direct )\n	DirectionalLight directionalLight;\n	for ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\n		directionalLight = directionalLights[ i ];\n		directLight = getDirectionalDirectLightIrradiance( directionalLight, geometry );\n		#ifdef USE_SHADOWMAP\n		directLight.color *= all( bvec2( directionalLight.shadow, directLight.visible ) ) ? getShadow( directionalShadowMap[ i ], directionalLight.shadowMapSize, directionalLight.shadowBias, directionalLight.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;\n		#endif\n		RE_Direct( directLight, geometry, material, reflectedLight );\n	}\n#endif\n#if defined( RE_IndirectDiffuse )\n	vec3 irradiance = getAmbientLightIrradiance( ambientLightColor );\n	#ifdef USE_LIGHTMAP\n		vec3 lightMapIrradiance = texture2D( lightMap, vUv2 ).xyz * lightMapIntensity;\n		#ifndef PHYSICALLY_CORRECT_LIGHTS\n			lightMapIrradiance *= PI;\n		#endif\n		irradiance += lightMapIrradiance;\n	#endif\n	#if ( NUM_HEMI_LIGHTS > 0 )\n		for ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {\n			irradiance += getHemisphereLightIrradiance( hemisphereLights[ i ], geometry );\n		}\n	#endif\n	#if defined( USE_ENVMAP ) && defined( STANDARD ) && defined( ENVMAP_TYPE_CUBE_UV )\n	 	irradiance += getLightProbeIndirectIrradiance( geometry, 8 );\n	#endif\n	RE_IndirectDiffuse( irradiance, geometry, material, reflectedLight );\n#endif\n#if defined( USE_ENVMAP ) && defined( RE_IndirectSpecular )\n	vec3 radiance = getLightProbeIndirectRadiance( geometry, Material_BlinnShininessExponent( material ), 8 );\n	RE_IndirectSpecular( radiance, geometry, material, reflectedLight );\n#endif\n", r.ShaderChunk.logdepthbuf_fragment = "#if defined(USE_LOGDEPTHBUF) && defined(USE_LOGDEPTHBUF_EXT)\n	gl_FragDepthEXT = log2(vFragDepth) * logDepthBufFC * 0.5;\n#endif", r.ShaderChunk.logdepthbuf_pars_fragment = "#ifdef USE_LOGDEPTHBUF\n	uniform float logDepthBufFC;\n	#ifdef USE_LOGDEPTHBUF_EXT\n		varying float vFragDepth;\n	#endif\n#endif\n", r.ShaderChunk.logdepthbuf_pars_vertex = "#ifdef USE_LOGDEPTHBUF\n	#ifdef USE_LOGDEPTHBUF_EXT\n		varying float vFragDepth;\n	#endif\n	uniform float logDepthBufFC;\n#endif", r.ShaderChunk.logdepthbuf_vertex = "#ifdef USE_LOGDEPTHBUF\n	gl_Position.z = log2(max( EPSILON, gl_Position.w + 1.0 )) * logDepthBufFC;\n	#ifdef USE_LOGDEPTHBUF_EXT\n		vFragDepth = 1.0 + gl_Position.w;\n	#else\n		gl_Position.z = (gl_Position.z - 1.0) * gl_Position.w;\n	#endif\n#endif\n", r.ShaderChunk.map_fragment = "#ifdef USE_MAP\n	vec4 texelColor = texture2D( map, vUv );\n	texelColor = mapTexelToLinear( texelColor );\n	diffuseColor *= texelColor;\n#endif\n", r.ShaderChunk.map_pars_fragment = "#ifdef USE_MAP\n	uniform sampler2D map;\n#endif\n", r.ShaderChunk.map_particle_fragment = "#ifdef USE_MAP\n	vec4 mapTexel = texture2D( map, vec2( gl_PointCoord.x, 1.0 - gl_PointCoord.y ) * offsetRepeat.zw + offsetRepeat.xy );\n	diffuseColor *= mapTexelToLinear( mapTexel );\n#endif\n", r.ShaderChunk.map_particle_pars_fragment = "#ifdef USE_MAP\n	uniform vec4 offsetRepeat;\n	uniform sampler2D map;\n#endif\n", r.ShaderChunk.metalnessmap_fragment = "float metalnessFactor = metalness;\n#ifdef USE_METALNESSMAP\n	vec4 texelMetalness = texture2D( metalnessMap, vUv );\n	metalnessFactor *= texelMetalness.r;\n#endif\n", r.ShaderChunk.metalnessmap_pars_fragment = "#ifdef USE_METALNESSMAP\n	uniform sampler2D metalnessMap;\n#endif", r.ShaderChunk.morphnormal_vertex = "#ifdef USE_MORPHNORMALS\n	objectNormal += ( morphNormal0 - normal ) * morphTargetInfluences[ 0 ];\n	objectNormal += ( morphNormal1 - normal ) * morphTargetInfluences[ 1 ];\n	objectNormal += ( morphNormal2 - normal ) * morphTargetInfluences[ 2 ];\n	objectNormal += ( morphNormal3 - normal ) * morphTargetInfluences[ 3 ];\n#endif\n", r.ShaderChunk.morphtarget_pars_vertex = "#ifdef USE_MORPHTARGETS\n	#ifndef USE_MORPHNORMALS\n	uniform float morphTargetInfluences[ 8 ];\n	#else\n	uniform float morphTargetInfluences[ 4 ];\n	#endif\n#endif", r.ShaderChunk.morphtarget_vertex = "#ifdef USE_MORPHTARGETS\n	transformed += ( morphTarget0 - position ) * morphTargetInfluences[ 0 ];\n	transformed += ( morphTarget1 - position ) * morphTargetInfluences[ 1 ];\n	transformed += ( morphTarget2 - position ) * morphTargetInfluences[ 2 ];\n	transformed += ( morphTarget3 - position ) * morphTargetInfluences[ 3 ];\n	#ifndef USE_MORPHNORMALS\n	transformed += ( morphTarget4 - position ) * morphTargetInfluences[ 4 ];\n	transformed += ( morphTarget5 - position ) * morphTargetInfluences[ 5 ];\n	transformed += ( morphTarget6 - position ) * morphTargetInfluences[ 6 ];\n	transformed += ( morphTarget7 - position ) * morphTargetInfluences[ 7 ];\n	#endif\n#endif\n", r.ShaderChunk.normal_fragment = "#ifdef FLAT_SHADED\n	vec3 fdx = vec3( dFdx( vViewPosition.x ), dFdx( vViewPosition.y ), dFdx( vViewPosition.z ) );\n	vec3 fdy = vec3( dFdy( vViewPosition.x ), dFdy( vViewPosition.y ), dFdy( vViewPosition.z ) );\n	vec3 normal = normalize( cross( fdx, fdy ) );\n#else\n	vec3 normal = normalize( vNormal );\n	#ifdef DOUBLE_SIDED\n		normal = normal * ( -1.0 + 2.0 * float( gl_FrontFacing ) );\n	#endif\n#endif\n#ifdef USE_NORMALMAP\n	normal = perturbNormal2Arb( -vViewPosition, normal );\n#elif defined( USE_BUMPMAP )\n	normal = perturbNormalArb( -vViewPosition, normal, dHdxy_fwd() );\n#endif\n", r.ShaderChunk.normalmap_pars_fragment = "#ifdef USE_NORMALMAP\n	uniform sampler2D normalMap;\n	uniform vec2 normalScale;\n	vec3 perturbNormal2Arb( vec3 eye_pos, vec3 surf_norm ) {\n		vec3 q0 = dFdx( eye_pos.xyz );\n		vec3 q1 = dFdy( eye_pos.xyz );\n		vec2 st0 = dFdx( vUv.st );\n		vec2 st1 = dFdy( vUv.st );\n		vec3 S = normalize( q0 * st1.t - q1 * st0.t );\n		vec3 T = normalize( -q0 * st1.s + q1 * st0.s );\n		vec3 N = normalize( surf_norm );\n		vec3 mapN = texture2D( normalMap, vUv ).xyz * 2.0 - 1.0;\n		mapN.xy = normalScale * mapN.xy;\n		mat3 tsn = mat3( S, T, N );\n		return normalize( tsn * mapN );\n	}\n#endif\n",
            r.ShaderChunk.premultiplied_alpha_fragment = "#ifdef PREMULTIPLIED_ALPHA\n	gl_FragColor.rgb *= gl_FragColor.a;\n#endif\n", r.ShaderChunk.project_vertex = "#ifdef USE_SKINNING\n	vec4 mvPosition = modelViewMatrix * skinned;\n#else\n	vec4 mvPosition = modelViewMatrix * vec4( transformed, 1.0 );\n#endif\ngl_Position = projectionMatrix * mvPosition;\n", r.ShaderChunk.roughnessmap_fragment = "float roughnessFactor = roughness;\n#ifdef USE_ROUGHNESSMAP\n	vec4 texelRoughness = texture2D( roughnessMap, vUv );\n	roughnessFactor *= texelRoughness.r;\n#endif\n", r.ShaderChunk.roughnessmap_pars_fragment = "#ifdef USE_ROUGHNESSMAP\n	uniform sampler2D roughnessMap;\n#endif", r.ShaderChunk.shadowmap_pars_fragment = "#ifdef USE_SHADOWMAP\n	#if NUM_DIR_LIGHTS > 0\n		uniform sampler2D directionalShadowMap[ NUM_DIR_LIGHTS ];\n		varying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHTS ];\n	#endif\n	#if NUM_SPOT_LIGHTS > 0\n		uniform sampler2D spotShadowMap[ NUM_SPOT_LIGHTS ];\n		varying vec4 vSpotShadowCoord[ NUM_SPOT_LIGHTS ];\n	#endif\n	#if NUM_POINT_LIGHTS > 0\n		uniform sampler2D pointShadowMap[ NUM_POINT_LIGHTS ];\n		varying vec4 vPointShadowCoord[ NUM_POINT_LIGHTS ];\n	#endif\n	float unpackDepth( const in vec4 rgba_depth ) {\n		const vec4 bit_shift = vec4( 1.0 / ( 256.0 * 256.0 * 256.0 ), 1.0 / ( 256.0 * 256.0 ), 1.0 / 256.0, 1.0 );\n		return dot( rgba_depth, bit_shift );\n	}\n	float texture2DCompare( sampler2D depths, vec2 uv, float compare ) {\n		return step( compare, unpackDepth( texture2D( depths, uv ) ) );\n	}\n	float texture2DShadowLerp( sampler2D depths, vec2 size, vec2 uv, float compare ) {\n		const vec2 offset = vec2( 0.0, 1.0 );\n		vec2 texelSize = vec2( 1.0 ) / size;\n		vec2 centroidUV = floor( uv * size + 0.5 ) / size;\n		float lb = texture2DCompare( depths, centroidUV + texelSize * offset.xx, compare );\n		float lt = texture2DCompare( depths, centroidUV + texelSize * offset.xy, compare );\n		float rb = texture2DCompare( depths, centroidUV + texelSize * offset.yx, compare );\n		float rt = texture2DCompare( depths, centroidUV + texelSize * offset.yy, compare );\n		vec2 f = fract( uv * size + 0.5 );\n		float a = mix( lb, lt, f.y );\n		float b = mix( rb, rt, f.y );\n		float c = mix( a, b, f.x );\n		return c;\n	}\n	float getShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord ) {\n		shadowCoord.xyz /= shadowCoord.w;\n		shadowCoord.z += shadowBias;\n		bvec4 inFrustumVec = bvec4 ( shadowCoord.x >= 0.0, shadowCoord.x <= 1.0, shadowCoord.y >= 0.0, shadowCoord.y <= 1.0 );\n		bool inFrustum = all( inFrustumVec );\n		bvec2 frustumTestVec = bvec2( inFrustum, shadowCoord.z <= 1.0 );\n		bool frustumTest = all( frustumTestVec );\n		if ( frustumTest ) {\n		#if defined( SHADOWMAP_TYPE_PCF )\n			vec2 texelSize = vec2( 1.0 ) / shadowMapSize;\n			float dx0 = - texelSize.x * shadowRadius;\n			float dy0 = - texelSize.y * shadowRadius;\n			float dx1 = + texelSize.x * shadowRadius;\n			float dy1 = + texelSize.y * shadowRadius;\n			return (\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )\n			) * ( 1.0 / 9.0 );\n		#elif defined( SHADOWMAP_TYPE_PCF_SOFT )\n			vec2 texelSize = vec2( 1.0 ) / shadowMapSize;\n			float dx0 = - texelSize.x * shadowRadius;\n			float dy0 = - texelSize.y * shadowRadius;\n			float dx1 = + texelSize.x * shadowRadius;\n			float dy1 = + texelSize.y * shadowRadius;\n			return (\n				texture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +\n				texture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +\n				texture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +\n				texture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +\n				texture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy, shadowCoord.z ) +\n				texture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +\n				texture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +\n				texture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +\n				texture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )\n			) * ( 1.0 / 9.0 );\n		#else\n			return texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z );\n		#endif\n		}\n		return 1.0;\n	}\n	vec2 cubeToUV( vec3 v, float texelSizeY ) {\n		vec3 absV = abs( v );\n		float scaleToCube = 1.0 / max( absV.x, max( absV.y, absV.z ) );\n		absV *= scaleToCube;\n		v *= scaleToCube * ( 1.0 - 2.0 * texelSizeY );\n		vec2 planar = v.xy;\n		float almostATexel = 1.5 * texelSizeY;\n		float almostOne = 1.0 - almostATexel;\n		if ( absV.z >= almostOne ) {\n			if ( v.z > 0.0 )\n				planar.x = 4.0 - v.x;\n		} else if ( absV.x >= almostOne ) {\n			float signX = sign( v.x );\n			planar.x = v.z * signX + 2.0 * signX;\n		} else if ( absV.y >= almostOne ) {\n			float signY = sign( v.y );\n			planar.x = v.x + 2.0 * signY + 2.0;\n			planar.y = v.z * signY - 2.0;\n		}\n		return vec2( 0.125, 0.25 ) * planar + vec2( 0.375, 0.75 );\n	}\n	float getPointShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord ) {\n		vec2 texelSize = vec2( 1.0 ) / ( shadowMapSize * vec2( 4.0, 2.0 ) );\n		vec3 lightToPosition = shadowCoord.xyz;\n		vec3 bd3D = normalize( lightToPosition );\n		float dp = ( length( lightToPosition ) - shadowBias ) / 1000.0;\n		#if defined( SHADOWMAP_TYPE_PCF ) || defined( SHADOWMAP_TYPE_PCF_SOFT )\n			vec2 offset = vec2( - 1, 1 ) * shadowRadius * texelSize.y;\n			return (\n				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyy, texelSize.y ), dp ) +\n				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyy, texelSize.y ), dp ) +\n				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyx, texelSize.y ), dp ) +\n				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyx, texelSize.y ), dp ) +\n				texture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp ) +\n				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxy, texelSize.y ), dp ) +\n				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxy, texelSize.y ), dp ) +\n				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxx, texelSize.y ), dp ) +\n				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxx, texelSize.y ), dp )\n			) * ( 1.0 / 9.0 );\n		#else\n			return texture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp );\n		#endif\n	}\n#endif\n", r.ShaderChunk.shadowmap_pars_vertex = "#ifdef USE_SHADOWMAP\n	#if NUM_DIR_LIGHTS > 0\n		uniform mat4 directionalShadowMatrix[ NUM_DIR_LIGHTS ];\n		varying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHTS ];\n	#endif\n	#if NUM_SPOT_LIGHTS > 0\n		uniform mat4 spotShadowMatrix[ NUM_SPOT_LIGHTS ];\n		varying vec4 vSpotShadowCoord[ NUM_SPOT_LIGHTS ];\n	#endif\n	#if NUM_POINT_LIGHTS > 0\n		uniform mat4 pointShadowMatrix[ NUM_POINT_LIGHTS ];\n		varying vec4 vPointShadowCoord[ NUM_POINT_LIGHTS ];\n	#endif\n#endif\n", r.ShaderChunk.shadowmap_vertex = "#ifdef USE_SHADOWMAP\n	#if NUM_DIR_LIGHTS > 0\n	for ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\n		vDirectionalShadowCoord[ i ] = directionalShadowMatrix[ i ] * worldPosition;\n	}\n	#endif\n	#if NUM_SPOT_LIGHTS > 0\n	for ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\n		vSpotShadowCoord[ i ] = spotShadowMatrix[ i ] * worldPosition;\n	}\n	#endif\n	#if NUM_POINT_LIGHTS > 0\n	for ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\n		vPointShadowCoord[ i ] = pointShadowMatrix[ i ] * worldPosition;\n	}\n	#endif\n#endif\n", r.ShaderChunk.shadowmask_pars_fragment = "float getShadowMask() {\n	float shadow = 1.0;\n	#ifdef USE_SHADOWMAP\n	#if NUM_DIR_LIGHTS > 0\n	DirectionalLight directionalLight;\n	for ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\n		directionalLight = directionalLights[ i ];\n		shadow *= bool( directionalLight.shadow ) ? getShadow( directionalShadowMap[ i ], directionalLight.shadowMapSize, directionalLight.shadowBias, directionalLight.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;\n	}\n	#endif\n	#if NUM_SPOT_LIGHTS > 0\n	SpotLight spotLight;\n	for ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\n		spotLight = spotLights[ i ];\n		shadow *= bool( spotLight.shadow ) ? getShadow( spotShadowMap[ i ], spotLight.shadowMapSize, spotLight.shadowBias, spotLight.shadowRadius, vSpotShadowCoord[ i ] ) : 1.0;\n	}\n	#endif\n	#if NUM_POINT_LIGHTS > 0\n	PointLight pointLight;\n	for ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\n		pointLight = pointLights[ i ];\n		shadow *= bool( pointLight.shadow ) ? getPointShadow( pointShadowMap[ i ], pointLight.shadowMapSize, pointLight.shadowBias, pointLight.shadowRadius, vPointShadowCoord[ i ] ) : 1.0;\n	}\n	#endif\n	#endif\n	return shadow;\n}\n", r.ShaderChunk.skinbase_vertex = "#ifdef USE_SKINNING\n	mat4 boneMatX = getBoneMatrix( skinIndex.x );\n	mat4 boneMatY = getBoneMatrix( skinIndex.y );\n	mat4 boneMatZ = getBoneMatrix( skinIndex.z );\n	mat4 boneMatW = getBoneMatrix( skinIndex.w );\n#endif", r.ShaderChunk.skinning_pars_vertex = "#ifdef USE_SKINNING\n	uniform mat4 bindMatrix;\n	uniform mat4 bindMatrixInverse;\n	#ifdef BONE_TEXTURE\n		uniform sampler2D boneTexture;\n		uniform int boneTextureWidth;\n		uniform int boneTextureHeight;\n		mat4 getBoneMatrix( const in float i ) {\n			float j = i * 4.0;\n			float x = mod( j, float( boneTextureWidth ) );\n			float y = floor( j / float( boneTextureWidth ) );\n			float dx = 1.0 / float( boneTextureWidth );\n			float dy = 1.0 / float( boneTextureHeight );\n			y = dy * ( y + 0.5 );\n			vec4 v1 = texture2D( boneTexture, vec2( dx * ( x + 0.5 ), y ) );\n			vec4 v2 = texture2D( boneTexture, vec2( dx * ( x + 1.5 ), y ) );\n			vec4 v3 = texture2D( boneTexture, vec2( dx * ( x + 2.5 ), y ) );\n			vec4 v4 = texture2D( boneTexture, vec2( dx * ( x + 3.5 ), y ) );\n			mat4 bone = mat4( v1, v2, v3, v4 );\n			return bone;\n		}\n	#else\n		uniform mat4 boneGlobalMatrices[ MAX_BONES ];\n		mat4 getBoneMatrix( const in float i ) {\n			mat4 bone = boneGlobalMatrices[ int(i) ];\n			return bone;\n		}\n	#endif\n#endif\n", r.ShaderChunk.skinning_vertex = "#ifdef USE_SKINNING\n	vec4 skinVertex = bindMatrix * vec4( transformed, 1.0 );\n	vec4 skinned = vec4( 0.0 );\n	skinned += boneMatX * skinVertex * skinWeight.x;\n	skinned += boneMatY * skinVertex * skinWeight.y;\n	skinned += boneMatZ * skinVertex * skinWeight.z;\n	skinned += boneMatW * skinVertex * skinWeight.w;\n	skinned  = bindMatrixInverse * skinned;\n#endif\n", r.ShaderChunk.skinnormal_vertex = "#ifdef USE_SKINNING\n	mat4 skinMatrix = mat4( 0.0 );\n	skinMatrix += skinWeight.x * boneMatX;\n	skinMatrix += skinWeight.y * boneMatY;\n	skinMatrix += skinWeight.z * boneMatZ;\n	skinMatrix += skinWeight.w * boneMatW;\n	skinMatrix  = bindMatrixInverse * skinMatrix * bindMatrix;\n	objectNormal = vec4( skinMatrix * vec4( objectNormal, 0.0 ) ).xyz;\n#endif\n", r.ShaderChunk.specularmap_fragment = "float specularStrength;\n#ifdef USE_SPECULARMAP\n	vec4 texelSpecular = texture2D( specularMap, vUv );\n	specularStrength = texelSpecular.r;\n#else\n	specularStrength = 1.0;\n#endif", r.ShaderChunk.specularmap_pars_fragment = "#ifdef USE_SPECULARMAP\n	uniform sampler2D specularMap;\n#endif", r.ShaderChunk.tonemapping_fragment = "#if defined( TONE_MAPPING )\n  gl_FragColor.rgb = toneMapping( gl_FragColor.rgb );\n#endif\n", r.ShaderChunk.tonemapping_pars_fragment = "#define saturate(a) clamp( a, 0.0, 1.0 )\nuniform float toneMappingExposure;\nuniform float toneMappingWhitePoint;\nvec3 LinearToneMapping( vec3 color ) {\n  return toneMappingExposure * color;\n}\nvec3 ReinhardToneMapping( vec3 color ) {\n  color *= toneMappingExposure;\n  return saturate( color / ( vec3( 1.0 ) + color ) );\n}\n#define Uncharted2Helper( x ) max( ( ( x * ( 0.15 * x + 0.10 * 0.50 ) + 0.20 * 0.02 ) / ( x * ( 0.15 * x + 0.50 ) + 0.20 * 0.30 ) ) - 0.02 / 0.30, vec3( 0.0 ) )\nvec3 Uncharted2ToneMapping( vec3 color ) {\n  color *= toneMappingExposure;\n  return saturate( Uncharted2Helper( color ) / Uncharted2Helper( vec3( toneMappingWhitePoint ) ) );\n}\nvec3 OptimizedCineonToneMapping( vec3 color ) {\n  color *= toneMappingExposure;\n  color = max( vec3( 0.0 ), color - 0.004 );\n  return pow( ( color * ( 6.2 * color + 0.5 ) ) / ( color * ( 6.2 * color + 1.7 ) + 0.06 ), vec3( 2.2 ) );\n}\n", r.ShaderChunk.uv2_pars_fragment = "#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\n	varying vec2 vUv2;\n#endif", r.ShaderChunk.uv2_pars_vertex = "#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\n	attribute vec2 uv2;\n	varying vec2 vUv2;\n#endif", r.ShaderChunk.uv2_vertex = "#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\n	vUv2 = uv2;\n#endif", r.ShaderChunk.uv_pars_fragment = "#if defined( USE_MAP ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( USE_SPECULARMAP ) || defined( USE_ALPHAMAP ) || defined( USE_EMISSIVEMAP ) || defined( USE_ROUGHNESSMAP ) || defined( USE_METALNESSMAP )\n	varying vec2 vUv;\n#endif", r.ShaderChunk.uv_pars_vertex = "#if defined( USE_MAP ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( USE_SPECULARMAP ) || defined( USE_ALPHAMAP ) || defined( USE_EMISSIVEMAP ) || defined( USE_ROUGHNESSMAP ) || defined( USE_METALNESSMAP )\n	varying vec2 vUv;\n	uniform vec4 offsetRepeat;\n#endif\n", r.ShaderChunk.uv_vertex = "#if defined( USE_MAP ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( USE_SPECULARMAP ) || defined( USE_ALPHAMAP ) || defined( USE_EMISSIVEMAP ) || defined( USE_ROUGHNESSMAP ) || defined( USE_METALNESSMAP )\n	vUv = uv * offsetRepeat.zw + offsetRepeat.xy;\n#endif", r.ShaderChunk.worldpos_vertex = "#if defined( USE_ENVMAP ) || defined( PHONG ) || defined( STANDARD ) || defined( LAMBERT ) || defined ( USE_SHADOWMAP )\n	#ifdef USE_SKINNING\n		vec4 worldPosition = modelMatrix * skinned;\n	#else\n		vec4 worldPosition = modelMatrix * vec4( transformed, 1.0 );\n	#endif\n#endif\n", r.UniformsUtils = {
                merge: function(e) {
                    for (var t = {}, i = 0; i < e.length; i++) {
                        var r = this.clone(e[i]);
                        for (var n in r) t[n] = r[n]
                    }
                    return t
                },
                clone: function(e) {
                    var t = {};
                    for (var i in e) {
                        t[i] = {};
                        for (var n in e[i]) {
                            var o = e[i][n];
                            o instanceof r.Color || o instanceof r.Vector2 || o instanceof r.Vector3 || o instanceof r.Vector4 || o instanceof r.Matrix3 || o instanceof r.Matrix4 || o instanceof r.Texture ? t[i][n] = o.clone() : Array.isArray(o) ? t[i][n] = o.slice() : t[i][n] = o
                        }
                    }
                    return t
                }
            }, r.UniformsLib = {
                common: {
                    diffuse: {
                        type: "c",
                        value: new r.Color(15658734)
                    },
                    opacity: {
                        type: "f",
                        value: 1
                    },
                    map: {
                        type: "t",
                        value: null
                    },
                    offsetRepeat: {
                        type: "v4",
                        value: new r.Vector4(0, 0, 1, 1)
                    },
                    specularMap: {
                        type: "t",
                        value: null
                    },
                    alphaMap: {
                        type: "t",
                        value: null
                    },
                    envMap: {
                        type: "t",
                        value: null
                    },
                    flipEnvMap: {
                        type: "f",
                        value: -1
                    },
                    reflectivity: {
                        type: "f",
                        value: 1
                    },
                    refractionRatio: {
                        type: "f",
                        value: .98
                    }
                },
                aomap: {
                    aoMap: {
                        type: "t",
                        value: null
                    },
                    aoMapIntensity: {
                        type: "f",
                        value: 1
                    }
                },
                lightmap: {
                    lightMap: {
                        type: "t",
                        value: null
                    },
                    lightMapIntensity: {
                        type: "f",
                        value: 1
                    }
                },
                emissivemap: {
                    emissiveMap: {
                        type: "t",
                        value: null
                    }
                },
                bumpmap: {
                    bumpMap: {
                        type: "t",
                        value: null
                    },
                    bumpScale: {
                        type: "f",
                        value: 1
                    }
                },
                normalmap: {
                    normalMap: {
                        type: "t",
                        value: null
                    },
                    normalScale: {
                        type: "v2",
                        value: new r.Vector2(1, 1)
                    }
                },
                displacementmap: {
                    displacementMap: {
                        type: "t",
                        value: null
                    },
                    displacementScale: {
                        type: "f",
                        value: 1
                    },
                    displacementBias: {
                        type: "f",
                        value: 0
                    }
                },
                roughnessmap: {
                    roughnessMap: {
                        type: "t",
                        value: null
                    }
                },
                metalnessmap: {
                    metalnessMap: {
                        type: "t",
                        value: null
                    }
                },
                fog: {
                    fogDensity: {
                        type: "f",
                        value: 25e-5
                    },
                    fogNear: {
                        type: "f",
                        value: 1
                    },
                    fogFar: {
                        type: "f",
                        value: 2e3
                    },
                    fogColor: {
                        type: "c",
                        value: new r.Color(16777215)
                    }
                },
                lights: {
                    ambientLightColor: {
                        type: "fv",
                        value: []
                    },
                    directionalLights: {
                        type: "sa",
                        value: [],
                        properties: {
                            direction: {
                                type: "v3"
                            },
                            color: {
                                type: "c"
                            },
                            shadow: {
                                type: "i"
                            },
                            shadowBias: {
                                type: "f"
                            },
                            shadowRadius: {
                                type: "f"
                            },
                            shadowMapSize: {
                                type: "v2"
                            }
                        }
                    },
                    directionalShadowMap: {
                        type: "tv",
                        value: []
                    },
                    directionalShadowMatrix: {
                        type: "m4v",
                        value: []
                    },
                    spotLights: {
                        type: "sa",
                        value: [],
                        properties: {
                            color: {
                                type: "c"
                            },
                            position: {
                                type: "v3"
                            },
                            direction: {
                                type: "v3"
                            },
                            distance: {
                                type: "f"
                            },
                            coneCos: {
                                type: "f"
                            },
                            penumbraCos: {
                                type: "f"
                            },
                            decay: {
                                type: "f"
                            },
                            shadow: {
                                type: "i"
                            },
                            shadowBias: {
                                type: "f"
                            },
                            shadowRadius: {
                                type: "f"
                            },
                            shadowMapSize: {
                                type: "v2"
                            }
                        }
                    },
                    spotShadowMap: {
                        type: "tv",
                        value: []
                    },
                    spotShadowMatrix: {
                        type: "m4v",
                        value: []
                    },
                    pointLights: {
                        type: "sa",
                        value: [],
                        properties: {
                            color: {
                                type: "c"
                            },
                            position: {
                                type: "v3"
                            },
                            decay: {
                                type: "f"
                            },
                            distance: {
                                type: "f"
                            },
                            shadow: {
                                type: "i"
                            },
                            shadowBias: {
                                type: "f"
                            },
                            shadowRadius: {
                                type: "f"
                            },
                            shadowMapSize: {
                                type: "v2"
                            }
                        }
                    },
                    pointShadowMap: {
                        type: "tv",
                        value: []
                    },
                    pointShadowMatrix: {
                        type: "m4v",
                        value: []
                    },
                    hemisphereLights: {
                        type: "sa",
                        value: [],
                        properties: {
                            direction: {
                                type: "v3"
                            },
                            skyColor: {
                                type: "c"
                            },
                            groundColor: {
                                type: "c"
                            }
                        }
                    }
                },
                points: {
                    diffuse: {
                        type: "c",
                        value: new r.Color(15658734)
                    },
                    opacity: {
                        type: "f",
                        value: 1
                    },
                    size: {
                        type: "f",
                        value: 1
                    },
                    scale: {
                        type: "f",
                        value: 1
                    },
                    map: {
                        type: "t",
                        value: null
                    },
                    offsetRepeat: {
                        type: "v4",
                        value: new r.Vector4(0, 0, 1, 1)
                    }
                }
            }, r.ShaderChunk.cube_frag = "uniform samplerCube tCube;\nuniform float tFlip;\nvarying vec3 vWorldPosition;\n#include <common>\n#include <logdepthbuf_pars_fragment>\nvoid main() {\n	gl_FragColor = textureCube( tCube, vec3( tFlip * vWorldPosition.x, vWorldPosition.yz ) );\n	#include <logdepthbuf_fragment>\n}\n", r.ShaderChunk.cube_vert = "varying vec3 vWorldPosition;\n#include <common>\n#include <logdepthbuf_pars_vertex>\nvoid main() {\n	vWorldPosition = transformDirection( position, modelMatrix );\n	gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n	#include <logdepthbuf_vertex>\n}\n", r.ShaderChunk.depth_frag = "uniform float mNear;\nuniform float mFar;\nuniform float opacity;\n#include <common>\n#include <logdepthbuf_pars_fragment>\nvoid main() {\n	#include <logdepthbuf_fragment>\n	#ifdef USE_LOGDEPTHBUF_EXT\n		float depth = gl_FragDepthEXT / gl_FragCoord.w;\n	#else\n		float depth = gl_FragCoord.z / gl_FragCoord.w;\n	#endif\n	float color = 1.0 - smoothstep( mNear, mFar, depth );\n	gl_FragColor = vec4( vec3( color ), opacity );\n}\n", r.ShaderChunk.depth_vert = "#include <common>\n#include <morphtarget_pars_vertex>\n#include <logdepthbuf_pars_vertex>\nvoid main() {\n	#include <begin_vertex>\n	#include <morphtarget_vertex>\n	#include <project_vertex>\n	#include <logdepthbuf_vertex>\n}\n", r.ShaderChunk.depthRGBA_frag = "#include <common>\n#include <logdepthbuf_pars_fragment>\nvec4 pack_depth( const in float depth ) {\n	const vec4 bit_shift = vec4( 256.0 * 256.0 * 256.0, 256.0 * 256.0, 256.0, 1.0 );\n	const vec4 bit_mask = vec4( 0.0, 1.0 / 256.0, 1.0 / 256.0, 1.0 / 256.0 );\n	vec4 res = mod( depth * bit_shift * vec4( 255 ), vec4( 256 ) ) / vec4( 255 );\n	res -= res.xxyz * bit_mask;\n	return res;\n}\nvoid main() {\n	#include <logdepthbuf_fragment>\n	#ifdef USE_LOGDEPTHBUF_EXT\n		gl_FragData[ 0 ] = pack_depth( gl_FragDepthEXT );\n	#else\n		gl_FragData[ 0 ] = pack_depth( gl_FragCoord.z );\n	#endif\n}\n", r.ShaderChunk.depthRGBA_vert = "#include <common>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\nvoid main() {\n	#include <skinbase_vertex>\n	#include <begin_vertex>\n	#include <morphtarget_vertex>\n	#include <skinning_vertex>\n	#include <project_vertex>\n	#include <logdepthbuf_vertex>\n}\n", r.ShaderChunk.distanceRGBA_frag = "uniform vec3 lightPos;\nvarying vec4 vWorldPosition;\n#include <common>\nvec4 pack1K ( float depth ) {\n	depth /= 1000.0;\n	const vec4 bitSh = vec4( 256.0 * 256.0 * 256.0, 256.0 * 256.0, 256.0, 1.0 );\n	const vec4 bitMsk = vec4( 0.0, 1.0 / 256.0, 1.0 / 256.0, 1.0 / 256.0 );\n	vec4 res = mod( depth * bitSh * vec4( 255 ), vec4( 256 ) ) / vec4( 255 );\n	res -= res.xxyz * bitMsk;\n	return res;\n}\nfloat unpack1K ( vec4 color ) {\n	const vec4 bitSh = vec4( 1.0 / ( 256.0 * 256.0 * 256.0 ), 1.0 / ( 256.0 * 256.0 ), 1.0 / 256.0, 1.0 );\n	return dot( color, bitSh ) * 1000.0;\n}\nvoid main () {\n	gl_FragColor = pack1K( length( vWorldPosition.xyz - lightPos.xyz ) );\n}\n", r.ShaderChunk.distanceRGBA_vert = "varying vec4 vWorldPosition;\n#include <common>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\nvoid main() {\n	#include <skinbase_vertex>\n	#include <begin_vertex>\n	#include <morphtarget_vertex>\n	#include <skinning_vertex>\n	#include <project_vertex>\n	#include <worldpos_vertex>\n	vWorldPosition = worldPosition;\n}\n", r.ShaderChunk.equirect_frag = "uniform sampler2D tEquirect;\nuniform float tFlip;\nvarying vec3 vWorldPosition;\n#include <common>\n#include <logdepthbuf_pars_fragment>\nvoid main() {\n	vec3 direction = normalize( vWorldPosition );\n	vec2 sampleUV;\n	sampleUV.y = saturate( tFlip * direction.y * -0.5 + 0.5 );\n	sampleUV.x = atan( direction.z, direction.x ) * RECIPROCAL_PI2 + 0.5;\n	gl_FragColor = texture2D( tEquirect, sampleUV );\n	#include <logdepthbuf_fragment>\n}\n", r.ShaderChunk.equirect_vert = "varying vec3 vWorldPosition;\n#include <common>\n#include <logdepthbuf_pars_vertex>\nvoid main() {\n	vWorldPosition = transformDirection( position, modelMatrix );\n	gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n	#include <logdepthbuf_vertex>\n}\n", r.ShaderChunk.linedashed_frag = "uniform vec3 diffuse;\nuniform float opacity;\nuniform float dashSize;\nuniform float totalSize;\nvarying float vLineDistance;\n#include <common>\n#include <color_pars_fragment>\n#include <fog_pars_fragment>\n#include <logdepthbuf_pars_fragment>\nvoid main() {\n	if ( mod( vLineDistance, totalSize ) > dashSize ) {\n		discard;\n	}\n	vec3 outgoingLight = vec3( 0.0 );\n	vec4 diffuseColor = vec4( diffuse, opacity );\n	#include <logdepthbuf_fragment>\n	#include <color_fragment>\n	outgoingLight = diffuseColor.rgb;\n	gl_FragColor = vec4( outgoingLight, diffuseColor.a );\n	#include <premultiplied_alpha_fragment>\n	#include <tonemapping_fragment>\n	#include <encodings_fragment>\n	#include <fog_fragment>\n}\n", r.ShaderChunk.linedashed_vert = "uniform float scale;\nattribute float lineDistance;\nvarying float vLineDistance;\n#include <common>\n#include <color_pars_vertex>\n#include <logdepthbuf_pars_vertex>\nvoid main() {\n	#include <color_vertex>\n	vLineDistance = scale * lineDistance;\n	vec4 mvPosition = modelViewMatrix * vec4( position, 1.0 );\n	gl_Position = projectionMatrix * mvPosition;\n	#include <logdepthbuf_vertex>\n}\n", r.ShaderChunk.meshbasic_frag = "uniform vec3 diffuse;\nuniform float opacity;\n#ifndef FLAT_SHADED\n	varying vec3 vNormal;\n#endif\n#include <common>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <aomap_pars_fragment>\n#include <envmap_pars_fragment>\n#include <fog_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\nvoid main() {\n	vec4 diffuseColor = vec4( diffuse, opacity );\n	#include <logdepthbuf_fragment>\n	#include <map_fragment>\n	#include <color_fragment>\n	#include <alphamap_fragment>\n	#include <alphatest_fragment>\n	#include <specularmap_fragment>\n	ReflectedLight reflectedLight;\n	reflectedLight.directDiffuse = vec3( 0.0 );\n	reflectedLight.directSpecular = vec3( 0.0 );\n	reflectedLight.indirectDiffuse = diffuseColor.rgb;\n	reflectedLight.indirectSpecular = vec3( 0.0 );\n	#include <aomap_fragment>\n	vec3 outgoingLight = reflectedLight.indirectDiffuse;\n	#include <envmap_fragment>\n	gl_FragColor = vec4( outgoingLight, diffuseColor.a );\n	#include <premultiplied_alpha_fragment>\n	#include <tonemapping_fragment>\n	#include <encodings_fragment>\n	#include <fog_fragment>\n}\n", r.ShaderChunk.meshbasic_vert = "#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <envmap_pars_vertex>\n#include <color_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\nvoid main() {\n	#include <uv_vertex>\n	#include <uv2_vertex>\n	#include <color_vertex>\n	#include <skinbase_vertex>\n	#ifdef USE_ENVMAP\n	#include <beginnormal_vertex>\n	#include <morphnormal_vertex>\n	#include <skinnormal_vertex>\n	#include <defaultnormal_vertex>\n	#endif\n	#include <begin_vertex>\n	#include <morphtarget_vertex>\n	#include <skinning_vertex>\n	#include <project_vertex>\n	#include <logdepthbuf_vertex>\n	#include <worldpos_vertex>\n	#include <envmap_vertex>\n}\n", r.ShaderChunk.meshlambert_frag = "uniform vec3 diffuse;\nuniform vec3 emissive;\nuniform float opacity;\nvarying vec3 vLightFront;\n#ifdef DOUBLE_SIDED\n	varying vec3 vLightBack;\n#endif\n#include <common>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <envmap_pars_fragment>\n#include <bsdfs>\n#include <lights_pars>\n#include <fog_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <shadowmask_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\nvoid main() {\n	vec4 diffuseColor = vec4( diffuse, opacity );\n	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n	vec3 totalEmissiveRadiance = emissive;\n	#include <logdepthbuf_fragment>\n	#include <map_fragment>\n	#include <color_fragment>\n	#include <alphamap_fragment>\n	#include <alphatest_fragment>\n	#include <specularmap_fragment>\n	#include <emissivemap_fragment>\n	reflectedLight.indirectDiffuse = getAmbientLightIrradiance( ambientLightColor );\n	#include <lightmap_fragment>\n	reflectedLight.indirectDiffuse *= BRDF_Diffuse_Lambert( diffuseColor.rgb );\n	#ifdef DOUBLE_SIDED\n		reflectedLight.directDiffuse = ( gl_FrontFacing ) ? vLightFront : vLightBack;\n	#else\n		reflectedLight.directDiffuse = vLightFront;\n	#endif\n	reflectedLight.directDiffuse *= BRDF_Diffuse_Lambert( diffuseColor.rgb ) * getShadowMask();\n	#include <aomap_fragment>\n	vec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;\n	#include <envmap_fragment>\n	gl_FragColor = vec4( outgoingLight, diffuseColor.a );\n	#include <premultiplied_alpha_fragment>\n	#include <tonemapping_fragment>\n	#include <encodings_fragment>\n	#include <fog_fragment>\n}\n", r.ShaderChunk.meshlambert_vert = "#define LAMBERT\nvarying vec3 vLightFront;\n#ifdef DOUBLE_SIDED\n	varying vec3 vLightBack;\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <envmap_pars_vertex>\n#include <bsdfs>\n#include <lights_pars>\n#include <color_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\nvoid main() {\n	#include <uv_vertex>\n	#include <uv2_vertex>\n	#include <color_vertex>\n	#include <beginnormal_vertex>\n	#include <morphnormal_vertex>\n	#include <skinbase_vertex>\n	#include <skinnormal_vertex>\n	#include <defaultnormal_vertex>\n	#include <begin_vertex>\n	#include <morphtarget_vertex>\n	#include <skinning_vertex>\n	#include <project_vertex>\n	#include <logdepthbuf_vertex>\n	#include <worldpos_vertex>\n	#include <envmap_vertex>\n	#include <lights_lambert_vertex>\n	#include <shadowmap_vertex>\n}\n", r.ShaderChunk.meshphong_frag = "#define PHONG\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform vec3 specular;\nuniform float shininess;\nuniform float opacity;\n#include <common>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <envmap_pars_fragment>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars>\n#include <lights_phong_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\nvoid main() {\n	vec4 diffuseColor = vec4( diffuse, opacity );\n	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n	vec3 totalEmissiveRadiance = emissive;\n	#include <logdepthbuf_fragment>\n	#include <map_fragment>\n	#include <color_fragment>\n	#include <alphamap_fragment>\n	#include <alphatest_fragment>\n	#include <specularmap_fragment>\n	#include <normal_fragment>\n	#include <emissivemap_fragment>\n	#include <lights_phong_fragment>\n	#include <lights_template>\n	#include <aomap_fragment>\n	vec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular + totalEmissiveRadiance;\n	#include <envmap_fragment>\n	gl_FragColor = vec4( outgoingLight, diffuseColor.a );\n	#include <premultiplied_alpha_fragment>\n	#include <tonemapping_fragment>\n	#include <encodings_fragment>\n	#include <fog_fragment>\n}\n", r.ShaderChunk.meshphong_vert = "#define PHONG\nvarying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n	varying vec3 vNormal;\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <envmap_pars_vertex>\n#include <lights_phong_pars_vertex>\n#include <color_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\nvoid main() {\n	#include <uv_vertex>\n	#include <uv2_vertex>\n	#include <color_vertex>\n	#include <beginnormal_vertex>\n	#include <morphnormal_vertex>\n	#include <skinbase_vertex>\n	#include <skinnormal_vertex>\n	#include <defaultnormal_vertex>\n#ifndef FLAT_SHADED\n	vNormal = normalize( transformedNormal );\n#endif\n	#include <begin_vertex>\n	#include <displacementmap_vertex>\n	#include <morphtarget_vertex>\n	#include <skinning_vertex>\n	#include <project_vertex>\n	#include <logdepthbuf_vertex>\n	vViewPosition = - mvPosition.xyz;\n	#include <worldpos_vertex>\n	#include <envmap_vertex>\n	#include <lights_phong_vertex>\n	#include <shadowmap_vertex>\n}\n", r.ShaderChunk.meshstandard_frag = "#define STANDARD\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform float roughness;\nuniform float metalness;\nuniform float opacity;\nuniform float envMapIntensity;\nvarying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n	varying vec3 vNormal;\n#endif\n#include <common>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <envmap_pars_fragment>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <cube_uv_reflection_fragment>\n#include <lights_pars>\n#include <lights_standard_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <roughnessmap_pars_fragment>\n#include <metalnessmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\nvoid main() {\n	vec4 diffuseColor = vec4( diffuse, opacity );\n	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n	vec3 totalEmissiveRadiance = emissive;\n	#include <logdepthbuf_fragment>\n	#include <map_fragment>\n	#include <color_fragment>\n	#include <alphamap_fragment>\n	#include <alphatest_fragment>\n	#include <specularmap_fragment>\n	#include <roughnessmap_fragment>\n	#include <metalnessmap_fragment>\n	#include <normal_fragment>\n	#include <emissivemap_fragment>\n	#include <lights_standard_fragment>\n	#include <lights_template>\n	#include <aomap_fragment>\n	vec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular + totalEmissiveRadiance;\n	gl_FragColor = vec4( outgoingLight, diffuseColor.a );\n	#include <premultiplied_alpha_fragment>\n	#include <tonemapping_fragment>\n	#include <encodings_fragment>\n	#include <fog_fragment>\n}\n",
            r.ShaderChunk.meshstandard_vert = "#define STANDARD\nvarying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n	varying vec3 vNormal;\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <envmap_pars_vertex>\n#include <color_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_vertex>\nvoid main() {\n	#include <uv_vertex>\n	#include <uv2_vertex>\n	#include <color_vertex>\n	#include <beginnormal_vertex>\n	#include <morphnormal_vertex>\n	#include <skinbase_vertex>\n	#include <skinnormal_vertex>\n	#include <defaultnormal_vertex>\n#ifndef FLAT_SHADED\n	vNormal = normalize( transformedNormal );\n#endif\n	#include <begin_vertex>\n	#include <displacementmap_vertex>\n	#include <morphtarget_vertex>\n	#include <skinning_vertex>\n	#include <project_vertex>\n	#include <logdepthbuf_vertex>\n	vViewPosition = - mvPosition.xyz;\n	#include <worldpos_vertex>\n	#include <envmap_vertex>\n	#include <shadowmap_vertex>\n}\n", r.ShaderChunk.normal_frag = "uniform float opacity;\nvarying vec3 vNormal;\n#include <common>\n#include <logdepthbuf_pars_fragment>\nvoid main() {\n	gl_FragColor = vec4( 0.5 * normalize( vNormal ) + 0.5, opacity );\n	#include <logdepthbuf_fragment>\n}\n", r.ShaderChunk.normal_vert = "varying vec3 vNormal;\n#include <common>\n#include <morphtarget_pars_vertex>\n#include <logdepthbuf_pars_vertex>\nvoid main() {\n	vNormal = normalize( normalMatrix * normal );\n	#include <begin_vertex>\n	#include <morphtarget_vertex>\n	#include <project_vertex>\n	#include <logdepthbuf_vertex>\n}\n", r.ShaderChunk.points_frag = "uniform vec3 diffuse;\nuniform float opacity;\n#include <common>\n#include <color_pars_fragment>\n#include <map_particle_pars_fragment>\n#include <fog_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\nvoid main() {\n	vec3 outgoingLight = vec3( 0.0 );\n	vec4 diffuseColor = vec4( diffuse, opacity );\n	#include <logdepthbuf_fragment>\n	#include <map_particle_fragment>\n	#include <color_fragment>\n	#include <alphatest_fragment>\n	outgoingLight = diffuseColor.rgb;\n	gl_FragColor = vec4( outgoingLight, diffuseColor.a );\n	#include <premultiplied_alpha_fragment>\n	#include <tonemapping_fragment>\n	#include <encodings_fragment>\n	#include <fog_fragment>\n}\n", r.ShaderChunk.points_vert = "uniform float size;\nuniform float scale;\n#include <common>\n#include <color_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\nvoid main() {\n	#include <color_vertex>\n	#include <begin_vertex>\n	#include <project_vertex>\n	#ifdef USE_SIZEATTENUATION\n		gl_PointSize = size * ( scale / - mvPosition.z );\n	#else\n		gl_PointSize = size;\n	#endif\n	#include <logdepthbuf_vertex>\n	#include <worldpos_vertex>\n	#include <shadowmap_vertex>\n}\n", r.ShaderLib = {
                basic: {
                    uniforms: r.UniformsUtils.merge([r.UniformsLib.common, r.UniformsLib.aomap, r.UniformsLib.fog]),
                    vertexShader: r.ShaderChunk.meshbasic_vert,
                    fragmentShader: r.ShaderChunk.meshbasic_frag
                },
                lambert: {
                    uniforms: r.UniformsUtils.merge([r.UniformsLib.common, r.UniformsLib.aomap, r.UniformsLib.lightmap, r.UniformsLib.emissivemap, r.UniformsLib.fog, r.UniformsLib.lights, {
                        emissive: {
                            type: "c",
                            value: new r.Color(0)
                        }
                    }]),
                    vertexShader: r.ShaderChunk.meshlambert_vert,
                    fragmentShader: r.ShaderChunk.meshlambert_frag
                },
                phong: {
                    uniforms: r.UniformsUtils.merge([r.UniformsLib.common, r.UniformsLib.aomap, r.UniformsLib.lightmap, r.UniformsLib.emissivemap, r.UniformsLib.bumpmap, r.UniformsLib.normalmap, r.UniformsLib.displacementmap, r.UniformsLib.fog, r.UniformsLib.lights, {
                        emissive: {
                            type: "c",
                            value: new r.Color(0)
                        },
                        specular: {
                            type: "c",
                            value: new r.Color(1118481)
                        },
                        shininess: {
                            type: "f",
                            value: 30
                        }
                    }]),
                    vertexShader: r.ShaderChunk.meshphong_vert,
                    fragmentShader: r.ShaderChunk.meshphong_frag
                },
                standard: {
                    uniforms: r.UniformsUtils.merge([r.UniformsLib.common, r.UniformsLib.aomap, r.UniformsLib.lightmap, r.UniformsLib.emissivemap, r.UniformsLib.bumpmap, r.UniformsLib.normalmap, r.UniformsLib.displacementmap, r.UniformsLib.roughnessmap, r.UniformsLib.metalnessmap, r.UniformsLib.fog, r.UniformsLib.lights, {
                        emissive: {
                            type: "c",
                            value: new r.Color(0)
                        },
                        roughness: {
                            type: "f",
                            value: .5
                        },
                        metalness: {
                            type: "f",
                            value: 0
                        },
                        envMapIntensity: {
                            type: "f",
                            value: 1
                        }
                    }]),
                    vertexShader: r.ShaderChunk.meshstandard_vert,
                    fragmentShader: r.ShaderChunk.meshstandard_frag
                },
                points: {
                    uniforms: r.UniformsUtils.merge([r.UniformsLib.points, r.UniformsLib.fog]),
                    vertexShader: r.ShaderChunk.points_vert,
                    fragmentShader: r.ShaderChunk.points_frag
                },
                dashed: {
                    uniforms: r.UniformsUtils.merge([r.UniformsLib.common, r.UniformsLib.fog, {
                        scale: {
                            type: "f",
                            value: 1
                        },
                        dashSize: {
                            type: "f",
                            value: 1
                        },
                        totalSize: {
                            type: "f",
                            value: 2
                        }
                    }]),
                    vertexShader: r.ShaderChunk.linedashed_vert,
                    fragmentShader: r.ShaderChunk.linedashed_frag
                },
                depth: {
                    uniforms: {
                        mNear: {
                            type: "f",
                            value: 1
                        },
                        mFar: {
                            type: "f",
                            value: 2e3
                        },
                        opacity: {
                            type: "f",
                            value: 1
                        }
                    },
                    vertexShader: r.ShaderChunk.depth_vert,
                    fragmentShader: r.ShaderChunk.depth_frag
                },
                normal: {
                    uniforms: {
                        opacity: {
                            type: "f",
                            value: 1
                        }
                    },
                    vertexShader: r.ShaderChunk.normal_vert,
                    fragmentShader: r.ShaderChunk.normal_frag
                },
                cube: {
                    uniforms: {
                        tCube: {
                            type: "t",
                            value: null
                        },
                        tFlip: {
                            type: "f",
                            value: -1
                        }
                    },
                    vertexShader: r.ShaderChunk.cube_vert,
                    fragmentShader: r.ShaderChunk.cube_frag
                },
                equirect: {
                    uniforms: {
                        tEquirect: {
                            type: "t",
                            value: null
                        },
                        tFlip: {
                            type: "f",
                            value: -1
                        }
                    },
                    vertexShader: r.ShaderChunk.equirect_vert,
                    fragmentShader: r.ShaderChunk.equirect_frag
                },
                depthRGBA: {
                    uniforms: {},
                    vertexShader: r.ShaderChunk.depthRGBA_vert,
                    fragmentShader: r.ShaderChunk.depthRGBA_frag
                },
                distanceRGBA: {
                    uniforms: {
                        lightPos: {
                            type: "v3",
                            value: new r.Vector3(0, 0, 0)
                        }
                    },
                    vertexShader: r.ShaderChunk.distanceRGBA_vert,
                    fragmentShader: r.ShaderChunk.distanceRGBA_frag
                }
            }, r.WebGLRenderer = function(e) {
                function t() {
                    return null === _e ? De : 1
                }

                function i(e, t, i, r) {
                    se === !0 && (e *= r, t *= r, i *= r), qe.clearColor(e, t, i, r)
                }

                function n() {
                    qe.init(), qe.scissor(Me.copy(Oe).multiplyScalar(De)), qe.viewport(Ee.copy(Fe).multiplyScalar(De)), i(Ce.r, Ce.g, Ce.b, Le)
                }

                function o() {
                    ye = null, Te = null, we = "", be = -1, qe.reset()
                }

                function a(e) {
                    e.preventDefault(), o(), n(), Ye.clear()
                }

                function s(e) {
                    var t = e.target;
                    t.removeEventListener("dispose", s), h(t), Ve.textures--
                }

                function l(e) {
                    var t = e.target;
                    t.removeEventListener("dispose", l), u(t), Ve.textures--
                }

                function c(e) {
                    var t = e.target;
                    t.removeEventListener("dispose", c), p(t)
                }

                function h(e) {
                    var t = Ye.get(e);
                    if (e.image && t.__image__webglTextureCube) Ge.deleteTexture(t.__image__webglTextureCube);
                    else {
                        if (void 0 === t.__webglInit) return;
                        Ge.deleteTexture(t.__webglTexture)
                    }
                    Ye["delete"](e)
                }

                function u(e) {
                    var t = Ye.get(e),
                        i = Ye.get(e.texture);
                    if (e && void 0 !== i.__webglTexture) {
                        if (Ge.deleteTexture(i.__webglTexture), e instanceof r.WebGLRenderTargetCube)
                            for (var n = 0; 6 > n; n++) Ge.deleteFramebuffer(t.__webglFramebuffer[n]), Ge.deleteRenderbuffer(t.__webglDepthbuffer[n]);
                        else Ge.deleteFramebuffer(t.__webglFramebuffer), Ge.deleteRenderbuffer(t.__webglDepthbuffer);
                        Ye["delete"](e.texture), Ye["delete"](e)
                    }
                }

                function p(e) {
                    f(e), Ye["delete"](e)
                }

                function f(e) {
                    var t = Ye.get(e).program;
                    e.program = void 0, void 0 !== t && Qe.releaseProgram(t)
                }

                function d(e, t, i, n) {
                    var o;
                    if (i instanceof r.InstancedBufferGeometry && (o = We.get("ANGLE_instanced_arrays"), null === o)) return void console.error("THREE.WebGLRenderer.setupVertexAttributes: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays.");
                    void 0 === n && (n = 0), qe.initAttributes();
                    var a = i.attributes,
                        s = t.getAttributes(),
                        l = e.defaultAttributeValues;
                    for (var c in s) {
                        var h = s[c];
                        if (h >= 0) {
                            var u = a[c];
                            if (void 0 !== u) {
                                var p = u.itemSize,
                                    f = Ze.getAttributeBuffer(u);
                                if (u instanceof r.InterleavedBufferAttribute) {
                                    var d = u.data,
                                        m = d.stride,
                                        g = u.offset;
                                    d instanceof r.InstancedInterleavedBuffer ? (qe.enableAttributeAndDivisor(h, d.meshPerAttribute, o), void 0 === i.maxInstancedCount && (i.maxInstancedCount = d.meshPerAttribute * d.count)) : qe.enableAttribute(h), Ge.bindBuffer(Ge.ARRAY_BUFFER, f), Ge.vertexAttribPointer(h, p, Ge.FLOAT, !1, m * d.array.BYTES_PER_ELEMENT, (n * m + g) * d.array.BYTES_PER_ELEMENT)
                                } else u instanceof r.InstancedBufferAttribute ? (qe.enableAttributeAndDivisor(h, u.meshPerAttribute, o), void 0 === i.maxInstancedCount && (i.maxInstancedCount = u.meshPerAttribute * u.count)) : qe.enableAttribute(h), Ge.bindBuffer(Ge.ARRAY_BUFFER, f), Ge.vertexAttribPointer(h, p, Ge.FLOAT, !1, 0, n * p * 4)
                            } else if (void 0 !== l) {
                                var v = l[c];
                                if (void 0 !== v) switch (v.length) {
                                    case 2:
                                        Ge.vertexAttrib2fv(h, v);
                                        break;
                                    case 3:
                                        Ge.vertexAttrib3fv(h, v);
                                        break;
                                    case 4:
                                        Ge.vertexAttrib4fv(h, v);
                                        break;
                                    default:
                                        Ge.vertexAttrib1fv(h, v)
                                }
                            }
                        }
                    }
                    qe.disableUnusedAttributes()
                }

                function m(e, t) {
                    return Math.abs(t[0]) - Math.abs(e[0])
                }

                function g(e, t) {
                    return e.object.renderOrder !== t.object.renderOrder ? e.object.renderOrder - t.object.renderOrder : e.material.id !== t.material.id ? e.material.id - t.material.id : e.z !== t.z ? e.z - t.z : e.id - t.id
                }

                function v(e, t) {
                    return e.object.renderOrder !== t.object.renderOrder ? e.object.renderOrder - t.object.renderOrder : e.z !== t.z ? t.z - e.z : e.id - t.id
                }

                function y(e, t, i, r, n) {
                    var o, a;
                    i.transparent ? (o = pe, a = ++fe) : (o = he, a = ++ue);
                    var s = o[a];
                    void 0 !== s ? (s.id = e.id, s.object = e, s.geometry = t, s.material = i, s.z = ke.z, s.group = n) : (s = {
                        id: e.id,
                        object: e,
                        geometry: t,
                        material: i,
                        z: ke.z,
                        group: n
                    }, o.push(s))
                }

                function _(e, t) {
                    if (e.visible !== !1) {
                        if (e.layers.test(t.layers))
                            if (e instanceof r.Light) ce.push(e);
                            else if (e instanceof r.Sprite) e.frustumCulled !== !1 && Ne.intersectsObject(e) !== !0 || me.push(e);
                        else if (e instanceof r.LensFlare) ge.push(e);
                        else if (e instanceof r.ImmediateRenderObject) ve.sortObjects === !0 && (ke.setFromMatrixPosition(e.matrixWorld), ke.applyProjection(Be)), y(e, null, e.material, ke.z, null);
                        else if ((e instanceof r.Mesh || e instanceof r.Line || e instanceof r.Points) && (e instanceof r.SkinnedMesh && e.skeleton.update(), e.frustumCulled === !1 || Ne.intersectsObject(e) === !0)) {
                            var i = e.material;
                            if (i.visible === !0) {
                                ve.sortObjects === !0 && (ke.setFromMatrixPosition(e.matrixWorld), ke.applyProjection(Be));
                                var n = Ze.update(e);
                                if (i instanceof r.MultiMaterial)
                                    for (var o = n.groups, a = i.materials, s = 0, l = o.length; l > s; s++) {
                                        var c = o[s],
                                            h = a[c.materialIndex];
                                        h.visible === !0 && y(e, n, h, ke.z, c)
                                    } else y(e, n, i, ke.z, null)
                            }
                        }
                        for (var u = e.children, s = 0, l = u.length; l > s; s++) _(u[s], t)
                    }
                }

                function x(e, t, i, n) {
                    for (var o = 0, a = e.length; a > o; o++) {
                        var s = e[o],
                            l = s.object,
                            c = s.geometry,
                            h = void 0 === n ? s.material : n,
                            u = s.group;
                        if (l.modelViewMatrix.multiplyMatrices(t.matrixWorldInverse, l.matrixWorld), l.normalMatrix.getNormalMatrix(l.modelViewMatrix), l instanceof r.ImmediateRenderObject) {
                            w(h);
                            var p = M(t, i, h, l);
                            we = "", l.render(function(e) {
                                ve.renderBufferImmediate(e, p, h)
                            })
                        } else ve.renderBufferDirect(t, i, c, h, l, u)
                    }
                }

                function b(e, t, i) {
                    var n = Ye.get(e),
                        o = Qe.getParameters(e, Ue, t, i),
                        a = Qe.getProgramCode(e, o),
                        s = n.program,
                        l = !0;
                    if (void 0 === s) e.addEventListener("dispose", c);
                    else if (s.code !== a) f(e);
                    else {
                        if (void 0 !== o.shaderID) return;
                        l = !1
                    }
                    if (l) {
                        if (o.shaderID) {
                            var h = r.ShaderLib[o.shaderID];
                            n.__webglShader = {
                                name: e.type,
                                uniforms: r.UniformsUtils.clone(h.uniforms),
                                vertexShader: h.vertexShader,
                                fragmentShader: h.fragmentShader
                            }
                        } else n.__webglShader = {
                            name: e.type,
                            uniforms: e.uniforms,
                            vertexShader: e.vertexShader,
                            fragmentShader: e.fragmentShader
                        };
                        e.__webglShader = n.__webglShader, s = Qe.acquireProgram(e, o, a), n.program = s, e.program = s
                    }
                    var u = s.getAttributes();
                    if (e.morphTargets) {
                        e.numSupportedMorphTargets = 0;
                        for (var p = 0; p < ve.maxMorphTargets; p++) u["morphTarget" + p] >= 0 && e.numSupportedMorphTargets++
                    }
                    if (e.morphNormals) {
                        e.numSupportedMorphNormals = 0;
                        for (var p = 0; p < ve.maxMorphNormals; p++) u["morphNormal" + p] >= 0 && e.numSupportedMorphNormals++
                    }
                    n.uniformsList = [];
                    var d = n.__webglShader.uniforms,
                        m = n.program.getUniforms();
                    for (var g in d) {
                        var v = m[g];
                        v && n.uniformsList.push([n.__webglShader.uniforms[g], v])
                    }(e instanceof r.MeshPhongMaterial || e instanceof r.MeshLambertMaterial || e instanceof r.MeshStandardMaterial || e.lights) && (n.lightsHash = Ue.hash, d.ambientLightColor.value = Ue.ambient, d.directionalLights.value = Ue.directional, d.spotLights.value = Ue.spot, d.pointLights.value = Ue.point, d.hemisphereLights.value = Ue.hemi, d.directionalShadowMap.value = Ue.directionalShadowMap, d.directionalShadowMatrix.value = Ue.directionalShadowMatrix, d.spotShadowMap.value = Ue.spotShadowMap, d.spotShadowMatrix.value = Ue.spotShadowMatrix, d.pointShadowMap.value = Ue.pointShadowMap, d.pointShadowMatrix.value = Ue.pointShadowMatrix), n.hasDynamicUniforms = !1;
                    for (var y = 0, _ = n.uniformsList.length; _ > y; y++) {
                        var x = n.uniformsList[y][0];
                        if (x.dynamic === !0) {
                            n.hasDynamicUniforms = !0;
                            break
                        }
                    }
                }

                function w(e) {
                    T(e), e.transparent === !0 ? qe.setBlending(e.blending, e.blendEquation, e.blendSrc, e.blendDst, e.blendEquationAlpha, e.blendSrcAlpha, e.blendDstAlpha, e.premultipliedAlpha) : qe.setBlending(r.NoBlending), qe.setDepthFunc(e.depthFunc), qe.setDepthTest(e.depthTest), qe.setDepthWrite(e.depthWrite), qe.setColorWrite(e.colorWrite), qe.setPolygonOffset(e.polygonOffset, e.polygonOffsetFactor, e.polygonOffsetUnits)
                }

                function T(e) {
                    e.side !== r.DoubleSide ? qe.enable(Ge.CULL_FACE) : qe.disable(Ge.CULL_FACE), qe.setFlipSided(e.side === r.BackSide)
                }

                function M(e, t, i, n) {
                    Ae = 0;
                    var o = Ye.get(i);
                    void 0 === o.program && (i.needsUpdate = !0), void 0 !== o.lightsHash && o.lightsHash !== Ue.hash && (i.needsUpdate = !0), i.needsUpdate && (b(i, t, n), i.needsUpdate = !1);
                    var a = !1,
                        s = !1,
                        l = !1,
                        c = o.program,
                        h = c.getUniforms(),
                        u = o.__webglShader.uniforms;
                    if (c.id !== ye && (Ge.useProgram(c.program), ye = c.id, a = !0, s = !0, l = !0), i.id !== be && (be = i.id, s = !0), (a || e !== Te) && (Ge.uniformMatrix4fv(h.projectionMatrix, !1, e.projectionMatrix.elements), Xe.logarithmicDepthBuffer && Ge.uniform1f(h.logDepthBufFC, 2 / (Math.log(e.far + 1) / Math.LN2)), e !== Te && (Te = e, s = !0, l = !0), (i instanceof r.ShaderMaterial || i instanceof r.MeshPhongMaterial || i instanceof r.MeshStandardMaterial || i.envMap) && void 0 !== h.cameraPosition && (ke.setFromMatrixPosition(e.matrixWorld), Ge.uniform3f(h.cameraPosition, ke.x, ke.y, ke.z)), (i instanceof r.MeshPhongMaterial || i instanceof r.MeshLambertMaterial || i instanceof r.MeshBasicMaterial || i instanceof r.MeshStandardMaterial || i instanceof r.ShaderMaterial || i.skinning) && void 0 !== h.viewMatrix && Ge.uniformMatrix4fv(h.viewMatrix, !1, e.matrixWorldInverse.elements), void 0 !== h.toneMappingExposure && Ge.uniform1f(h.toneMappingExposure, ve.toneMappingExposure), void 0 !== h.toneMappingWhitePoint && Ge.uniform1f(h.toneMappingWhitePoint, ve.toneMappingWhitePoint)), i.skinning)
                        if (n.bindMatrix && void 0 !== h.bindMatrix && Ge.uniformMatrix4fv(h.bindMatrix, !1, n.bindMatrix.elements), n.bindMatrixInverse && void 0 !== h.bindMatrixInverse && Ge.uniformMatrix4fv(h.bindMatrixInverse, !1, n.bindMatrixInverse.elements), Xe.floatVertexTextures && n.skeleton && n.skeleton.useVertexTexture) {
                            if (void 0 !== h.boneTexture) {
                                var p = N();
                                Ge.uniform1i(h.boneTexture, p), ve.setTexture(n.skeleton.boneTexture, p)
                            }
                            void 0 !== h.boneTextureWidth && Ge.uniform1i(h.boneTextureWidth, n.skeleton.boneTextureWidth), void 0 !== h.boneTextureHeight && Ge.uniform1i(h.boneTextureHeight, n.skeleton.boneTextureHeight)
                        } else n.skeleton && n.skeleton.boneMatrices && void 0 !== h.boneGlobalMatrices && Ge.uniformMatrix4fv(h.boneGlobalMatrices, !1, n.skeleton.boneMatrices);
                    return s && ((i instanceof r.MeshPhongMaterial || i instanceof r.MeshLambertMaterial || i instanceof r.MeshStandardMaterial || i.lights) && I(u, l), t && i.fog && P(u, t), (i instanceof r.MeshBasicMaterial || i instanceof r.MeshLambertMaterial || i instanceof r.MeshPhongMaterial || i instanceof r.MeshStandardMaterial) && E(u, i), i instanceof r.LineBasicMaterial ? A(u, i) : i instanceof r.LineDashedMaterial ? (A(u, i), C(u, i)) : i instanceof r.PointsMaterial ? L(u, i) : i instanceof r.MeshLambertMaterial ? R(u, i) : i instanceof r.MeshPhongMaterial ? D(u, i) : i instanceof r.MeshStandardMaterial ? O(u, i) : i instanceof r.MeshDepthMaterial ? (u.mNear.value = e.near, u.mFar.value = e.far, u.opacity.value = i.opacity) : i instanceof r.MeshNormalMaterial && (u.opacity.value = i.opacity), k(o.uniformsList)), F(h, n), void 0 !== h.modelMatrix && Ge.uniformMatrix4fv(h.modelMatrix, !1, n.matrixWorld.elements), o.hasDynamicUniforms === !0 && S(o.uniformsList, n, e), c
                }

                function S(e, t, i) {
                    for (var r = [], n = 0, o = e.length; o > n; n++) {
                        var a = e[n][0],
                            s = a.onUpdateCallback;
                        void 0 !== s && (s.bind(a)(t, i), r.push(e[n]))
                    }
                    k(r)
                }

                function E(e, t) {
                    e.opacity.value = t.opacity, e.diffuse.value = t.color, t.emissive && e.emissive.value.copy(t.emissive).multiplyScalar(t.emissiveIntensity), e.map.value = t.map, e.specularMap.value = t.specularMap, e.alphaMap.value = t.alphaMap, t.aoMap && (e.aoMap.value = t.aoMap, e.aoMapIntensity.value = t.aoMapIntensity);
                    var i;
                    if (t.map ? i = t.map : t.specularMap ? i = t.specularMap : t.displacementMap ? i = t.displacementMap : t.normalMap ? i = t.normalMap : t.bumpMap ? i = t.bumpMap : t.roughnessMap ? i = t.roughnessMap : t.metalnessMap ? i = t.metalnessMap : t.alphaMap ? i = t.alphaMap : t.emissiveMap && (i = t.emissiveMap), void 0 !== i) {
                        i instanceof r.WebGLRenderTarget && (i = i.texture);
                        var n = i.offset,
                            o = i.repeat;
                        e.offsetRepeat.value.set(n.x, n.y, o.x, o.y)
                    }
                    e.envMap.value = t.envMap, e.flipEnvMap.value = t.envMap instanceof r.WebGLRenderTargetCube ? 1 : -1, e.reflectivity.value = t.reflectivity, e.refractionRatio.value = t.refractionRatio
                }

                function A(e, t) {
                    e.diffuse.value = t.color, e.opacity.value = t.opacity
                }

                function C(e, t) {
                    e.dashSize.value = t.dashSize, e.totalSize.value = t.dashSize + t.gapSize, e.scale.value = t.scale
                }

                function L(e, t) {
                    if (e.diffuse.value = t.color, e.opacity.value = t.opacity, e.size.value = t.size * De, e.scale.value = te.clientHeight / 2, e.map.value = t.map, null !== t.map) {
                        var i = t.map.offset,
                            r = t.map.repeat;
                        e.offsetRepeat.value.set(i.x, i.y, r.x, r.y)
                    }
                }

                function P(e, t) {
                    e.fogColor.value = t.color, t instanceof r.Fog ? (e.fogNear.value = t.near, e.fogFar.value = t.far) : t instanceof r.FogExp2 && (e.fogDensity.value = t.density)
                }

                function R(e, t) {
                    t.lightMap && (e.lightMap.value = t.lightMap, e.lightMapIntensity.value = t.lightMapIntensity), t.emissiveMap && (e.emissiveMap.value = t.emissiveMap)
                }

                function D(e, t) {
                    e.specular.value = t.specular, e.shininess.value = Math.max(t.shininess, 1e-4), t.lightMap && (e.lightMap.value = t.lightMap, e.lightMapIntensity.value = t.lightMapIntensity), t.emissiveMap && (e.emissiveMap.value = t.emissiveMap), t.bumpMap && (e.bumpMap.value = t.bumpMap, e.bumpScale.value = t.bumpScale), t.normalMap && (e.normalMap.value = t.normalMap, e.normalScale.value.copy(t.normalScale)), t.displacementMap && (e.displacementMap.value = t.displacementMap, e.displacementScale.value = t.displacementScale, e.displacementBias.value = t.displacementBias)
                }

                function O(e, t) {
                    e.roughness.value = t.roughness, e.metalness.value = t.metalness, t.roughnessMap && (e.roughnessMap.value = t.roughnessMap), t.metalnessMap && (e.metalnessMap.value = t.metalnessMap), t.lightMap && (e.lightMap.value = t.lightMap, e.lightMapIntensity.value = t.lightMapIntensity), t.emissiveMap && (e.emissiveMap.value = t.emissiveMap), t.bumpMap && (e.bumpMap.value = t.bumpMap, e.bumpScale.value = t.bumpScale), t.normalMap && (e.normalMap.value = t.normalMap, e.normalScale.value.copy(t.normalScale)), t.displacementMap && (e.displacementMap.value = t.displacementMap, e.displacementScale.value = t.displacementScale, e.displacementBias.value = t.displacementBias), t.envMap && (e.envMapIntensity.value = t.envMapIntensity)
                }

                function I(e, t) {
                    e.ambientLightColor.needsUpdate = t, e.directionalLights.needsUpdate = t, e.pointLights.needsUpdate = t, e.spotLights.needsUpdate = t, e.hemisphereLights.needsUpdate = t
                }

                function F(e, t) {
                    Ge.uniformMatrix4fv(e.modelViewMatrix, !1, t.modelViewMatrix.elements), e.normalMatrix && Ge.uniformMatrix3fv(e.normalMatrix, !1, t.normalMatrix.elements)
                }

                function N() {
                    var e = Ae;
                    return e >= Xe.maxTextures && console.warn("WebGLRenderer: trying to use " + e + " texture units while this GPU supports only " + Xe.maxTextures), Ae += 1, e
                }

                function B(e, t, i, n) {
                    var o, a;
                    if ("1i" === t) Ge.uniform1i(i, n);
                    else if ("1f" === t) Ge.uniform1f(i, n);
                    else if ("2f" === t) Ge.uniform2f(i, n[0], n[1]);
                    else if ("3f" === t) Ge.uniform3f(i, n[0], n[1], n[2]);
                    else if ("4f" === t) Ge.uniform4f(i, n[0], n[1], n[2], n[3]);
                    else if ("1iv" === t) Ge.uniform1iv(i, n);
                    else if ("3iv" === t) Ge.uniform3iv(i, n);
                    else if ("1fv" === t) Ge.uniform1fv(i, n);
                    else if ("2fv" === t) Ge.uniform2fv(i, n);
                    else if ("3fv" === t) Ge.uniform3fv(i, n);
                    else if ("4fv" === t) Ge.uniform4fv(i, n);
                    else if ("Matrix2fv" === t) Ge.uniformMatrix2fv(i, !1, n);
                    else if ("Matrix3fv" === t) Ge.uniformMatrix3fv(i, !1, n);
                    else if ("Matrix4fv" === t) Ge.uniformMatrix4fv(i, !1, n);
                    else if ("i" === t) Ge.uniform1i(i, n);
                    else if ("f" === t) Ge.uniform1f(i, n);
                    else if ("v2" === t) Ge.uniform2f(i, n.x, n.y);
                    else if ("v3" === t) Ge.uniform3f(i, n.x, n.y, n.z);
                    else if ("v4" === t) Ge.uniform4f(i, n.x, n.y, n.z, n.w);
                    else if ("c" === t) Ge.uniform3f(i, n.r, n.g, n.b);
                    else if ("s" === t) {
                        var s = e.properties;
                        for (var l in s) {
                            var c = s[l],
                                h = i[l],
                                u = n[l];
                            B(c, c.type, h, u)
                        }
                    } else if ("sa" === t)
                        for (var s = e.properties, p = 0, f = n.length; f > p; p++)
                            for (var l in s) {
                                var c = s[l],
                                    h = i[p][l],
                                    u = n[p][l];
                                B(c, c.type, h, u)
                            } else if ("iv1" === t) Ge.uniform1iv(i, n);
                            else if ("iv" === t) Ge.uniform3iv(i, n);
                    else if ("fv1" === t) Ge.uniform1fv(i, n);
                    else if ("fv" === t) Ge.uniform3fv(i, n);
                    else if ("v2v" === t) {
                        void 0 === e._array && (e._array = new Float32Array(2 * n.length));
                        for (var p = 0, d = 0, m = n.length; m > p; p++, d += 2) e._array[d + 0] = n[p].x, e._array[d + 1] = n[p].y;
                        Ge.uniform2fv(i, e._array)
                    } else if ("v3v" === t) {
                        void 0 === e._array && (e._array = new Float32Array(3 * n.length));
                        for (var p = 0, g = 0, m = n.length; m > p; p++, g += 3) e._array[g + 0] = n[p].x, e._array[g + 1] = n[p].y, e._array[g + 2] = n[p].z;
                        Ge.uniform3fv(i, e._array)
                    } else if ("v4v" === t) {
                        void 0 === e._array && (e._array = new Float32Array(4 * n.length));
                        for (var p = 0, v = 0, m = n.length; m > p; p++, v += 4) e._array[v + 0] = n[p].x, e._array[v + 1] = n[p].y, e._array[v + 2] = n[p].z, e._array[v + 3] = n[p].w;
                        Ge.uniform4fv(i, e._array)
                    } else if ("m2" === t) Ge.uniformMatrix2fv(i, !1, n.elements);
                    else if ("m3" === t) Ge.uniformMatrix3fv(i, !1, n.elements);
                    else if ("m3v" === t) {
                        void 0 === e._array && (e._array = new Float32Array(9 * n.length));
                        for (var p = 0, m = n.length; m > p; p++) n[p].flattenToArrayOffset(e._array, 9 * p);
                        Ge.uniformMatrix3fv(i, !1, e._array)
                    } else if ("m4" === t) Ge.uniformMatrix4fv(i, !1, n.elements);
                    else if ("m4v" === t) {
                        void 0 === e._array && (e._array = new Float32Array(16 * n.length));
                        for (var p = 0, m = n.length; m > p; p++) n[p].flattenToArrayOffset(e._array, 16 * p);
                        Ge.uniformMatrix4fv(i, !1, e._array)
                    } else if ("t" === t) {
                        if (o = n, a = N(), Ge.uniform1i(i, a), !o) return;
                        o instanceof r.CubeTexture || Array.isArray(o.image) && 6 === o.image.length ? X(o, a) : o instanceof r.WebGLRenderTargetCube ? q(o.texture, a) : o instanceof r.WebGLRenderTarget ? ve.setTexture(o.texture, a) : ve.setTexture(o, a)
                    } else if ("tv" === t) {
                        void 0 === e._array && (e._array = []);
                        for (var p = 0, m = e.value.length; m > p; p++) e._array[p] = N();
                        Ge.uniform1iv(i, e._array);
                        for (var p = 0, m = e.value.length; m > p; p++) o = e.value[p], a = e._array[p], o && (o instanceof r.CubeTexture || o.image instanceof Array && 6 === o.image.length ? X(o, a) : o instanceof r.WebGLRenderTarget ? ve.setTexture(o.texture, a) : o instanceof r.WebGLRenderTargetCube ? q(o.texture, a) : ve.setTexture(o, a))
                    } else console.warn("THREE.WebGLRenderer: Unknown uniform type: " + t)
                }

                function k(e) {
                    for (var t = 0, i = e.length; i > t; t++) {
                        var r = e[t][0];
                        if (r.needsUpdate !== !1) {
                            var n = r.type,
                                o = e[t][1],
                                a = r.value;
                            B(r, n, o, a)
                        }
                    }
                }

                function U(e, t) {
                    var i, n, o, a, s, l, c = 0,
                        h = 0,
                        u = 0,
                        p = t.matrixWorldInverse,
                        f = 0,
                        d = 0,
                        m = 0,
                        g = 0,
                        v = 0;
                    for (Ue.shadowsPointLight = 0, i = 0, n = e.length; n > i; i++)
                        if (o = e[i], a = o.color, s = o.intensity, l = o.distance, o instanceof r.AmbientLight) c += a.r * s, h += a.g * s, u += a.b * s;
                        else if (o instanceof r.DirectionalLight) {
                        var y = Ke.get(o);
                        y.color.copy(o.color).multiplyScalar(o.intensity), y.direction.setFromMatrixPosition(o.matrixWorld), ke.setFromMatrixPosition(o.target.matrixWorld), y.direction.sub(ke), y.direction.transformDirection(p), y.shadow = o.castShadow, o.castShadow && (y.shadowBias = o.shadow.bias, y.shadowRadius = o.shadow.radius, y.shadowMapSize = o.shadow.mapSize, Ue.shadows[v++] = o), Ue.directionalShadowMap[f] = o.shadow.map, Ue.directionalShadowMatrix[f] = o.shadow.matrix, Ue.directional[f++] = y
                    } else if (o instanceof r.SpotLight) {
                        var y = Ke.get(o);
                        y.position.setFromMatrixPosition(o.matrixWorld), y.position.applyMatrix4(p), y.color.copy(a).multiplyScalar(s), y.distance = l, y.direction.setFromMatrixPosition(o.matrixWorld), ke.setFromMatrixPosition(o.target.matrixWorld), y.direction.sub(ke), y.direction.transformDirection(p), y.coneCos = Math.cos(o.angle), y.penumbraCos = Math.cos(o.angle * (1 - o.penumbra)), y.decay = 0 === o.distance ? 0 : o.decay, y.shadow = o.castShadow, o.castShadow && (y.shadowBias = o.shadow.bias, y.shadowRadius = o.shadow.radius, y.shadowMapSize = o.shadow.mapSize, Ue.shadows[v++] = o), Ue.spotShadowMap[m] = o.shadow.map, Ue.spotShadowMatrix[m] = o.shadow.matrix, Ue.spot[m++] = y
                    } else if (o instanceof r.PointLight) {
                        var y = Ke.get(o);
                        y.position.setFromMatrixPosition(o.matrixWorld), y.position.applyMatrix4(p), y.color.copy(o.color).multiplyScalar(o.intensity), y.distance = o.distance, y.decay = 0 === o.distance ? 0 : o.decay, y.shadow = o.castShadow, o.castShadow && (y.shadowBias = o.shadow.bias, y.shadowRadius = o.shadow.radius, y.shadowMapSize = o.shadow.mapSize, Ue.shadows[v++] = o), Ue.pointShadowMap[d] = o.shadow.map, void 0 === Ue.pointShadowMatrix[d] && (Ue.pointShadowMatrix[d] = new r.Matrix4), ke.setFromMatrixPosition(o.matrixWorld).negate(), Ue.pointShadowMatrix[d].identity().setPosition(ke), Ue.point[d++] = y
                    } else if (o instanceof r.HemisphereLight) {
                        var y = Ke.get(o);
                        y.direction.setFromMatrixPosition(o.matrixWorld), y.direction.transformDirection(p), y.direction.normalize(), y.skyColor.copy(o.color).multiplyScalar(s), y.groundColor.copy(o.groundColor).multiplyScalar(s), Ue.hemi[g++] = y
                    }
                    Ue.ambient[0] = c, Ue.ambient[1] = h, Ue.ambient[2] = u, Ue.directional.length = f, Ue.spot.length = m, Ue.point.length = d, Ue.hemi.length = g, Ue.shadows.length = v, Ue.hash = f + "," + d + "," + m + "," + g + "," + v
                }

                function V(e, t, i) {
                    var n;
                    if (i ? (Ge.texParameteri(e, Ge.TEXTURE_WRAP_S, ee(t.wrapS)), Ge.texParameteri(e, Ge.TEXTURE_WRAP_T, ee(t.wrapT)), Ge.texParameteri(e, Ge.TEXTURE_MAG_FILTER, ee(t.magFilter)), Ge.texParameteri(e, Ge.TEXTURE_MIN_FILTER, ee(t.minFilter))) : (Ge.texParameteri(e, Ge.TEXTURE_WRAP_S, Ge.CLAMP_TO_EDGE), Ge.texParameteri(e, Ge.TEXTURE_WRAP_T, Ge.CLAMP_TO_EDGE), t.wrapS === r.ClampToEdgeWrapping && t.wrapT === r.ClampToEdgeWrapping || console.warn("THREE.WebGLRenderer: Texture is not power of two. Texture.wrapS and Texture.wrapT should be set to THREE.ClampToEdgeWrapping.", t), Ge.texParameteri(e, Ge.TEXTURE_MAG_FILTER, J(t.magFilter)), Ge.texParameteri(e, Ge.TEXTURE_MIN_FILTER, J(t.minFilter)), t.minFilter !== r.NearestFilter && t.minFilter !== r.LinearFilter && console.warn("THREE.WebGLRenderer: Texture is not power of two. Texture.minFilter should be set to THREE.NearestFilter or THREE.LinearFilter.", t)), n = We.get("EXT_texture_filter_anisotropic")) {
                        if (t.type === r.FloatType && null === We.get("OES_texture_float_linear")) return;
                        if (t.type === r.HalfFloatType && null === We.get("OES_texture_half_float_linear")) return;
                        (t.anisotropy > 1 || Ye.get(t).__currentAnisotropy) && (Ge.texParameterf(e, n.TEXTURE_MAX_ANISOTROPY_EXT, Math.min(t.anisotropy, ve.getMaxAnisotropy())), Ye.get(t).__currentAnisotropy = t.anisotropy)
                    }
                }

                function z(e, t, i) {
                    void 0 === e.__webglInit && (e.__webglInit = !0, t.addEventListener("dispose", s), e.__webglTexture = Ge.createTexture(), Ve.textures++), qe.activeTexture(Ge.TEXTURE0 + i), qe.bindTexture(Ge.TEXTURE_2D, e.__webglTexture), Ge.pixelStorei(Ge.UNPACK_FLIP_Y_WEBGL, t.flipY), Ge.pixelStorei(Ge.UNPACK_PREMULTIPLY_ALPHA_WEBGL, t.premultiplyAlpha), Ge.pixelStorei(Ge.UNPACK_ALIGNMENT, t.unpackAlignment);
                    var n = G(t.image, Xe.maxTextureSize);
                    j(t) && H(n) === !1 && (n = W(n));
                    var o = H(n),
                        a = ee(t.format),
                        l = ee(t.type);
                    V(Ge.TEXTURE_2D, t, o);
                    var c, h = t.mipmaps;
                    if (t instanceof r.DataTexture)
                        if (h.length > 0 && o) {
                            for (var u = 0, p = h.length; p > u; u++) c = h[u], qe.texImage2D(Ge.TEXTURE_2D, u, a, c.width, c.height, 0, a, l, c.data);
                            t.generateMipmaps = !1
                        } else qe.texImage2D(Ge.TEXTURE_2D, 0, a, n.width, n.height, 0, a, l, n.data);
                    else if (t instanceof r.CompressedTexture)
                        for (var u = 0, p = h.length; p > u; u++) c = h[u], t.format !== r.RGBAFormat && t.format !== r.RGBFormat ? qe.getCompressedTextureFormats().indexOf(a) > -1 ? qe.compressedTexImage2D(Ge.TEXTURE_2D, u, a, c.width, c.height, 0, c.data) : console.warn("THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .uploadTexture()") : qe.texImage2D(Ge.TEXTURE_2D, u, a, c.width, c.height, 0, a, l, c.data);
                    else if (h.length > 0 && o) {
                        for (var u = 0, p = h.length; p > u; u++) c = h[u], qe.texImage2D(Ge.TEXTURE_2D, u, a, a, l, c);
                        t.generateMipmaps = !1
                    } else qe.texImage2D(Ge.TEXTURE_2D, 0, a, a, l, n);
                    t.generateMipmaps && o && Ge.generateMipmap(Ge.TEXTURE_2D), e.__version = t.version, t.onUpdate && t.onUpdate(t)
                }

                function G(e, t) {
                    if (e.width > t || e.height > t) {
                        var i = t / Math.max(e.width, e.height),
                            r = document.createElement("canvas");
                        r.width = Math.floor(e.width * i), r.height = Math.floor(e.height * i);
                        var n = r.getContext("2d");
                        return n.drawImage(e, 0, 0, e.width, e.height, 0, 0, r.width, r.height), console.warn("THREE.WebGLRenderer: image is too big (" + e.width + "x" + e.height + "). Resized to " + r.width + "x" + r.height, e), r
                    }
                    return e
                }

                function H(e) {
                    return r.Math.isPowerOfTwo(e.width) && r.Math.isPowerOfTwo(e.height)
                }

                function j(e) {
                    return e.wrapS !== r.ClampToEdgeWrapping || e.wrapT !== r.ClampToEdgeWrapping ? !0 : e.minFilter !== r.NearestFilter && e.minFilter !== r.LinearFilter
                }

                function W(e) {
                    if (e instanceof HTMLImageElement || e instanceof HTMLCanvasElement) {
                        var t = document.createElement("canvas");
                        t.width = r.Math.nearestPowerOfTwo(e.width), t.height = r.Math.nearestPowerOfTwo(e.height);
                        var i = t.getContext("2d");
                        return i.drawImage(e, 0, 0, t.width, t.height), console.warn("THREE.WebGLRenderer: image is not power of two (" + e.width + "x" + e.height + "). Resized to " + t.width + "x" + t.height, e), t
                    }
                    return e
                }

                function X(e, t) {
                    var i = Ye.get(e);
                    if (6 === e.image.length)
                        if (e.version > 0 && i.__version !== e.version) {
                            i.__image__webglTextureCube || (e.addEventListener("dispose", s), i.__image__webglTextureCube = Ge.createTexture(), Ve.textures++), qe.activeTexture(Ge.TEXTURE0 + t), qe.bindTexture(Ge.TEXTURE_CUBE_MAP, i.__image__webglTextureCube), Ge.pixelStorei(Ge.UNPACK_FLIP_Y_WEBGL, e.flipY);
                            for (var n = e instanceof r.CompressedTexture, o = e.image[0] instanceof r.DataTexture, a = [], l = 0; 6 > l; l++) !ve.autoScaleCubemaps || n || o ? a[l] = o ? e.image[l].image : e.image[l] : a[l] = G(e.image[l], Xe.maxCubemapSize);
                            var c = a[0],
                                h = H(c),
                                u = ee(e.format),
                                p = ee(e.type);
                            V(Ge.TEXTURE_CUBE_MAP, e, h);
                            for (var l = 0; 6 > l; l++)
                                if (n)
                                    for (var f, d = a[l].mipmaps, m = 0, g = d.length; g > m; m++) f = d[m], e.format !== r.RGBAFormat && e.format !== r.RGBFormat ? qe.getCompressedTextureFormats().indexOf(u) > -1 ? qe.compressedTexImage2D(Ge.TEXTURE_CUBE_MAP_POSITIVE_X + l, m, u, f.width, f.height, 0, f.data) : console.warn("THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .setCubeTexture()") : qe.texImage2D(Ge.TEXTURE_CUBE_MAP_POSITIVE_X + l, m, u, f.width, f.height, 0, u, p, f.data);
                                else o ? qe.texImage2D(Ge.TEXTURE_CUBE_MAP_POSITIVE_X + l, 0, u, a[l].width, a[l].height, 0, u, p, a[l].data) : qe.texImage2D(Ge.TEXTURE_CUBE_MAP_POSITIVE_X + l, 0, u, u, p, a[l]);
                            e.generateMipmaps && h && Ge.generateMipmap(Ge.TEXTURE_CUBE_MAP), i.__version = e.version, e.onUpdate && e.onUpdate(e)
                        } else qe.activeTexture(Ge.TEXTURE0 + t), qe.bindTexture(Ge.TEXTURE_CUBE_MAP, i.__image__webglTextureCube)
                }

                function q(e, t) {
                    qe.activeTexture(Ge.TEXTURE0 + t), qe.bindTexture(Ge.TEXTURE_CUBE_MAP, Ye.get(e).__webglTexture)
                }

                function Y(e, t, i, r) {
                    var n = ee(t.texture.format),
                        o = ee(t.texture.type);
                    qe.texImage2D(r, 0, n, t.width, t.height, 0, n, o, null), Ge.bindFramebuffer(Ge.FRAMEBUFFER, e), Ge.framebufferTexture2D(Ge.FRAMEBUFFER, i, r, Ye.get(t.texture).__webglTexture, 0), Ge.bindFramebuffer(Ge.FRAMEBUFFER, null)
                }

                function Z(e, t) {
                    Ge.bindRenderbuffer(Ge.RENDERBUFFER, e), t.depthBuffer && !t.stencilBuffer ? (Ge.renderbufferStorage(Ge.RENDERBUFFER, Ge.DEPTH_COMPONENT16, t.width, t.height), Ge.framebufferRenderbuffer(Ge.FRAMEBUFFER, Ge.DEPTH_ATTACHMENT, Ge.RENDERBUFFER, e)) : t.depthBuffer && t.stencilBuffer ? (Ge.renderbufferStorage(Ge.RENDERBUFFER, Ge.DEPTH_STENCIL, t.width, t.height), Ge.framebufferRenderbuffer(Ge.FRAMEBUFFER, Ge.DEPTH_STENCIL_ATTACHMENT, Ge.RENDERBUFFER, e)) : Ge.renderbufferStorage(Ge.RENDERBUFFER, Ge.RGBA4, t.width, t.height), Ge.bindRenderbuffer(Ge.RENDERBUFFER, null)
                }

                function Q(e) {
                    var t = Ye.get(e),
                        i = e instanceof r.WebGLRenderTargetCube;
                    if (i) {
                        t.__webglDepthbuffer = [];
                        for (var n = 0; 6 > n; n++) Ge.bindFramebuffer(Ge.FRAMEBUFFER, t.__webglFramebuffer[n]), t.__webglDepthbuffer[n] = Ge.createRenderbuffer(), Z(t.__webglDepthbuffer[n], e)
                    } else Ge.bindFramebuffer(Ge.FRAMEBUFFER, t.__webglFramebuffer), t.__webglDepthbuffer = Ge.createRenderbuffer(), Z(t.__webglDepthbuffer, e);
                    Ge.bindFramebuffer(Ge.FRAMEBUFFER, null)
                }

                function K(e) {
                    var t = Ye.get(e),
                        i = Ye.get(e.texture);
                    e.addEventListener("dispose", l), i.__webglTexture = Ge.createTexture(), Ve.textures++;
                    var n = e instanceof r.WebGLRenderTargetCube,
                        o = r.Math.isPowerOfTwo(e.width) && r.Math.isPowerOfTwo(e.height);
                    if (n) {
                        t.__webglFramebuffer = [];
                        for (var a = 0; 6 > a; a++) t.__webglFramebuffer[a] = Ge.createFramebuffer()
                    } else t.__webglFramebuffer = Ge.createFramebuffer();
                    if (n) {
                        qe.bindTexture(Ge.TEXTURE_CUBE_MAP, i.__webglTexture), V(Ge.TEXTURE_CUBE_MAP, e.texture, o);
                        for (var a = 0; 6 > a; a++) Y(t.__webglFramebuffer[a], e, Ge.COLOR_ATTACHMENT0, Ge.TEXTURE_CUBE_MAP_POSITIVE_X + a);
                        e.texture.generateMipmaps && o && Ge.generateMipmap(Ge.TEXTURE_CUBE_MAP),
                            qe.bindTexture(Ge.TEXTURE_CUBE_MAP, null)
                    } else qe.bindTexture(Ge.TEXTURE_2D, i.__webglTexture), V(Ge.TEXTURE_2D, e.texture, o), Y(t.__webglFramebuffer, e, Ge.COLOR_ATTACHMENT0, Ge.TEXTURE_2D), e.texture.generateMipmaps && o && Ge.generateMipmap(Ge.TEXTURE_2D), qe.bindTexture(Ge.TEXTURE_2D, null);
                    e.depthBuffer && Q(e)
                }

                function $(e) {
                    var t = e instanceof r.WebGLRenderTargetCube ? Ge.TEXTURE_CUBE_MAP : Ge.TEXTURE_2D,
                        i = Ye.get(e.texture).__webglTexture;
                    qe.bindTexture(t, i), Ge.generateMipmap(t), qe.bindTexture(t, null)
                }

                function J(e) {
                    return e === r.NearestFilter || e === r.NearestMipMapNearestFilter || e === r.NearestMipMapLinearFilter ? Ge.NEAREST : Ge.LINEAR
                }

                function ee(e) {
                    var t;
                    if (e === r.RepeatWrapping) return Ge.REPEAT;
                    if (e === r.ClampToEdgeWrapping) return Ge.CLAMP_TO_EDGE;
                    if (e === r.MirroredRepeatWrapping) return Ge.MIRRORED_REPEAT;
                    if (e === r.NearestFilter) return Ge.NEAREST;
                    if (e === r.NearestMipMapNearestFilter) return Ge.NEAREST_MIPMAP_NEAREST;
                    if (e === r.NearestMipMapLinearFilter) return Ge.NEAREST_MIPMAP_LINEAR;
                    if (e === r.LinearFilter) return Ge.LINEAR;
                    if (e === r.LinearMipMapNearestFilter) return Ge.LINEAR_MIPMAP_NEAREST;
                    if (e === r.LinearMipMapLinearFilter) return Ge.LINEAR_MIPMAP_LINEAR;
                    if (e === r.UnsignedByteType) return Ge.UNSIGNED_BYTE;
                    if (e === r.UnsignedShort4444Type) return Ge.UNSIGNED_SHORT_4_4_4_4;
                    if (e === r.UnsignedShort5551Type) return Ge.UNSIGNED_SHORT_5_5_5_1;
                    if (e === r.UnsignedShort565Type) return Ge.UNSIGNED_SHORT_5_6_5;
                    if (e === r.ByteType) return Ge.BYTE;
                    if (e === r.ShortType) return Ge.SHORT;
                    if (e === r.UnsignedShortType) return Ge.UNSIGNED_SHORT;
                    if (e === r.IntType) return Ge.INT;
                    if (e === r.UnsignedIntType) return Ge.UNSIGNED_INT;
                    if (e === r.FloatType) return Ge.FLOAT;
                    if (t = We.get("OES_texture_half_float"), null !== t && e === r.HalfFloatType) return t.HALF_FLOAT_OES;
                    if (e === r.AlphaFormat) return Ge.ALPHA;
                    if (e === r.RGBFormat) return Ge.RGB;
                    if (e === r.RGBAFormat) return Ge.RGBA;
                    if (e === r.LuminanceFormat) return Ge.LUMINANCE;
                    if (e === r.LuminanceAlphaFormat) return Ge.LUMINANCE_ALPHA;
                    if (e === r.AddEquation) return Ge.FUNC_ADD;
                    if (e === r.SubtractEquation) return Ge.FUNC_SUBTRACT;
                    if (e === r.ReverseSubtractEquation) return Ge.FUNC_REVERSE_SUBTRACT;
                    if (e === r.ZeroFactor) return Ge.ZERO;
                    if (e === r.OneFactor) return Ge.ONE;
                    if (e === r.SrcColorFactor) return Ge.SRC_COLOR;
                    if (e === r.OneMinusSrcColorFactor) return Ge.ONE_MINUS_SRC_COLOR;
                    if (e === r.SrcAlphaFactor) return Ge.SRC_ALPHA;
                    if (e === r.OneMinusSrcAlphaFactor) return Ge.ONE_MINUS_SRC_ALPHA;
                    if (e === r.DstAlphaFactor) return Ge.DST_ALPHA;
                    if (e === r.OneMinusDstAlphaFactor) return Ge.ONE_MINUS_DST_ALPHA;
                    if (e === r.DstColorFactor) return Ge.DST_COLOR;
                    if (e === r.OneMinusDstColorFactor) return Ge.ONE_MINUS_DST_COLOR;
                    if (e === r.SrcAlphaSaturateFactor) return Ge.SRC_ALPHA_SATURATE;
                    if (t = We.get("WEBGL_compressed_texture_s3tc"), null !== t) {
                        if (e === r.RGB_S3TC_DXT1_Format) return t.COMPRESSED_RGB_S3TC_DXT1_EXT;
                        if (e === r.RGBA_S3TC_DXT1_Format) return t.COMPRESSED_RGBA_S3TC_DXT1_EXT;
                        if (e === r.RGBA_S3TC_DXT3_Format) return t.COMPRESSED_RGBA_S3TC_DXT3_EXT;
                        if (e === r.RGBA_S3TC_DXT5_Format) return t.COMPRESSED_RGBA_S3TC_DXT5_EXT
                    }
                    if (t = We.get("WEBGL_compressed_texture_pvrtc"), null !== t) {
                        if (e === r.RGB_PVRTC_4BPPV1_Format) return t.COMPRESSED_RGB_PVRTC_4BPPV1_IMG;
                        if (e === r.RGB_PVRTC_2BPPV1_Format) return t.COMPRESSED_RGB_PVRTC_2BPPV1_IMG;
                        if (e === r.RGBA_PVRTC_4BPPV1_Format) return t.COMPRESSED_RGBA_PVRTC_4BPPV1_IMG;
                        if (e === r.RGBA_PVRTC_2BPPV1_Format) return t.COMPRESSED_RGBA_PVRTC_2BPPV1_IMG
                    }
                    if (t = We.get("WEBGL_compressed_texture_etc1"), null !== t && e === r.RGB_ETC1_Format) return t.COMPRESSED_RGB_ETC1_WEBGL;
                    if (t = We.get("EXT_blend_minmax"), null !== t) {
                        if (e === r.MinEquation) return t.MIN_EXT;
                        if (e === r.MaxEquation) return t.MAX_EXT
                    }
                    return 0
                }
                console.log("THREE.WebGLRenderer", r.REVISION), e = e || {};
                var te = void 0 !== e.canvas ? e.canvas : document.createElement("canvas"),
                    ie = void 0 !== e.context ? e.context : null,
                    re = void 0 !== e.alpha ? e.alpha : !1,
                    ne = void 0 !== e.depth ? e.depth : !0,
                    oe = void 0 !== e.stencil ? e.stencil : !0,
                    ae = void 0 !== e.antialias ? e.antialias : !1,
                    se = void 0 !== e.premultipliedAlpha ? e.premultipliedAlpha : !0,
                    le = void 0 !== e.preserveDrawingBuffer ? e.preserveDrawingBuffer : !1,
                    ce = [],
                    he = [],
                    ue = -1,
                    pe = [],
                    fe = -1,
                    de = new Float32Array(8),
                    me = [],
                    ge = [];
                this.domElement = te, this.context = null, this.autoClear = !0, this.autoClearColor = !0, this.autoClearDepth = !0, this.autoClearStencil = !0, this.sortObjects = !0, this.gammaFactor = 2, this.gammaInput = !1, this.gammaOutput = !1, this.physicallyCorrectLights = !1, this.toneMapping = r.LinearToneMapping, this.toneMappingExposure = 1, this.toneMappingWhitePoint = 1, this.maxMorphTargets = 8, this.maxMorphNormals = 4, this.autoScaleCubemaps = !0;
                var ve = this,
                    ye = null,
                    _e = null,
                    xe = null,
                    be = -1,
                    we = "",
                    Te = null,
                    Me = new r.Vector4,
                    Se = null,
                    Ee = new r.Vector4,
                    Ae = 0,
                    Ce = new r.Color(0),
                    Le = 0,
                    Pe = te.width,
                    Re = te.height,
                    De = 1,
                    Oe = new r.Vector4(0, 0, Pe, Re),
                    Ie = !1,
                    Fe = new r.Vector4(0, 0, Pe, Re),
                    Ne = new r.Frustum,
                    Be = new r.Matrix4,
                    ke = new r.Vector3,
                    Ue = {
                        hash: "",
                        ambient: [0, 0, 0],
                        directional: [],
                        directionalShadowMap: [],
                        directionalShadowMatrix: [],
                        spot: [],
                        spotShadowMap: [],
                        spotShadowMatrix: [],
                        point: [],
                        pointShadowMap: [],
                        pointShadowMatrix: [],
                        hemi: [],
                        shadows: [],
                        shadowsPointLight: 0
                    },
                    Ve = {
                        geometries: 0,
                        textures: 0
                    },
                    ze = {
                        calls: 0,
                        vertices: 0,
                        faces: 0,
                        points: 0
                    };
                this.info = {
                    render: ze,
                    memory: Ve,
                    programs: null
                };
                var Ge;
                try {
                    var He = {
                        alpha: re,
                        depth: ne,
                        stencil: oe,
                        antialias: ae,
                        premultipliedAlpha: se,
                        preserveDrawingBuffer: le
                    };
                    if (Ge = ie || te.getContext("webgl", He) || te.getContext("experimental-webgl", He), null === Ge) throw null !== te.getContext("webgl") ? "Error creating WebGL context with your selected attributes." : "Error creating WebGL context.";
                    void 0 === Ge.getShaderPrecisionFormat && (Ge.getShaderPrecisionFormat = function() {
                        return {
                            rangeMin: 1,
                            rangeMax: 1,
                            precision: 1
                        }
                    }), te.addEventListener("webglcontextlost", a, !1)
                } catch (je) {
                    console.error("THREE.WebGLRenderer: " + je)
                }
                var We = new r.WebGLExtensions(Ge);
                We.get("OES_texture_float"), We.get("OES_texture_float_linear"), We.get("OES_texture_half_float"), We.get("OES_texture_half_float_linear"), We.get("OES_standard_derivatives"), We.get("ANGLE_instanced_arrays"), We.get("OES_element_index_uint") && (r.BufferGeometry.MaxIndex = 4294967296);
                var Xe = new r.WebGLCapabilities(Ge, We, e),
                    qe = new r.WebGLState(Ge, We, ee),
                    Ye = new r.WebGLProperties,
                    Ze = new r.WebGLObjects(Ge, Ye, this.info),
                    Qe = new r.WebGLPrograms(this, Xe),
                    Ke = new r.WebGLLights;
                this.info.programs = Qe.programs;
                var $e = new r.WebGLBufferRenderer(Ge, We, ze),
                    Je = new r.WebGLIndexedBufferRenderer(Ge, We, ze);
                n(), this.context = Ge, this.capabilities = Xe, this.extensions = We, this.properties = Ye, this.state = qe;
                var et = new r.WebGLShadowMap(this, Ue, Ze);
                this.shadowMap = et;
                var tt = new r.SpritePlugin(this, me),
                    it = new r.LensFlarePlugin(this, ge);
                this.getContext = function() {
                    return Ge
                }, this.getContextAttributes = function() {
                    return Ge.getContextAttributes()
                }, this.forceContextLoss = function() {
                    We.get("WEBGL_lose_context").loseContext()
                }, this.getMaxAnisotropy = function() {
                    var e;
                    return function() {
                        if (void 0 !== e) return e;
                        var t = We.get("EXT_texture_filter_anisotropic");
                        return e = null !== t ? Ge.getParameter(t.MAX_TEXTURE_MAX_ANISOTROPY_EXT) : 0
                    }
                }(), this.getPrecision = function() {
                    return Xe.precision
                }, this.getPixelRatio = function() {
                    return De
                }, this.setPixelRatio = function(e) {
                    void 0 !== e && (De = e, this.setSize(Fe.z, Fe.w, !1))
                }, this.getSize = function() {
                    return {
                        width: Pe,
                        height: Re
                    }
                }, this.setSize = function(e, t, i) {
                    Pe = e, Re = t, te.width = e * De, te.height = t * De, i !== !1 && (te.style.width = e + "px", te.style.height = t + "px"), this.setViewport(0, 0, e, t)
                }, this.setViewport = function(e, t, i, r) {
                    qe.viewport(Fe.set(e, t, i, r))
                }, this.setScissor = function(e, t, i, r) {
                    qe.scissor(Oe.set(e, t, i, r))
                }, this.setScissorTest = function(e) {
                    qe.setScissorTest(Ie = e)
                }, this.getClearColor = function() {
                    return Ce
                }, this.setClearColor = function(e, t) {
                    Ce.set(e), Le = void 0 !== t ? t : 1, i(Ce.r, Ce.g, Ce.b, Le)
                }, this.getClearAlpha = function() {
                    return Le
                }, this.setClearAlpha = function(e) {
                    Le = e, i(Ce.r, Ce.g, Ce.b, Le)
                }, this.clear = function(e, t, i) {
                    var r = 0;
                    (void 0 === e || e) && (r |= Ge.COLOR_BUFFER_BIT), (void 0 === t || t) && (r |= Ge.DEPTH_BUFFER_BIT), (void 0 === i || i) && (r |= Ge.STENCIL_BUFFER_BIT), Ge.clear(r)
                }, this.clearColor = function() {
                    this.clear(!0, !1, !1)
                }, this.clearDepth = function() {
                    this.clear(!1, !0, !1)
                }, this.clearStencil = function() {
                    this.clear(!1, !1, !0)
                }, this.clearTarget = function(e, t, i, r) {
                    this.setRenderTarget(e), this.clear(t, i, r)
                }, this.resetGLState = o, this.dispose = function() {
                    te.removeEventListener("webglcontextlost", a, !1)
                }, this.renderBufferImmediate = function(e, t, i) {
                    qe.initAttributes();
                    var n = Ye.get(e);
                    e.hasPositions && !n.position && (n.position = Ge.createBuffer()), e.hasNormals && !n.normal && (n.normal = Ge.createBuffer()), e.hasUvs && !n.uv && (n.uv = Ge.createBuffer()), e.hasColors && !n.color && (n.color = Ge.createBuffer());
                    var o = t.getAttributes();
                    if (e.hasPositions && (Ge.bindBuffer(Ge.ARRAY_BUFFER, n.position), Ge.bufferData(Ge.ARRAY_BUFFER, e.positionArray, Ge.DYNAMIC_DRAW), qe.enableAttribute(o.position), Ge.vertexAttribPointer(o.position, 3, Ge.FLOAT, !1, 0, 0)), e.hasNormals) {
                        if (Ge.bindBuffer(Ge.ARRAY_BUFFER, n.normal), "MeshPhongMaterial" !== i.type && "MeshStandardMaterial" !== i.type && i.shading === r.FlatShading)
                            for (var a = 0, s = 3 * e.count; s > a; a += 9) {
                                var l = e.normalArray,
                                    c = (l[a + 0] + l[a + 3] + l[a + 6]) / 3,
                                    h = (l[a + 1] + l[a + 4] + l[a + 7]) / 3,
                                    u = (l[a + 2] + l[a + 5] + l[a + 8]) / 3;
                                l[a + 0] = c, l[a + 1] = h, l[a + 2] = u, l[a + 3] = c, l[a + 4] = h, l[a + 5] = u, l[a + 6] = c, l[a + 7] = h, l[a + 8] = u
                            }
                        Ge.bufferData(Ge.ARRAY_BUFFER, e.normalArray, Ge.DYNAMIC_DRAW), qe.enableAttribute(o.normal), Ge.vertexAttribPointer(o.normal, 3, Ge.FLOAT, !1, 0, 0)
                    }
                    e.hasUvs && i.map && (Ge.bindBuffer(Ge.ARRAY_BUFFER, n.uv), Ge.bufferData(Ge.ARRAY_BUFFER, e.uvArray, Ge.DYNAMIC_DRAW), qe.enableAttribute(o.uv), Ge.vertexAttribPointer(o.uv, 2, Ge.FLOAT, !1, 0, 0)), e.hasColors && i.vertexColors !== r.NoColors && (Ge.bindBuffer(Ge.ARRAY_BUFFER, n.color), Ge.bufferData(Ge.ARRAY_BUFFER, e.colorArray, Ge.DYNAMIC_DRAW), qe.enableAttribute(o.color), Ge.vertexAttribPointer(o.color, 3, Ge.FLOAT, !1, 0, 0)), qe.disableUnusedAttributes(), Ge.drawArrays(Ge.TRIANGLES, 0, e.count), e.count = 0
                }, this.renderBufferDirect = function(e, i, n, o, a, s) {
                    w(o);
                    var l = M(e, i, o, a),
                        c = !1,
                        h = n.id + "_" + l.id + "_" + o.wireframe;
                    h !== we && (we = h, c = !0);
                    var u = a.morphTargetInfluences;
                    if (void 0 !== u) {
                        for (var p = [], f = 0, g = u.length; g > f; f++) {
                            var v = u[f];
                            p.push([v, f])
                        }
                        p.sort(m), p.length > 8 && (p.length = 8);
                        for (var y = n.morphAttributes, f = 0, g = p.length; g > f; f++) {
                            var v = p[f];
                            if (de[f] = v[0], 0 !== v[0]) {
                                var _ = v[1];
                                o.morphTargets === !0 && y.position && n.addAttribute("morphTarget" + f, y.position[_]), o.morphNormals === !0 && y.normal && n.addAttribute("morphNormal" + f, y.normal[_])
                            } else o.morphTargets === !0 && n.removeAttribute("morphTarget" + f), o.morphNormals === !0 && n.removeAttribute("morphNormal" + f)
                        }
                        var x = l.getUniforms();
                        null !== x.morphTargetInfluences && Ge.uniform1fv(x.morphTargetInfluences, de), c = !0
                    }
                    var _ = n.index,
                        b = n.attributes.position;
                    o.wireframe === !0 && (_ = Ze.getWireframeAttribute(n));
                    var T;
                    null !== _ ? (T = Je, T.setIndex(_)) : T = $e, c && (d(o, l, n), null !== _ && Ge.bindBuffer(Ge.ELEMENT_ARRAY_BUFFER, Ze.getAttributeBuffer(_)));
                    var S = 0,
                        E = 1 / 0;
                    null !== _ ? E = _.count : void 0 !== b && (E = b.count);
                    var A = n.drawRange.start,
                        C = n.drawRange.count,
                        L = null !== s ? s.start : 0,
                        P = null !== s ? s.count : 1 / 0,
                        R = Math.max(S, A, L),
                        D = Math.min(S + E, A + C, L + P) - 1,
                        O = Math.max(0, D - R + 1);
                    if (a instanceof r.Mesh)
                        if (o.wireframe === !0) qe.setLineWidth(o.wireframeLinewidth * t()), T.setMode(Ge.LINES);
                        else switch (a.drawMode) {
                            case r.TrianglesDrawMode:
                                T.setMode(Ge.TRIANGLES);
                                break;
                            case r.TriangleStripDrawMode:
                                T.setMode(Ge.TRIANGLE_STRIP);
                                break;
                            case r.TriangleFanDrawMode:
                                T.setMode(Ge.TRIANGLE_FAN)
                        } else if (a instanceof r.Line) {
                            var I = o.linewidth;
                            void 0 === I && (I = 1), qe.setLineWidth(I * t()), a instanceof r.LineSegments ? T.setMode(Ge.LINES) : T.setMode(Ge.LINE_STRIP)
                        } else a instanceof r.Points && T.setMode(Ge.POINTS);
                    n instanceof r.InstancedBufferGeometry ? n.maxInstancedCount > 0 && T.renderInstances(n, R, O) : T.render(R, O)
                }, this.render = function(e, t, i, n) {
                    if (t instanceof r.Camera == !1) return void console.error("THREE.WebGLRenderer.render: camera is not an instance of THREE.Camera.");
                    var o = e.fog;
                    if (we = "", be = -1, Te = null, e.autoUpdate === !0 && e.updateMatrixWorld(), null === t.parent && t.updateMatrixWorld(), t.matrixWorldInverse.getInverse(t.matrixWorld), Be.multiplyMatrices(t.projectionMatrix, t.matrixWorldInverse), Ne.setFromMatrix(Be), ce.length = 0, ue = -1, fe = -1, me.length = 0, ge.length = 0, _(e, t), he.length = ue + 1, pe.length = fe + 1, ve.sortObjects === !0 && (he.sort(g), pe.sort(v)), U(ce, t), et.render(e, t), ze.calls = 0, ze.vertices = 0, ze.faces = 0, ze.points = 0, void 0 === i && (i = null), this.setRenderTarget(i), (this.autoClear || n) && this.clear(this.autoClearColor, this.autoClearDepth, this.autoClearStencil), e.overrideMaterial) {
                        var a = e.overrideMaterial;
                        x(he, t, o, a), x(pe, t, o, a)
                    } else qe.setBlending(r.NoBlending), x(he, t, o), x(pe, t, o);
                    if (tt.render(e, t), it.render(e, t, Ee), i) {
                        var s = i.texture;
                        s.generateMipmaps && H(i) && s.minFilter !== r.NearestFilter && s.minFilter !== r.LinearFilter && $(i)
                    }
                    qe.setDepthTest(!0), qe.setDepthWrite(!0), qe.setColorWrite(!0)
                }, this.setFaceCulling = function(e, t) {
                    e === r.CullFaceNone ? qe.disable(Ge.CULL_FACE) : (t === r.FrontFaceDirectionCW ? Ge.frontFace(Ge.CW) : Ge.frontFace(Ge.CCW), e === r.CullFaceBack ? Ge.cullFace(Ge.BACK) : e === r.CullFaceFront ? Ge.cullFace(Ge.FRONT) : Ge.cullFace(Ge.FRONT_AND_BACK), qe.enable(Ge.CULL_FACE))
                }, this.setTexture = function(e, t) {
                    var i = Ye.get(e);
                    if (e.version > 0 && i.__version !== e.version) {
                        var r = e.image;
                        return void 0 === r ? void console.warn("THREE.WebGLRenderer: Texture marked for update but image is undefined", e) : r.complete === !1 ? void console.warn("THREE.WebGLRenderer: Texture marked for update but image is incomplete", e) : void z(i, e, t)
                    }
                    qe.activeTexture(Ge.TEXTURE0 + t), qe.bindTexture(Ge.TEXTURE_2D, i.__webglTexture)
                }, this.getCurrentRenderTarget = function() {
                    return _e
                }, this.setRenderTarget = function(e) {
                    _e = e, e && void 0 === Ye.get(e).__webglFramebuffer && K(e);
                    var t, i = e instanceof r.WebGLRenderTargetCube;
                    if (e) {
                        var n = Ye.get(e);
                        t = i ? n.__webglFramebuffer[e.activeCubeFace] : n.__webglFramebuffer, Me.copy(e.scissor), Se = e.scissorTest, Ee.copy(e.viewport)
                    } else t = null, Me.copy(Oe).multiplyScalar(De), Se = Ie, Ee.copy(Fe).multiplyScalar(De);
                    if (xe !== t && (Ge.bindFramebuffer(Ge.FRAMEBUFFER, t), xe = t), qe.scissor(Me), qe.setScissorTest(Se), qe.viewport(Ee), i) {
                        var o = Ye.get(e.texture);
                        Ge.framebufferTexture2D(Ge.FRAMEBUFFER, Ge.COLOR_ATTACHMENT0, Ge.TEXTURE_CUBE_MAP_POSITIVE_X + e.activeCubeFace, o.__webglTexture, e.activeMipMapLevel)
                    }
                }, this.readRenderTargetPixels = function(e, t, i, n, o, a) {
                    if (e instanceof r.WebGLRenderTarget == !1) return void console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not THREE.WebGLRenderTarget.");
                    var s = Ye.get(e).__webglFramebuffer;
                    if (s) {
                        var l = !1;
                        s !== xe && (Ge.bindFramebuffer(Ge.FRAMEBUFFER, s), l = !0);
                        try {
                            var c = e.texture;
                            if (c.format !== r.RGBAFormat && ee(c.format) !== Ge.getParameter(Ge.IMPLEMENTATION_COLOR_READ_FORMAT)) return void console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in RGBA or implementation defined format.");
                            if (!(c.type === r.UnsignedByteType || ee(c.type) === Ge.getParameter(Ge.IMPLEMENTATION_COLOR_READ_TYPE) || c.type === r.FloatType && We.get("WEBGL_color_buffer_float") || c.type === r.HalfFloatType && We.get("EXT_color_buffer_half_float"))) return void console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in UnsignedByteType or implementation defined type.");
                            Ge.checkFramebufferStatus(Ge.FRAMEBUFFER) === Ge.FRAMEBUFFER_COMPLETE ? Ge.readPixels(t, i, n, o, ee(c.format), ee(c.type), a) : console.error("THREE.WebGLRenderer.readRenderTargetPixels: readPixels from renderTarget failed. Framebuffer not complete.")
                        } finally {
                            l && Ge.bindFramebuffer(Ge.FRAMEBUFFER, xe)
                        }
                    }
                }
            }, r.WebGLRenderTarget = function(e, t, i) {
                this.uuid = r.Math.generateUUID(), this.width = e, this.height = t, this.scissor = new r.Vector4(0, 0, e, t), this.scissorTest = !1, this.viewport = new r.Vector4(0, 0, e, t), i = i || {}, void 0 === i.minFilter && (i.minFilter = r.LinearFilter), this.texture = new r.Texture(void 0, void 0, i.wrapS, i.wrapT, i.magFilter, i.minFilter, i.format, i.type, i.anisotropy), this.depthBuffer = void 0 !== i.depthBuffer ? i.depthBuffer : !0, this.stencilBuffer = void 0 !== i.stencilBuffer ? i.stencilBuffer : !0
            }, r.WebGLRenderTarget.prototype = {
                constructor: r.WebGLRenderTarget,
                setSize: function(e, t) {
                    this.width === e && this.height === t || (this.width = e, this.height = t, this.dispose()), this.viewport.set(0, 0, e, t), this.scissor.set(0, 0, e, t)
                },
                clone: function() {
                    return (new this.constructor).copy(this)
                },
                copy: function(e) {
                    return this.width = e.width, this.height = e.height, this.viewport.copy(e.viewport), this.texture = e.texture.clone(), this.depthBuffer = e.depthBuffer, this.stencilBuffer = e.stencilBuffer, this
                },
                dispose: function() {
                    this.dispatchEvent({
                        type: "dispose"
                    })
                }
            }, r.EventDispatcher.prototype.apply(r.WebGLRenderTarget.prototype), r.WebGLRenderTargetCube = function(e, t, i) {
                r.WebGLRenderTarget.call(this, e, t, i), this.activeCubeFace = 0, this.activeMipMapLevel = 0
            }, r.WebGLRenderTargetCube.prototype = Object.create(r.WebGLRenderTarget.prototype), r.WebGLRenderTargetCube.prototype.constructor = r.WebGLRenderTargetCube, r.WebGLBufferRenderer = function(e, t, i) {
                function n(e) {
                    s = e
                }

                function o(t, r) {
                    e.drawArrays(s, t, r), i.calls++, i.vertices += r, s === e.TRIANGLES && (i.faces += r / 3)
                }

                function a(n) {
                    var o = t.get("ANGLE_instanced_arrays");
                    if (null === o) return void console.error("THREE.WebGLBufferRenderer: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays.");
                    var a = n.attributes.position,
                        l = 0;
                    a instanceof r.InterleavedBufferAttribute ? (l = a.data.count, o.drawArraysInstancedANGLE(s, 0, l, n.maxInstancedCount)) : (l = a.count, o.drawArraysInstancedANGLE(s, 0, l, n.maxInstancedCount)), i.calls++, i.vertices += l * n.maxInstancedCount, s === e.TRIANGLES && (i.faces += n.maxInstancedCount * l / 3)
                }
                var s;
                this.setMode = n, this.render = o, this.renderInstances = a
            }, r.WebGLIndexedBufferRenderer = function(e, t, i) {
                function r(e) {
                    s = e
                }

                function n(i) {
                    i.array instanceof Uint32Array && t.get("OES_element_index_uint") ? (l = e.UNSIGNED_INT, c = 4) : (l = e.UNSIGNED_SHORT, c = 2)
                }

                function o(t, r) {
                    e.drawElements(s, r, l, t * c), i.calls++, i.vertices += r, s === e.TRIANGLES && (i.faces += r / 3)
                }

                function a(r, n, o) {
                    var a = t.get("ANGLE_instanced_arrays");
                    return null === a ? void console.error("THREE.WebGLBufferRenderer: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays.") : (a.drawElementsInstancedANGLE(s, o, l, n * c, r.maxInstancedCount), i.calls++, i.vertices += o * r.maxInstancedCount, void(s === e.TRIANGLES && (i.faces += r.maxInstancedCount * o / 3)))
                }
                var s, l, c;
                this.setMode = r, this.setIndex = n, this.render = o, this.renderInstances = a
            }, r.WebGLExtensions = function(e) {
                var t = {};
                this.get = function(i) {
                    if (void 0 !== t[i]) return t[i];
                    var r;
                    switch (i) {
                        case "EXT_texture_filter_anisotropic":
                            r = e.getExtension("EXT_texture_filter_anisotropic") || e.getExtension("MOZ_EXT_texture_filter_anisotropic") || e.getExtension("WEBKIT_EXT_texture_filter_anisotropic");
                            break;
                        case "WEBGL_compressed_texture_s3tc":
                            r = e.getExtension("WEBGL_compressed_texture_s3tc") || e.getExtension("MOZ_WEBGL_compressed_texture_s3tc") || e.getExtension("WEBKIT_WEBGL_compressed_texture_s3tc");
                            break;
                        case "WEBGL_compressed_texture_pvrtc":
                            r = e.getExtension("WEBGL_compressed_texture_pvrtc") || e.getExtension("WEBKIT_WEBGL_compressed_texture_pvrtc");
                            break;
                        case "WEBGL_compressed_texture_etc1":
                            r = e.getExtension("WEBGL_compressed_texture_etc1");
                            break;
                        default:
                            r = e.getExtension(i)
                    }
                    return null === r && console.warn("THREE.WebGLRenderer: " + i + " extension not supported."), t[i] = r, r
                }
            }, r.WebGLCapabilities = function(e, t, i) {
                function r(t) {
                    if ("highp" === t) {
                        if (e.getShaderPrecisionFormat(e.VERTEX_SHADER, e.HIGH_FLOAT).precision > 0 && e.getShaderPrecisionFormat(e.FRAGMENT_SHADER, e.HIGH_FLOAT).precision > 0) return "highp";
                        t = "mediump"
                    }
                    return "mediump" === t && e.getShaderPrecisionFormat(e.VERTEX_SHADER, e.MEDIUM_FLOAT).precision > 0 && e.getShaderPrecisionFormat(e.FRAGMENT_SHADER, e.MEDIUM_FLOAT).precision > 0 ? "mediump" : "lowp"
                }
                this.getMaxPrecision = r, this.precision = void 0 !== i.precision ? i.precision : "highp", this.logarithmicDepthBuffer = void 0 !== i.logarithmicDepthBuffer ? i.logarithmicDepthBuffer : !1, this.maxTextures = e.getParameter(e.MAX_TEXTURE_IMAGE_UNITS), this.maxVertexTextures = e.getParameter(e.MAX_VERTEX_TEXTURE_IMAGE_UNITS), this.maxTextureSize = e.getParameter(e.MAX_TEXTURE_SIZE), this.maxCubemapSize = e.getParameter(e.MAX_CUBE_MAP_TEXTURE_SIZE), this.maxAttributes = e.getParameter(e.MAX_VERTEX_ATTRIBS), this.maxVertexUniforms = e.getParameter(e.MAX_VERTEX_UNIFORM_VECTORS), this.maxVaryings = e.getParameter(e.MAX_VARYING_VECTORS), this.maxFragmentUniforms = e.getParameter(e.MAX_FRAGMENT_UNIFORM_VECTORS), this.vertexTextures = this.maxVertexTextures > 0, this.floatFragmentTextures = !!t.get("OES_texture_float"), this.floatVertexTextures = this.vertexTextures && this.floatFragmentTextures;
                var n = r(this.precision);
                n !== this.precision && (console.warn("THREE.WebGLRenderer:", this.precision, "not supported, using", n, "instead."), this.precision = n), this.logarithmicDepthBuffer && (this.logarithmicDepthBuffer = !!t.get("EXT_frag_depth"))
            }, r.WebGLGeometries = function(e, t, i) {
                function n(e) {
                    var t = e.geometry;
                    if (void 0 !== h[t.id]) return h[t.id];
                    t.addEventListener("dispose", o);
                    var n;
                    return t instanceof r.BufferGeometry ? n = t : t instanceof r.Geometry && (void 0 === t._bufferGeometry && (t._bufferGeometry = (new r.BufferGeometry).setFromObject(e)), n = t._bufferGeometry), h[t.id] = n, i.memory.geometries++, n
                }

                function o(e) {
                    var r = e.target,
                        n = h[r.id];
                    null !== n.index && s(n.index), l(n.attributes), r.removeEventListener("dispose", o), delete h[r.id];
                    var a = t.get(r);
                    a.wireframe && s(a.wireframe), t["delete"](r);
                    var c = t.get(n);
                    c.wireframe && s(c.wireframe), t["delete"](n), i.memory.geometries--
                }

                function a(e) {
                    return e instanceof r.InterleavedBufferAttribute ? t.get(e.data).__webglBuffer : t.get(e).__webglBuffer
                }

                function s(t) {
                    var i = a(t);
                    void 0 !== i && (e.deleteBuffer(i), c(t))
                }

                function l(e) {
                    for (var t in e) s(e[t])
                }

                function c(e) {
                    e instanceof r.InterleavedBufferAttribute ? t["delete"](e.data) : t["delete"](e)
                }
                var h = {};
                this.get = n
            }, r.WebGLLights = function() {
                var e = {};
                this.get = function(t) {
                    if (void 0 !== e[t.id]) return e[t.id];
                    var i;
                    switch (t.type) {
                        case "DirectionalLight":
                            i = {
                                direction: new r.Vector3,
                                color: new r.Color,
                                shadow: !1,
                                shadowBias: 0,
                                shadowRadius: 1,
                                shadowMapSize: new r.Vector2
                            };
                            break;
                        case "SpotLight":
                            i = {
                                position: new r.Vector3,
                                direction: new r.Vector3,
                                color: new r.Color,
                                distance: 0,
                                coneCos: 0,
                                penumbraCos: 0,
                                decay: 0,
                                shadow: !1,
                                shadowBias: 0,
                                shadowRadius: 1,
                                shadowMapSize: new r.Vector2
                            };
                            break;
                        case "PointLight":
                            i = {
                                position: new r.Vector3,
                                color: new r.Color,
                                distance: 0,
                                decay: 0,
                                shadow: !1,
                                shadowBias: 0,
                                shadowRadius: 1,
                                shadowMapSize: new r.Vector2
                            };
                            break;
                        case "HemisphereLight":
                            i = {
                                direction: new r.Vector3,
                                skyColor: new r.Color,
                                groundColor: new r.Color
                            }
                    }
                    return e[t.id] = i, i
                }
            }, r.WebGLObjects = function(e, t, i) {
                function n(t) {
                    var i = u.get(t);
                    t.geometry instanceof r.Geometry && i.updateFromObject(t);
                    var n = i.index,
                        a = i.attributes;
                    null !== n && o(n, e.ELEMENT_ARRAY_BUFFER);
                    for (var s in a) o(a[s], e.ARRAY_BUFFER);
                    var l = i.morphAttributes;
                    for (var s in l)
                        for (var c = l[s], h = 0, p = c.length; p > h; h++) o(c[h], e.ARRAY_BUFFER);
                    return i
                }

                function o(e, i) {
                    var n = e instanceof r.InterleavedBufferAttribute ? e.data : e,
                        o = t.get(n);
                    void 0 === o.__webglBuffer ? a(o, n, i) : o.version !== n.version && s(o, n, i)
                }

                function a(t, i, r) {
                    t.__webglBuffer = e.createBuffer(), e.bindBuffer(r, t.__webglBuffer);
                    var n = i.dynamic ? e.DYNAMIC_DRAW : e.STATIC_DRAW;
                    e.bufferData(r, i.array, n), t.version = i.version
                }

                function s(t, i, r) {
                    e.bindBuffer(r, t.__webglBuffer), i.dynamic === !1 || -1 === i.updateRange.count ? e.bufferSubData(r, 0, i.array) : 0 === i.updateRange.count ? console.error("THREE.WebGLObjects.updateBuffer: dynamic THREE.BufferAttribute marked as needsUpdate but updateRange.count is 0, ensure you are using set methods or updating manually.") : (e.bufferSubData(r, i.updateRange.offset * i.array.BYTES_PER_ELEMENT, i.array.subarray(i.updateRange.offset, i.updateRange.offset + i.updateRange.count)), i.updateRange.count = 0), t.version = i.version
                }

                function l(e) {
                    return e instanceof r.InterleavedBufferAttribute ? t.get(e.data).__webglBuffer : t.get(e).__webglBuffer
                }

                function c(i) {
                    var n = t.get(i);
                    if (void 0 !== n.wireframe) return n.wireframe;
                    var a = [],
                        s = i.index,
                        l = i.attributes,
                        c = l.position;
                    if (null !== s)
                        for (var u = {}, p = s.array, f = 0, d = p.length; d > f; f += 3) {
                            var m = p[f + 0],
                                g = p[f + 1],
                                v = p[f + 2];
                            h(u, m, g) && a.push(m, g), h(u, g, v) && a.push(g, v), h(u, v, m) && a.push(v, m)
                        } else
                            for (var p = l.position.array, f = 0, d = p.length / 3 - 1; d > f; f += 3) {
                                var m = f + 0,
                                    g = f + 1,
                                    v = f + 2;
                                a.push(m, g, g, v, v, m)
                            }
                    var y = c.count > 65535 ? Uint32Array : Uint16Array,
                        _ = new r.BufferAttribute(new y(a), 1);
                    return o(_, e.ELEMENT_ARRAY_BUFFER), n.wireframe = _, _
                }

                function h(e, t, i) {
                    if (t > i) {
                        var r = t;
                        t = i, i = r
                    }
                    var n = e[t];
                    return void 0 === n ? (e[t] = [i], !0) : -1 === n.indexOf(i) ? (n.push(i), !0) : !1
                }
                var u = new r.WebGLGeometries(e, t, i);
                this.getAttributeBuffer = l, this.getWireframeAttribute = c, this.update = n
            }, r.WebGLProgram = function() {
                function e(e) {
                    switch (e) {
                        case r.LinearEncoding:
                            return ["Linear", "( value )"];
                        case r.sRGBEncoding:
                            return ["sRGB", "( value )"];
                        case r.RGBEEncoding:
                            return ["RGBE", "( value )"];
                        case r.RGBM7Encoding:
                            return ["RGBM", "( value, 7.0 )"];
                        case r.RGBM16Encoding:
                            return ["RGBM", "( value, 16.0 )"];
                        case r.RGBDEncoding:
                            return ["RGBD", "( value, 256.0 )"];
                        case r.GammaEncoding:
                            return ["Gamma", "( value, float( GAMMA_FACTOR ) )"];
                        default:
                            throw new Error("unsupported encoding: " + e)
                    }
                }

                function t(t, i) {
                    var r = e(i);
                    return "vec4 " + t + "( vec4 value ) { return " + r[0] + "ToLinear" + r[1] + "; }"
                }

                function i(t, i) {
                    var r = e(i);
                    return "vec4 " + t + "( vec4 value ) { return LinearTo" + r[0] + r[1] + "; }"
                }

                function n(e, t) {
                    var i;
                    switch (t) {
                        case r.LinearToneMapping:
                            i = "Linear";
                            break;
                        case r.ReinhardToneMapping:
                            i = "Reinhard";
                            break;
                        case r.Uncharted2ToneMapping:
                            i = "Uncharted2";
                            break;
                        case r.CineonToneMapping:
                            i = "OptimizedCineon";
                            break;
                        default:
                            throw new Error("unsupported toneMapping: " + t)
                    }
                    return "vec3 " + e + "( vec3 color ) { return " + i + "ToneMapping( color ); }"
                }

                function o(e, t, i) {
                    e = e || {};
                    var r = [e.derivatives || t.envMapCubeUV || t.bumpMap || t.normalMap || t.flatShading ? "#extension GL_OES_standard_derivatives : enable" : "", (e.fragDepth || t.logarithmicDepthBuffer) && i.get("EXT_frag_depth") ? "#extension GL_EXT_frag_depth : enable" : "", e.drawBuffers && i.get("WEBGL_draw_buffers") ? "#extension GL_EXT_draw_buffers : require" : "", (e.shaderTextureLOD || t.envMap) && i.get("EXT_shader_texture_lod") ? "#extension GL_EXT_shader_texture_lod : enable" : ""];
                    return r.filter(c).join("\n")
                }

                function a(e) {
                    var t = [];
                    for (var i in e) {
                        var r = e[i];
                        r !== !1 && t.push("#define " + i + " " + r)
                    }
                    return t.join("\n")
                }

                function s(e, t, i) {
                    for (var r = {}, n = e.getProgramParameter(t, e.ACTIVE_UNIFORMS), o = 0; n > o; o++) {
                        var a = e.getActiveUniform(t, o),
                            s = a.name,
                            l = e.getUniformLocation(t, s),
                            c = d.exec(s);
                        if (c) {
                            var h = c[1],
                                u = c[2],
                                p = r[h];
                            p || (p = r[h] = {}), p[u] = l
                        } else if (c = m.exec(s)) {
                            var f = c[1],
                                v = c[2],
                                y = c[3],
                                _ = r[f];
                            _ || (_ = r[f] = []);
                            var x = _[v];
                            x || (x = _[v] = {}), x[y] = l
                        } else if (c = g.exec(s)) {
                            var f = c[1];
                            r[f] = l
                        } else r[s] = l
                    }
                    return r
                }

                function l(e, t, i) {
                    for (var r = {}, n = e.getProgramParameter(t, e.ACTIVE_ATTRIBUTES), o = 0; n > o; o++) {
                        var a = e.getActiveAttrib(t, o),
                            s = a.name;
                        r[s] = e.getAttribLocation(t, s)
                    }
                    return r
                }

                function c(e) {
                    return "" !== e
                }

                function h(e, t) {
                    return e.replace(/NUM_DIR_LIGHTS/g, t.numDirLights).replace(/NUM_SPOT_LIGHTS/g, t.numSpotLights).replace(/NUM_POINT_LIGHTS/g, t.numPointLights).replace(/NUM_HEMI_LIGHTS/g, t.numHemiLights)
                }

                function u(e) {
                    function t(e, t) {
                        var i = r.ShaderChunk[t];
                        if (void 0 === i) throw new Error("Can not resolve #include <" + t + ">");
                        return u(i)
                    }
                    var i = /#include +<([\w\d.]+)>/g;
                    return e.replace(i, t)
                }

                function p(e) {
                    function t(e, t, i, r) {
                        for (var n = "", o = parseInt(t); o < parseInt(i); o++) n += r.replace(/\[ i \]/g, "[ " + o + " ]");
                        return n
                    }
                    var i = /for \( int i \= (\d+)\; i < (\d+)\; i \+\+ \) \{([\s\S]+?)(?=\})\}/g;
                    return e.replace(i, t)
                }
                var f = 0,
                    d = /^([\w\d_]+)\.([\w\d_]+)$/,
                    m = /^([\w\d_]+)\[(\d+)\]\.([\w\d_]+)$/,
                    g = /^([\w\d_]+)\[0\]$/;
                return function(e, d, m, g) {
                    var v = e.context,
                        y = m.extensions,
                        _ = m.defines,
                        x = m.__webglShader.vertexShader,
                        b = m.__webglShader.fragmentShader,
                        w = "SHADOWMAP_TYPE_BASIC";
                    g.shadowMapType === r.PCFShadowMap ? w = "SHADOWMAP_TYPE_PCF" : g.shadowMapType === r.PCFSoftShadowMap && (w = "SHADOWMAP_TYPE_PCF_SOFT");
                    var T = "ENVMAP_TYPE_CUBE",
                        M = "ENVMAP_MODE_REFLECTION",
                        S = "ENVMAP_BLENDING_MULTIPLY";
                    if (g.envMap) {
                        switch (m.envMap.mapping) {
                            case r.CubeReflectionMapping:
                            case r.CubeRefractionMapping:
                                T = "ENVMAP_TYPE_CUBE";
                                break;
                            case r.CubeUVReflectionMapping:
                            case r.CubeUVRefractionMapping:
                                T = "ENVMAP_TYPE_CUBE_UV";
                                break;
                            case r.EquirectangularReflectionMapping:
                            case r.EquirectangularRefractionMapping:
                                T = "ENVMAP_TYPE_EQUIREC";
                                break;
                            case r.SphericalReflectionMapping:
                                T = "ENVMAP_TYPE_SPHERE"
                        }
                        switch (m.envMap.mapping) {
                            case r.CubeRefractionMapping:
                            case r.EquirectangularRefractionMapping:
                                M = "ENVMAP_MODE_REFRACTION"
                        }
                        switch (m.combine) {
                            case r.MultiplyOperation:
                                S = "ENVMAP_BLENDING_MULTIPLY";
                                break;
                            case r.MixOperation:
                                S = "ENVMAP_BLENDING_MIX";
                                break;
                            case r.AddOperation:
                                S = "ENVMAP_BLENDING_ADD"
                        }
                    }
                    var E, A, C = e.gammaFactor > 0 ? e.gammaFactor : 1,
                        L = o(y, g, e.extensions),
                        P = a(_),
                        R = v.createProgram();
                    m instanceof r.RawShaderMaterial ? (E = "", A = "") : (E = ["precision " + g.precision + " float;", "precision " + g.precision + " int;", "#define SHADER_NAME " + m.__webglShader.name, P, g.supportsVertexTextures ? "#define VERTEX_TEXTURES" : "", "#define GAMMA_FACTOR " + C, "#define MAX_BONES " + g.maxBones, g.map ? "#define USE_MAP" : "", g.envMap ? "#define USE_ENVMAP" : "", g.envMap ? "#define " + M : "", g.lightMap ? "#define USE_LIGHTMAP" : "", g.aoMap ? "#define USE_AOMAP" : "", g.emissiveMap ? "#define USE_EMISSIVEMAP" : "", g.bumpMap ? "#define USE_BUMPMAP" : "", g.normalMap ? "#define USE_NORMALMAP" : "", g.displacementMap && g.supportsVertexTextures ? "#define USE_DISPLACEMENTMAP" : "", g.specularMap ? "#define USE_SPECULARMAP" : "", g.roughnessMap ? "#define USE_ROUGHNESSMAP" : "", g.metalnessMap ? "#define USE_METALNESSMAP" : "", g.alphaMap ? "#define USE_ALPHAMAP" : "", g.vertexColors ? "#define USE_COLOR" : "", g.flatShading ? "#define FLAT_SHADED" : "", g.skinning ? "#define USE_SKINNING" : "", g.useVertexTexture ? "#define BONE_TEXTURE" : "", g.morphTargets ? "#define USE_MORPHTARGETS" : "", g.morphNormals && g.flatShading === !1 ? "#define USE_MORPHNORMALS" : "", g.doubleSided ? "#define DOUBLE_SIDED" : "", g.flipSided ? "#define FLIP_SIDED" : "", g.shadowMapEnabled ? "#define USE_SHADOWMAP" : "", g.shadowMapEnabled ? "#define " + w : "", g.pointLightShadows > 0 ? "#define POINT_LIGHT_SHADOWS" : "", g.sizeAttenuation ? "#define USE_SIZEATTENUATION" : "", g.logarithmicDepthBuffer ? "#define USE_LOGDEPTHBUF" : "", g.logarithmicDepthBuffer && e.extensions.get("EXT_frag_depth") ? "#define USE_LOGDEPTHBUF_EXT" : "", "uniform mat4 modelMatrix;", "uniform mat4 modelViewMatrix;", "uniform mat4 projectionMatrix;", "uniform mat4 viewMatrix;", "uniform mat3 normalMatrix;", "uniform vec3 cameraPosition;", "attribute vec3 position;", "attribute vec3 normal;", "attribute vec2 uv;", "#ifdef USE_COLOR", "	attribute vec3 color;", "#endif", "#ifdef USE_MORPHTARGETS", "	attribute vec3 morphTarget0;", "	attribute vec3 morphTarget1;", "	attribute vec3 morphTarget2;", "	attribute vec3 morphTarget3;", "	#ifdef USE_MORPHNORMALS", "		attribute vec3 morphNormal0;", "		attribute vec3 morphNormal1;", "		attribute vec3 morphNormal2;", "		attribute vec3 morphNormal3;", "	#else", "		attribute vec3 morphTarget4;", "		attribute vec3 morphTarget5;", "		attribute vec3 morphTarget6;", "		attribute vec3 morphTarget7;", "	#endif", "#endif", "#ifdef USE_SKINNING", "	attribute vec4 skinIndex;", "	attribute vec4 skinWeight;", "#endif", "\n"].filter(c).join("\n"), A = [L, "precision " + g.precision + " float;", "precision " + g.precision + " int;", "#define SHADER_NAME " + m.__webglShader.name, P, g.alphaTest ? "#define ALPHATEST " + g.alphaTest : "", "#define GAMMA_FACTOR " + C, g.useFog && g.fog ? "#define USE_FOG" : "", g.useFog && g.fogExp ? "#define FOG_EXP2" : "", g.map ? "#define USE_MAP" : "", g.envMap ? "#define USE_ENVMAP" : "", g.envMap ? "#define " + T : "", g.envMap ? "#define " + M : "", g.envMap ? "#define " + S : "", g.lightMap ? "#define USE_LIGHTMAP" : "", g.aoMap ? "#define USE_AOMAP" : "", g.emissiveMap ? "#define USE_EMISSIVEMAP" : "", g.bumpMap ? "#define USE_BUMPMAP" : "", g.normalMap ? "#define USE_NORMALMAP" : "", g.specularMap ? "#define USE_SPECULARMAP" : "", g.roughnessMap ? "#define USE_ROUGHNESSMAP" : "", g.metalnessMap ? "#define USE_METALNESSMAP" : "", g.alphaMap ? "#define USE_ALPHAMAP" : "", g.vertexColors ? "#define USE_COLOR" : "", g.flatShading ? "#define FLAT_SHADED" : "", g.doubleSided ? "#define DOUBLE_SIDED" : "", g.flipSided ? "#define FLIP_SIDED" : "", g.shadowMapEnabled ? "#define USE_SHADOWMAP" : "", g.shadowMapEnabled ? "#define " + w : "", g.pointLightShadows > 0 ? "#define POINT_LIGHT_SHADOWS" : "", g.premultipliedAlpha ? "#define PREMULTIPLIED_ALPHA" : "", g.physicallyCorrectLights ? "#define PHYSICALLY_CORRECT_LIGHTS" : "", g.logarithmicDepthBuffer ? "#define USE_LOGDEPTHBUF" : "", g.logarithmicDepthBuffer && e.extensions.get("EXT_frag_depth") ? "#define USE_LOGDEPTHBUF_EXT" : "", g.envMap && e.extensions.get("EXT_shader_texture_lod") ? "#define TEXTURE_LOD_EXT" : "", "uniform mat4 viewMatrix;", "uniform vec3 cameraPosition;", g.toneMapping !== r.NoToneMapping ? "#define TONE_MAPPING" : "", g.toneMapping !== r.NoToneMapping ? r.ShaderChunk.tonemapping_pars_fragment : "", g.toneMapping !== r.NoToneMapping ? n("toneMapping", g.toneMapping) : "", g.outputEncoding || g.mapEncoding || g.envMapEncoding || g.emissiveMapEncoding ? r.ShaderChunk.encodings_pars_fragment : "", g.mapEncoding ? t("mapTexelToLinear", g.mapEncoding) : "", g.envMapEncoding ? t("envMapTexelToLinear", g.envMapEncoding) : "", g.emissiveMapEncoding ? t("emissiveMapTexelToLinear", g.emissiveMapEncoding) : "", g.outputEncoding ? i("linearToOutputTexel", g.outputEncoding) : "", "\n"].filter(c).join("\n")),
                        x = u(x, g), x = h(x, g), b = u(b, g), b = h(b, g), m instanceof r.ShaderMaterial == !1 && (x = p(x), b = p(b));
                    var D = E + x,
                        O = A + b,
                        I = r.WebGLShader(v, v.VERTEX_SHADER, D),
                        F = r.WebGLShader(v, v.FRAGMENT_SHADER, O);
                    v.attachShader(R, I), v.attachShader(R, F), void 0 !== m.index0AttributeName ? v.bindAttribLocation(R, 0, m.index0AttributeName) : g.morphTargets === !0 && v.bindAttribLocation(R, 0, "position"), v.linkProgram(R);
                    var N = v.getProgramInfoLog(R),
                        B = v.getShaderInfoLog(I),
                        k = v.getShaderInfoLog(F),
                        U = !0,
                        V = !0;
                    v.getProgramParameter(R, v.LINK_STATUS) === !1 ? (U = !1, console.error("THREE.WebGLProgram: shader error: ", v.getError(), "gl.VALIDATE_STATUS", v.getProgramParameter(R, v.VALIDATE_STATUS), "gl.getProgramInfoLog", N, B, k)) : "" !== N ? console.warn("THREE.WebGLProgram: gl.getProgramInfoLog()", N) : "" !== B && "" !== k || (V = !1), V && (this.diagnostics = {
                        runnable: U,
                        material: m,
                        programLog: N,
                        vertexShader: {
                            log: B,
                            prefix: E
                        },
                        fragmentShader: {
                            log: k,
                            prefix: A
                        }
                    }), v.deleteShader(I), v.deleteShader(F);
                    var z;
                    this.getUniforms = function() {
                        return void 0 === z && (z = s(v, R)), z
                    };
                    var G;
                    return this.getAttributes = function() {
                        return void 0 === G && (G = l(v, R)), G
                    }, this.destroy = function() {
                        v.deleteProgram(R), this.program = void 0
                    }, Object.defineProperties(this, {
                        uniforms: {
                            get: function() {
                                return console.warn("THREE.WebGLProgram: .uniforms is now .getUniforms()."), this.getUniforms()
                            }
                        },
                        attributes: {
                            get: function() {
                                return console.warn("THREE.WebGLProgram: .attributes is now .getAttributes()."), this.getAttributes()
                            }
                        }
                    }), this.id = f++, this.code = d, this.usedTimes = 1, this.program = R, this.vertexShader = I, this.fragmentShader = F, this
                }
            }(), r.WebGLPrograms = function(e, t) {
                function i(e) {
                    if (t.floatVertexTextures && e && e.skeleton && e.skeleton.useVertexTexture) return 1024;
                    var i = t.maxVertexUniforms,
                        n = Math.floor((i - 20) / 4),
                        o = n;
                    return void 0 !== e && e instanceof r.SkinnedMesh && (o = Math.min(e.skeleton.bones.length, o), o < e.skeleton.bones.length && console.warn("WebGLRenderer: too many bones - " + e.skeleton.bones.length + ", this GPU supports just " + o + " (try OpenGL instead of ANGLE)")), o
                }

                function n(e, t) {
                    var i;
                    return e ? e instanceof r.Texture ? i = e.encoding : e instanceof r.WebGLRenderTarget && (i = e.texture.encoding) : i = r.LinearEncoding, i === r.LinearEncoding && t && (i = r.GammaEncoding), i
                }
                var o = [],
                    a = {
                        MeshDepthMaterial: "depth",
                        MeshNormalMaterial: "normal",
                        MeshBasicMaterial: "basic",
                        MeshLambertMaterial: "lambert",
                        MeshPhongMaterial: "phong",
                        MeshStandardMaterial: "standard",
                        LineBasicMaterial: "basic",
                        LineDashedMaterial: "dashed",
                        PointsMaterial: "points"
                    },
                    s = ["precision", "supportsVertexTextures", "map", "mapEncoding", "envMap", "envMapMode", "envMapEncoding", "lightMap", "aoMap", "emissiveMap", "emissiveMapEncoding", "bumpMap", "normalMap", "displacementMap", "specularMap", "roughnessMap", "metalnessMap", "alphaMap", "combine", "vertexColors", "fog", "useFog", "fogExp", "flatShading", "sizeAttenuation", "logarithmicDepthBuffer", "skinning", "maxBones", "useVertexTexture", "morphTargets", "morphNormals", "maxMorphTargets", "maxMorphNormals", "premultipliedAlpha", "numDirLights", "numPointLights", "numSpotLights", "numHemiLights", "shadowMapEnabled", "pointLightShadows", "toneMapping", "physicallyCorrectLights", "shadowMapType", "alphaTest", "doubleSided", "flipSided"];
                this.getParameters = function(o, s, l, c) {
                    var h = a[o.type],
                        u = i(c),
                        p = e.getPrecision();
                    null !== o.precision && (p = t.getMaxPrecision(o.precision), p !== o.precision && console.warn("THREE.WebGLProgram.getParameters:", o.precision, "not supported, using", p, "instead."));
                    var f = {
                        shaderID: h,
                        precision: p,
                        supportsVertexTextures: t.vertexTextures,
                        outputEncoding: n(e.getCurrentRenderTarget(), e.gammaOutput),
                        map: !!o.map,
                        mapEncoding: n(o.map, e.gammaInput),
                        envMap: !!o.envMap,
                        envMapMode: o.envMap && o.envMap.mapping,
                        envMapEncoding: n(o.envMap, e.gammaInput),
                        envMapCubeUV: !!o.envMap && (o.envMap.mapping === r.CubeUVReflectionMapping || o.envMap.mapping === r.CubeUVRefractionMapping),
                        lightMap: !!o.lightMap,
                        aoMap: !!o.aoMap,
                        emissiveMap: !!o.emissiveMap,
                        emissiveMapEncoding: n(o.emissiveMap, e.gammaInput),
                        bumpMap: !!o.bumpMap,
                        normalMap: !!o.normalMap,
                        displacementMap: !!o.displacementMap,
                        roughnessMap: !!o.roughnessMap,
                        metalnessMap: !!o.metalnessMap,
                        specularMap: !!o.specularMap,
                        alphaMap: !!o.alphaMap,
                        combine: o.combine,
                        vertexColors: o.vertexColors,
                        fog: l,
                        useFog: o.fog,
                        fogExp: l instanceof r.FogExp2,
                        flatShading: o.shading === r.FlatShading,
                        sizeAttenuation: o.sizeAttenuation,
                        logarithmicDepthBuffer: t.logarithmicDepthBuffer,
                        skinning: o.skinning,
                        maxBones: u,
                        useVertexTexture: t.floatVertexTextures && c && c.skeleton && c.skeleton.useVertexTexture,
                        morphTargets: o.morphTargets,
                        morphNormals: o.morphNormals,
                        maxMorphTargets: e.maxMorphTargets,
                        maxMorphNormals: e.maxMorphNormals,
                        numDirLights: s.directional.length,
                        numPointLights: s.point.length,
                        numSpotLights: s.spot.length,
                        numHemiLights: s.hemi.length,
                        pointLightShadows: s.shadowsPointLight,
                        shadowMapEnabled: e.shadowMap.enabled && c.receiveShadow && s.shadows.length > 0,
                        shadowMapType: e.shadowMap.type,
                        toneMapping: e.toneMapping,
                        physicallyCorrectLights: e.physicallyCorrectLights,
                        premultipliedAlpha: o.premultipliedAlpha,
                        alphaTest: o.alphaTest,
                        doubleSided: o.side === r.DoubleSide,
                        flipSided: o.side === r.BackSide
                    };
                    return f
                }, this.getProgramCode = function(e, t) {
                    var i = [];
                    if (t.shaderID ? i.push(t.shaderID) : (i.push(e.fragmentShader), i.push(e.vertexShader)), void 0 !== e.defines)
                        for (var r in e.defines) i.push(r), i.push(e.defines[r]);
                    for (var n = 0; n < s.length; n++) {
                        var o = s[n];
                        i.push(o), i.push(t[o])
                    }
                    return i.join()
                }, this.acquireProgram = function(t, i, n) {
                    for (var a, s = 0, l = o.length; l > s; s++) {
                        var c = o[s];
                        if (c.code === n) {
                            a = c, ++a.usedTimes;
                            break
                        }
                    }
                    return void 0 === a && (a = new r.WebGLProgram(e, n, t, i), o.push(a)), a
                }, this.releaseProgram = function(e) {
                    if (0 === --e.usedTimes) {
                        var t = o.indexOf(e);
                        o[t] = o[o.length - 1], o.pop(), e.destroy()
                    }
                }, this.programs = o
            }, r.WebGLProperties = function() {
                var e = {};
                this.get = function(t) {
                    var i = t.uuid,
                        r = e[i];
                    return void 0 === r && (r = {}, e[i] = r), r
                }, this["delete"] = function(t) {
                    delete e[t.uuid]
                }, this.clear = function() {
                    e = {}
                }
            }, r.WebGLShader = function() {
                function e(e) {
                    for (var t = e.split("\n"), i = 0; i < t.length; i++) t[i] = i + 1 + ": " + t[i];
                    return t.join("\n")
                }
                return function(t, i, r) {
                    var n = t.createShader(i);
                    return t.shaderSource(n, r), t.compileShader(n), t.getShaderParameter(n, t.COMPILE_STATUS) === !1 && console.error("THREE.WebGLShader: Shader couldn't compile."), "" !== t.getShaderInfoLog(n) && console.warn("THREE.WebGLShader: gl.getShaderInfoLog()", i === t.VERTEX_SHADER ? "vertex" : "fragment", t.getShaderInfoLog(n), e(r)), n
                }
            }(), r.WebGLShadowMap = function(e, t, i) {
                function n(e, t, i, n) {
                    var o = e.geometry,
                        a = null,
                        s = v,
                        l = e.customDepthMaterial;
                    if (i && (s = y, l = e.customDistanceMaterial), l) a = l;
                    else {
                        var c = void 0 !== o.morphTargets && o.morphTargets.length > 0 && t.morphTargets,
                            h = e instanceof r.SkinnedMesh && t.skinning,
                            u = 0;
                        c && (u |= d), h && (u |= m), a = s[u]
                    }
                    return a.visible = t.visible, a.wireframe = t.wireframe, a.wireframeLinewidth = t.wireframeLinewidth, i && void 0 !== a.uniforms.lightPos && a.uniforms.lightPos.value.copy(n), a
                }

                function o(e, t, i) {
                    if (e.visible !== !1) {
                        if (e.layers.test(t.layers) && (e instanceof r.Mesh || e instanceof r.Line || e instanceof r.Points) && e.castShadow && (e.frustumCulled === !1 || l.intersectsObject(e) === !0)) {
                            var n = e.material;
                            n.visible === !0 && (e.modelViewMatrix.multiplyMatrices(i.matrixWorldInverse, e.matrixWorld), f.push(e))
                        }
                        for (var a = e.children, s = 0, c = a.length; c > s; s++) o(a[s], t, i)
                    }
                }
                for (var a = e.context, s = e.state, l = new r.Frustum, c = new r.Matrix4, h = new r.Vector2, u = new r.Vector3, p = new r.Vector3, f = [], d = 1, m = 2, g = (d | m) + 1, v = new Array(g), y = new Array(g), _ = [new r.Vector3(1, 0, 0), new r.Vector3(-1, 0, 0), new r.Vector3(0, 0, 1), new r.Vector3(0, 0, -1), new r.Vector3(0, 1, 0), new r.Vector3(0, -1, 0)], x = [new r.Vector3(0, 1, 0), new r.Vector3(0, 1, 0), new r.Vector3(0, 1, 0), new r.Vector3(0, 1, 0), new r.Vector3(0, 0, 1), new r.Vector3(0, 0, -1)], b = [new r.Vector4, new r.Vector4, new r.Vector4, new r.Vector4, new r.Vector4, new r.Vector4], w = r.ShaderLib.depthRGBA, T = r.UniformsUtils.clone(w.uniforms), M = r.ShaderLib.distanceRGBA, S = r.UniformsUtils.clone(M.uniforms), E = 0; E !== g; ++E) {
                    var A = 0 !== (E & d),
                        C = 0 !== (E & m),
                        L = new r.ShaderMaterial({
                            uniforms: T,
                            vertexShader: w.vertexShader,
                            fragmentShader: w.fragmentShader,
                            morphTargets: A,
                            skinning: C
                        });
                    v[E] = L;
                    var P = new r.ShaderMaterial({
                        defines: {
                            USE_SHADOWMAP: ""
                        },
                        uniforms: S,
                        vertexShader: M.vertexShader,
                        fragmentShader: M.fragmentShader,
                        morphTargets: A,
                        skinning: C
                    });
                    y[E] = P
                }
                var R = this;
                this.enabled = !1, this.autoUpdate = !0, this.needsUpdate = !1, this.type = r.PCFShadowMap, this.cullFace = r.CullFaceFront, this.render = function(d, m) {
                    var g, v, y = t.shadows;
                    if (0 !== y.length && R.enabled !== !1 && (R.autoUpdate !== !1 || R.needsUpdate !== !1)) {
                        s.clearColor(1, 1, 1, 1), s.disable(a.BLEND), s.enable(a.CULL_FACE), a.frontFace(a.CCW), a.cullFace(R.cullFace === r.CullFaceFront ? a.FRONT : a.BACK), s.setDepthTest(!0), s.setScissorTest(!1);
                        for (var w = 0, T = y.length; T > w; w++) {
                            var M = y[w],
                                S = M.shadow,
                                E = S.camera;
                            if (h.copy(S.mapSize), M instanceof r.PointLight) {
                                g = 6, v = !0;
                                var A = h.x,
                                    C = h.y;
                                b[0].set(2 * A, C, A, C), b[1].set(0, C, A, C), b[2].set(3 * A, C, A, C), b[3].set(A, C, A, C), b[4].set(3 * A, 0, A, C), b[5].set(A, 0, A, C), h.x *= 4, h.y *= 2
                            } else g = 1, v = !1;
                            if (null === S.map) {
                                var L = {
                                    minFilter: r.NearestFilter,
                                    magFilter: r.NearestFilter,
                                    format: r.RGBAFormat
                                };
                                S.map = new r.WebGLRenderTarget(h.x, h.y, L), M instanceof r.SpotLight && (E.aspect = h.x / h.y), E.updateProjectionMatrix()
                            }
                            var P = S.map,
                                D = S.matrix;
                            p.setFromMatrixPosition(M.matrixWorld), E.position.copy(p), e.setRenderTarget(P), e.clear();
                            for (var O = 0; g > O; O++) {
                                if (v) {
                                    u.copy(E.position), u.add(_[O]), E.up.copy(x[O]), E.lookAt(u);
                                    var I = b[O];
                                    s.viewport(I)
                                } else u.setFromMatrixPosition(M.target.matrixWorld), E.lookAt(u);
                                E.updateMatrixWorld(), E.matrixWorldInverse.getInverse(E.matrixWorld), D.set(.5, 0, 0, .5, 0, .5, 0, .5, 0, 0, .5, .5, 0, 0, 0, 1), D.multiply(E.projectionMatrix), D.multiply(E.matrixWorldInverse), c.multiplyMatrices(E.projectionMatrix, E.matrixWorldInverse), l.setFromMatrix(c), f.length = 0, o(d, m, E);
                                for (var F = 0, N = f.length; N > F; F++) {
                                    var B = f[F],
                                        k = i.update(B),
                                        U = B.material;
                                    if (U instanceof r.MultiMaterial)
                                        for (var V = k.groups, z = U.materials, G = 0, H = V.length; H > G; G++) {
                                            var j = V[G],
                                                W = z[j.materialIndex];
                                            if (W.visible === !0) {
                                                var X = n(B, W, v, p);
                                                e.renderBufferDirect(E, null, k, X, B, j)
                                            }
                                        } else {
                                            var X = n(B, U, v, p);
                                            e.renderBufferDirect(E, null, k, X, B, null)
                                        }
                                }
                            }
                        }
                        var q = e.getClearColor(),
                            Y = e.getClearAlpha();
                        e.setClearColor(q, Y), s.enable(a.BLEND), R.cullFace === r.CullFaceFront && a.cullFace(a.BACK), R.needsUpdate = !1
                    }
                }
            }, r.WebGLState = function(e, t, i) {
                var n = this,
                    o = new r.Vector4,
                    a = new Uint8Array(16),
                    s = new Uint8Array(16),
                    l = new Uint8Array(16),
                    c = {},
                    h = null,
                    u = null,
                    p = null,
                    f = null,
                    d = null,
                    m = null,
                    g = null,
                    v = null,
                    y = !1,
                    _ = null,
                    x = null,
                    b = null,
                    w = null,
                    T = null,
                    M = null,
                    S = null,
                    E = null,
                    A = null,
                    C = null,
                    L = null,
                    P = null,
                    R = null,
                    D = null,
                    O = null,
                    I = e.getParameter(e.MAX_TEXTURE_IMAGE_UNITS),
                    F = void 0,
                    N = {},
                    B = new r.Vector4,
                    k = null,
                    U = null,
                    V = new r.Vector4,
                    z = new r.Vector4,
                    G = e.createTexture();
                e.bindTexture(e.TEXTURE_2D, G), e.texParameteri(e.TEXTURE_2D, e.TEXTURE_MIN_FILTER, e.LINEAR), e.texImage2D(e.TEXTURE_2D, 0, e.RGB, 1, 1, 0, e.RGB, e.UNSIGNED_BYTE, new Uint8Array(3)), this.init = function() {
                    this.clearColor(0, 0, 0, 1), this.clearDepth(1), this.clearStencil(0), this.enable(e.DEPTH_TEST), e.depthFunc(e.LEQUAL), e.frontFace(e.CCW), e.cullFace(e.BACK), this.enable(e.CULL_FACE), this.enable(e.BLEND), e.blendEquation(e.FUNC_ADD), e.blendFunc(e.SRC_ALPHA, e.ONE_MINUS_SRC_ALPHA)
                }, this.initAttributes = function() {
                    for (var e = 0, t = a.length; t > e; e++) a[e] = 0
                }, this.enableAttribute = function(i) {
                    if (a[i] = 1, 0 === s[i] && (e.enableVertexAttribArray(i), s[i] = 1), 0 !== l[i]) {
                        var r = t.get("ANGLE_instanced_arrays");
                        r.vertexAttribDivisorANGLE(i, 0), l[i] = 0
                    }
                }, this.enableAttributeAndDivisor = function(t, i, r) {
                    a[t] = 1, 0 === s[t] && (e.enableVertexAttribArray(t), s[t] = 1), l[t] !== i && (r.vertexAttribDivisorANGLE(t, i), l[t] = i)
                }, this.disableUnusedAttributes = function() {
                    for (var t = 0, i = s.length; i > t; t++) s[t] !== a[t] && (e.disableVertexAttribArray(t), s[t] = 0)
                }, this.enable = function(t) {
                    c[t] !== !0 && (e.enable(t), c[t] = !0)
                }, this.disable = function(t) {
                    c[t] !== !1 && (e.disable(t), c[t] = !1)
                }, this.getCompressedTextureFormats = function() {
                    if (null === h && (h = [], t.get("WEBGL_compressed_texture_pvrtc") || t.get("WEBGL_compressed_texture_s3tc") || t.get("WEBGL_compressed_texture_etc1")))
                        for (var i = e.getParameter(e.COMPRESSED_TEXTURE_FORMATS), r = 0; r < i.length; r++) h.push(i[r]);
                    return h
                }, this.setBlending = function(t, n, o, a, s, l, c, h) {
                    t === r.NoBlending ? this.disable(e.BLEND) : this.enable(e.BLEND), t === u && h === y || (t === r.AdditiveBlending ? h ? (e.blendEquationSeparate(e.FUNC_ADD, e.FUNC_ADD), e.blendFuncSeparate(e.ONE, e.ONE, e.ONE, e.ONE)) : (e.blendEquation(e.FUNC_ADD), e.blendFunc(e.SRC_ALPHA, e.ONE)) : t === r.SubtractiveBlending ? h ? (e.blendEquationSeparate(e.FUNC_ADD, e.FUNC_ADD), e.blendFuncSeparate(e.ZERO, e.ZERO, e.ONE_MINUS_SRC_COLOR, e.ONE_MINUS_SRC_ALPHA)) : (e.blendEquation(e.FUNC_ADD), e.blendFunc(e.ZERO, e.ONE_MINUS_SRC_COLOR)) : t === r.MultiplyBlending ? h ? (e.blendEquationSeparate(e.FUNC_ADD, e.FUNC_ADD), e.blendFuncSeparate(e.ZERO, e.ZERO, e.SRC_COLOR, e.SRC_ALPHA)) : (e.blendEquation(e.FUNC_ADD), e.blendFunc(e.ZERO, e.SRC_COLOR)) : h ? (e.blendEquationSeparate(e.FUNC_ADD, e.FUNC_ADD), e.blendFuncSeparate(e.ONE, e.ONE_MINUS_SRC_ALPHA, e.ONE, e.ONE_MINUS_SRC_ALPHA)) : (e.blendEquationSeparate(e.FUNC_ADD, e.FUNC_ADD), e.blendFuncSeparate(e.SRC_ALPHA, e.ONE_MINUS_SRC_ALPHA, e.ONE, e.ONE_MINUS_SRC_ALPHA)), u = t, y = h), t === r.CustomBlending ? (s = s || n, l = l || o, c = c || a, n === p && s === m || (e.blendEquationSeparate(i(n), i(s)), p = n, m = s), o === f && a === d && l === g && c === v || (e.blendFuncSeparate(i(o), i(a), i(l), i(c)), f = o, d = a, g = l, v = c)) : (p = null, f = null, d = null, m = null, g = null, v = null)
                }, this.setDepthFunc = function(t) {
                    if (_ !== t) {
                        if (t) switch (t) {
                            case r.NeverDepth:
                                e.depthFunc(e.NEVER);
                                break;
                            case r.AlwaysDepth:
                                e.depthFunc(e.ALWAYS);
                                break;
                            case r.LessDepth:
                                e.depthFunc(e.LESS);
                                break;
                            case r.LessEqualDepth:
                                e.depthFunc(e.LEQUAL);
                                break;
                            case r.EqualDepth:
                                e.depthFunc(e.EQUAL);
                                break;
                            case r.GreaterEqualDepth:
                                e.depthFunc(e.GEQUAL);
                                break;
                            case r.GreaterDepth:
                                e.depthFunc(e.GREATER);
                                break;
                            case r.NotEqualDepth:
                                e.depthFunc(e.NOTEQUAL);
                                break;
                            default:
                                e.depthFunc(e.LEQUAL)
                        } else e.depthFunc(e.LEQUAL);
                        _ = t
                    }
                }, this.setDepthTest = function(t) {
                    t ? this.enable(e.DEPTH_TEST) : this.disable(e.DEPTH_TEST)
                }, this.setDepthWrite = function(t) {
                    x !== t && (e.depthMask(t), x = t)
                }, this.setColorWrite = function(t) {
                    b !== t && (e.colorMask(t, t, t, t), b = t)
                }, this.setStencilFunc = function(t, i, r) {
                    T === t && M === i && S === r || (e.stencilFunc(t, i, r), T = t, M = i, S = r)
                }, this.setStencilOp = function(t, i, r) {
                    E === t && A === i && C === r || (e.stencilOp(t, i, r), E = t, A = i, C = r)
                }, this.setStencilTest = function(t) {
                    t ? this.enable(e.STENCIL_TEST) : this.disable(e.STENCIL_TEST)
                }, this.setStencilWrite = function(t) {
                    w !== t && (e.stencilMask(t), w = t)
                }, this.setFlipSided = function(t) {
                    L !== t && (t ? e.frontFace(e.CW) : e.frontFace(e.CCW), L = t)
                }, this.setLineWidth = function(t) {
                    t !== P && (e.lineWidth(t), P = t)
                }, this.setPolygonOffset = function(t, i, r) {
                    t ? this.enable(e.POLYGON_OFFSET_FILL) : this.disable(e.POLYGON_OFFSET_FILL), !t || R === i && D === r || (e.polygonOffset(i, r), R = i, D = r)
                }, this.getScissorTest = function() {
                    return O
                }, this.setScissorTest = function(t) {
                    O = t, t ? this.enable(e.SCISSOR_TEST) : this.disable(e.SCISSOR_TEST)
                }, this.activeTexture = function(t) {
                    void 0 === t && (t = e.TEXTURE0 + I - 1), F !== t && (e.activeTexture(t), F = t)
                }, this.bindTexture = function(t, i) {
                    void 0 === F && n.activeTexture();
                    var r = N[F];
                    void 0 === r && (r = {
                        type: void 0,
                        texture: void 0
                    }, N[F] = r), r.type === t && r.texture === i || (e.bindTexture(t, i || G), r.type = t, r.texture = i)
                }, this.compressedTexImage2D = function() {
                    try {
                        e.compressedTexImage2D.apply(e, arguments)
                    } catch (t) {
                        console.error(t)
                    }
                }, this.texImage2D = function() {
                    try {
                        e.texImage2D.apply(e, arguments)
                    } catch (t) {
                        console.error(t)
                    }
                }, this.clearColor = function(t, i, r, n) {
                    o.set(t, i, r, n), B.equals(o) === !1 && (e.clearColor(t, i, r, n), B.copy(o))
                }, this.clearDepth = function(t) {
                    k !== t && (e.clearDepth(t), k = t)
                }, this.clearStencil = function(t) {
                    U !== t && (e.clearStencil(t), U = t)
                }, this.scissor = function(t) {
                    V.equals(t) === !1 && (e.scissor(t.x, t.y, t.z, t.w), V.copy(t))
                }, this.viewport = function(t) {
                    z.equals(t) === !1 && (e.viewport(t.x, t.y, t.z, t.w), z.copy(t))
                }, this.reset = function() {
                    for (var t = 0; t < s.length; t++) 1 === s[t] && (e.disableVertexAttribArray(t), s[t] = 0);
                    c = {}, h = null, F = void 0, N = {}, u = null, b = null, x = null, w = null, L = null
                }
            }, r.LensFlarePlugin = function(e, t) {
                function i() {
                    var e = new Float32Array([-1, -1, 0, 0, 1, -1, 1, 0, 1, 1, 1, 1, -1, 1, 0, 1]),
                        t = new Uint16Array([0, 1, 2, 0, 2, 3]);
                    o = f.createBuffer(), a = f.createBuffer(), f.bindBuffer(f.ARRAY_BUFFER, o), f.bufferData(f.ARRAY_BUFFER, e, f.STATIC_DRAW), f.bindBuffer(f.ELEMENT_ARRAY_BUFFER, a), f.bufferData(f.ELEMENT_ARRAY_BUFFER, t, f.STATIC_DRAW), u = f.createTexture(), p = f.createTexture(), d.bindTexture(f.TEXTURE_2D, u), f.texImage2D(f.TEXTURE_2D, 0, f.RGB, 16, 16, 0, f.RGB, f.UNSIGNED_BYTE, null), f.texParameteri(f.TEXTURE_2D, f.TEXTURE_WRAP_S, f.CLAMP_TO_EDGE), f.texParameteri(f.TEXTURE_2D, f.TEXTURE_WRAP_T, f.CLAMP_TO_EDGE), f.texParameteri(f.TEXTURE_2D, f.TEXTURE_MAG_FILTER, f.NEAREST), f.texParameteri(f.TEXTURE_2D, f.TEXTURE_MIN_FILTER, f.NEAREST), d.bindTexture(f.TEXTURE_2D, p), f.texImage2D(f.TEXTURE_2D, 0, f.RGBA, 16, 16, 0, f.RGBA, f.UNSIGNED_BYTE, null), f.texParameteri(f.TEXTURE_2D, f.TEXTURE_WRAP_S, f.CLAMP_TO_EDGE), f.texParameteri(f.TEXTURE_2D, f.TEXTURE_WRAP_T, f.CLAMP_TO_EDGE), f.texParameteri(f.TEXTURE_2D, f.TEXTURE_MAG_FILTER, f.NEAREST), f.texParameteri(f.TEXTURE_2D, f.TEXTURE_MIN_FILTER, f.NEAREST), h = f.getParameter(f.MAX_VERTEX_TEXTURE_IMAGE_UNITS) > 0;
                    var i;
                    i = h ? {
                        vertexShader: ["uniform lowp int renderType;", "uniform vec3 screenPosition;", "uniform vec2 scale;", "uniform float rotation;", "uniform sampler2D occlusionMap;", "attribute vec2 position;", "attribute vec2 uv;", "varying vec2 vUV;", "varying float vVisibility;", "void main() {", "vUV = uv;", "vec2 pos = position;", "if ( renderType == 2 ) {", "vec4 visibility = texture2D( occlusionMap, vec2( 0.1, 0.1 ) );", "visibility += texture2D( occlusionMap, vec2( 0.5, 0.1 ) );", "visibility += texture2D( occlusionMap, vec2( 0.9, 0.1 ) );", "visibility += texture2D( occlusionMap, vec2( 0.9, 0.5 ) );", "visibility += texture2D( occlusionMap, vec2( 0.9, 0.9 ) );", "visibility += texture2D( occlusionMap, vec2( 0.5, 0.9 ) );", "visibility += texture2D( occlusionMap, vec2( 0.1, 0.9 ) );", "visibility += texture2D( occlusionMap, vec2( 0.1, 0.5 ) );", "visibility += texture2D( occlusionMap, vec2( 0.5, 0.5 ) );", "vVisibility =        visibility.r / 9.0;", "vVisibility *= 1.0 - visibility.g / 9.0;", "vVisibility *=       visibility.b / 9.0;", "vVisibility *= 1.0 - visibility.a / 9.0;", "pos.x = cos( rotation ) * position.x - sin( rotation ) * position.y;", "pos.y = sin( rotation ) * position.x + cos( rotation ) * position.y;", "}", "gl_Position = vec4( ( pos * scale + screenPosition.xy ).xy, screenPosition.z, 1.0 );", "}"].join("\n"),
                        fragmentShader: ["uniform lowp int renderType;", "uniform sampler2D map;", "uniform float opacity;", "uniform vec3 color;", "varying vec2 vUV;", "varying float vVisibility;", "void main() {", "if ( renderType == 0 ) {", "gl_FragColor = vec4( 1.0, 0.0, 1.0, 0.0 );", "} else if ( renderType == 1 ) {", "gl_FragColor = texture2D( map, vUV );", "} else {", "vec4 texture = texture2D( map, vUV );", "texture.a *= opacity * vVisibility;", "gl_FragColor = texture;", "gl_FragColor.rgb *= color;", "}", "}"].join("\n")
                    } : {
                        vertexShader: ["uniform lowp int renderType;", "uniform vec3 screenPosition;", "uniform vec2 scale;", "uniform float rotation;", "attribute vec2 position;", "attribute vec2 uv;", "varying vec2 vUV;", "void main() {", "vUV = uv;", "vec2 pos = position;", "if ( renderType == 2 ) {", "pos.x = cos( rotation ) * position.x - sin( rotation ) * position.y;", "pos.y = sin( rotation ) * position.x + cos( rotation ) * position.y;", "}", "gl_Position = vec4( ( pos * scale + screenPosition.xy ).xy, screenPosition.z, 1.0 );", "}"].join("\n"),
                        fragmentShader: ["precision mediump float;", "uniform lowp int renderType;", "uniform sampler2D map;", "uniform sampler2D occlusionMap;", "uniform float opacity;", "uniform vec3 color;", "varying vec2 vUV;", "void main() {", "if ( renderType == 0 ) {", "gl_FragColor = vec4( texture2D( map, vUV ).rgb, 0.0 );", "} else if ( renderType == 1 ) {", "gl_FragColor = texture2D( map, vUV );", "} else {", "float visibility = texture2D( occlusionMap, vec2( 0.5, 0.1 ) ).a;", "visibility += texture2D( occlusionMap, vec2( 0.9, 0.5 ) ).a;", "visibility += texture2D( occlusionMap, vec2( 0.5, 0.9 ) ).a;", "visibility += texture2D( occlusionMap, vec2( 0.1, 0.5 ) ).a;", "visibility = ( 1.0 - visibility / 4.0 );", "vec4 texture = texture2D( map, vUV );", "texture.a *= opacity * visibility;", "gl_FragColor = texture;", "gl_FragColor.rgb *= color;", "}", "}"].join("\n")
                    }, s = n(i), l = {
                        vertex: f.getAttribLocation(s, "position"),
                        uv: f.getAttribLocation(s, "uv")
                    }, c = {
                        renderType: f.getUniformLocation(s, "renderType"),
                        map: f.getUniformLocation(s, "map"),
                        occlusionMap: f.getUniformLocation(s, "occlusionMap"),
                        opacity: f.getUniformLocation(s, "opacity"),
                        color: f.getUniformLocation(s, "color"),
                        scale: f.getUniformLocation(s, "scale"),
                        rotation: f.getUniformLocation(s, "rotation"),
                        screenPosition: f.getUniformLocation(s, "screenPosition")
                    }
                }

                function n(t) {
                    var i = f.createProgram(),
                        r = f.createShader(f.FRAGMENT_SHADER),
                        n = f.createShader(f.VERTEX_SHADER),
                        o = "precision " + e.getPrecision() + " float;\n";
                    return f.shaderSource(r, o + t.fragmentShader), f.shaderSource(n, o + t.vertexShader), f.compileShader(r), f.compileShader(n), f.attachShader(i, r), f.attachShader(i, n), f.linkProgram(i), i
                }
                var o, a, s, l, c, h, u, p, f = e.context,
                    d = e.state;
                this.render = function(n, m, g) {
                    if (0 !== t.length) {
                        var v = new r.Vector3,
                            y = g.w / g.z,
                            _ = .5 * g.z,
                            x = .5 * g.w,
                            b = 16 / g.w,
                            w = new r.Vector2(b * y, b),
                            T = new r.Vector3(1, 1, 0),
                            M = new r.Vector2(1, 1);
                        void 0 === s && i(), f.useProgram(s), d.initAttributes(), d.enableAttribute(l.vertex), d.enableAttribute(l.uv), d.disableUnusedAttributes(), f.uniform1i(c.occlusionMap, 0), f.uniform1i(c.map, 1), f.bindBuffer(f.ARRAY_BUFFER, o), f.vertexAttribPointer(l.vertex, 2, f.FLOAT, !1, 16, 0), f.vertexAttribPointer(l.uv, 2, f.FLOAT, !1, 16, 8), f.bindBuffer(f.ELEMENT_ARRAY_BUFFER, a), d.disable(f.CULL_FACE), d.setDepthWrite(!1);
                        for (var S = 0, E = t.length; E > S; S++) {
                            b = 16 / g.w, w.set(b * y, b);
                            var A = t[S];
                            if (v.set(A.matrixWorld.elements[12], A.matrixWorld.elements[13], A.matrixWorld.elements[14]), v.applyMatrix4(m.matrixWorldInverse), v.applyProjection(m.projectionMatrix), T.copy(v), M.x = T.x * _ + _, M.y = T.y * x + x, h || M.x > 0 && M.x < g.z && M.y > 0 && M.y < g.w) {
                                d.activeTexture(f.TEXTURE0), d.bindTexture(f.TEXTURE_2D, null), d.activeTexture(f.TEXTURE1), d.bindTexture(f.TEXTURE_2D, u), f.copyTexImage2D(f.TEXTURE_2D, 0, f.RGB, g.x + M.x - 8, g.y + M.y - 8, 16, 16, 0), f.uniform1i(c.renderType, 0), f.uniform2f(c.scale, w.x, w.y), f.uniform3f(c.screenPosition, T.x, T.y, T.z), d.disable(f.BLEND), d.enable(f.DEPTH_TEST), f.drawElements(f.TRIANGLES, 6, f.UNSIGNED_SHORT, 0), d.activeTexture(f.TEXTURE0), d.bindTexture(f.TEXTURE_2D, p), f.copyTexImage2D(f.TEXTURE_2D, 0, f.RGBA, g.x + M.x - 8, g.y + M.y - 8, 16, 16, 0), f.uniform1i(c.renderType, 1), d.disable(f.DEPTH_TEST), d.activeTexture(f.TEXTURE1), d.bindTexture(f.TEXTURE_2D, u), f.drawElements(f.TRIANGLES, 6, f.UNSIGNED_SHORT, 0), A.positionScreen.copy(T), A.customUpdateCallback ? A.customUpdateCallback(A) : A.updateLensFlares(), f.uniform1i(c.renderType, 2), d.enable(f.BLEND);
                                for (var C = 0, L = A.lensFlares.length; L > C; C++) {
                                    var P = A.lensFlares[C];
                                    P.opacity > .001 && P.scale > .001 && (T.x = P.x, T.y = P.y, T.z = P.z, b = P.size * P.scale / g.w, w.x = b * y, w.y = b, f.uniform3f(c.screenPosition, T.x, T.y, T.z), f.uniform2f(c.scale, w.x, w.y), f.uniform1f(c.rotation, P.rotation), f.uniform1f(c.opacity, P.opacity), f.uniform3f(c.color, P.color.r, P.color.g, P.color.b), d.setBlending(P.blending, P.blendEquation, P.blendSrc, P.blendDst), e.setTexture(P.texture, 1), f.drawElements(f.TRIANGLES, 6, f.UNSIGNED_SHORT, 0))
                                }
                            }
                        }
                        d.enable(f.CULL_FACE), d.enable(f.DEPTH_TEST), d.setDepthWrite(!0), e.resetGLState()
                    }
                }
            }, r.SpritePlugin = function(e, t) {
                function i() {
                    var e = new Float32Array([-.5, -.5, 0, 0, .5, -.5, 1, 0, .5, .5, 1, 1, -.5, .5, 0, 1]),
                        t = new Uint16Array([0, 1, 2, 0, 2, 3]);
                    a = p.createBuffer(), s = p.createBuffer(), p.bindBuffer(p.ARRAY_BUFFER, a), p.bufferData(p.ARRAY_BUFFER, e, p.STATIC_DRAW), p.bindBuffer(p.ELEMENT_ARRAY_BUFFER, s), p.bufferData(p.ELEMENT_ARRAY_BUFFER, t, p.STATIC_DRAW), l = n(), c = {
                        position: p.getAttribLocation(l, "position"),
                        uv: p.getAttribLocation(l, "uv")
                    }, h = {
                        uvOffset: p.getUniformLocation(l, "uvOffset"),
                        uvScale: p.getUniformLocation(l, "uvScale"),
                        rotation: p.getUniformLocation(l, "rotation"),
                        scale: p.getUniformLocation(l, "scale"),
                        color: p.getUniformLocation(l, "color"),
                        map: p.getUniformLocation(l, "map"),
                        opacity: p.getUniformLocation(l, "opacity"),
                        modelViewMatrix: p.getUniformLocation(l, "modelViewMatrix"),
                        projectionMatrix: p.getUniformLocation(l, "projectionMatrix"),
                        fogType: p.getUniformLocation(l, "fogType"),
                        fogDensity: p.getUniformLocation(l, "fogDensity"),
                        fogNear: p.getUniformLocation(l, "fogNear"),
                        fogFar: p.getUniformLocation(l, "fogFar"),
                        fogColor: p.getUniformLocation(l, "fogColor"),
                        alphaTest: p.getUniformLocation(l, "alphaTest")
                    };
                    var i = document.createElement("canvas");
                    i.width = 8, i.height = 8;
                    var o = i.getContext("2d");
                    o.fillStyle = "white", o.fillRect(0, 0, 8, 8), u = new r.Texture(i), u.needsUpdate = !0
                }

                function n() {
                    var t = p.createProgram(),
                        i = p.createShader(p.VERTEX_SHADER),
                        r = p.createShader(p.FRAGMENT_SHADER);
                    return p.shaderSource(i, ["precision " + e.getPrecision() + " float;", "uniform mat4 modelViewMatrix;", "uniform mat4 projectionMatrix;", "uniform float rotation;", "uniform vec2 scale;", "uniform vec2 uvOffset;", "uniform vec2 uvScale;", "attribute vec2 position;", "attribute vec2 uv;", "varying vec2 vUV;", "void main() {", "vUV = uvOffset + uv * uvScale;", "vec2 alignedPosition = position * scale;", "vec2 rotatedPosition;", "rotatedPosition.x = cos( rotation ) * alignedPosition.x - sin( rotation ) * alignedPosition.y;", "rotatedPosition.y = sin( rotation ) * alignedPosition.x + cos( rotation ) * alignedPosition.y;", "vec4 finalPosition;", "finalPosition = modelViewMatrix * vec4( 0.0, 0.0, 0.0, 1.0 );", "finalPosition.xy += rotatedPosition;", "finalPosition = projectionMatrix * finalPosition;", "gl_Position = finalPosition;", "}"].join("\n")), p.shaderSource(r, ["precision " + e.getPrecision() + " float;", "uniform vec3 color;", "uniform sampler2D map;", "uniform float opacity;", "uniform int fogType;", "uniform vec3 fogColor;", "uniform float fogDensity;", "uniform float fogNear;", "uniform float fogFar;", "uniform float alphaTest;", "varying vec2 vUV;", "void main() {", "vec4 texture = texture2D( map, vUV );", "if ( texture.a < alphaTest ) discard;", "gl_FragColor = vec4( color * texture.xyz, texture.a * opacity );", "if ( fogType > 0 ) {", "float depth = gl_FragCoord.z / gl_FragCoord.w;", "float fogFactor = 0.0;", "if ( fogType == 1 ) {", "fogFactor = smoothstep( fogNear, fogFar, depth );", "} else {", "const float LOG2 = 1.442695;", "fogFactor = exp2( - fogDensity * fogDensity * depth * depth * LOG2 );", "fogFactor = 1.0 - clamp( fogFactor, 0.0, 1.0 );", "}", "gl_FragColor = mix( gl_FragColor, vec4( fogColor, gl_FragColor.w ), fogFactor );", "}", "}"].join("\n")), p.compileShader(i), p.compileShader(r), p.attachShader(t, i), p.attachShader(t, r), p.linkProgram(t), t
                }

                function o(e, t) {
                    return e.renderOrder !== t.renderOrder ? e.renderOrder - t.renderOrder : e.z !== t.z ? t.z - e.z : t.id - e.id
                }
                var a, s, l, c, h, u, p = e.context,
                    f = e.state,
                    d = new r.Vector3,
                    m = new r.Quaternion,
                    g = new r.Vector3;
                this.render = function(n, v) {
                    if (0 !== t.length) {
                        void 0 === l && i(), p.useProgram(l), f.initAttributes(), f.enableAttribute(c.position), f.enableAttribute(c.uv), f.disableUnusedAttributes(), f.disable(p.CULL_FACE), f.enable(p.BLEND), p.bindBuffer(p.ARRAY_BUFFER, a), p.vertexAttribPointer(c.position, 2, p.FLOAT, !1, 16, 0), p.vertexAttribPointer(c.uv, 2, p.FLOAT, !1, 16, 8), p.bindBuffer(p.ELEMENT_ARRAY_BUFFER, s), p.uniformMatrix4fv(h.projectionMatrix, !1, v.projectionMatrix.elements), f.activeTexture(p.TEXTURE0), p.uniform1i(h.map, 0);
                        var y = 0,
                            _ = 0,
                            x = n.fog;
                        x ? (p.uniform3f(h.fogColor, x.color.r, x.color.g, x.color.b), x instanceof r.Fog ? (p.uniform1f(h.fogNear, x.near), p.uniform1f(h.fogFar, x.far), p.uniform1i(h.fogType, 1), y = 1, _ = 1) : x instanceof r.FogExp2 && (p.uniform1f(h.fogDensity, x.density), p.uniform1i(h.fogType, 2), y = 2, _ = 2)) : (p.uniform1i(h.fogType, 0), y = 0, _ = 0);
                        for (var b = 0, w = t.length; w > b; b++) {
                            var T = t[b];
                            T.modelViewMatrix.multiplyMatrices(v.matrixWorldInverse, T.matrixWorld), T.z = -T.modelViewMatrix.elements[14]
                        }
                        t.sort(o);
                        for (var M = [], b = 0, w = t.length; w > b; b++) {
                            var T = t[b],
                                S = T.material;
                            p.uniform1f(h.alphaTest, S.alphaTest), p.uniformMatrix4fv(h.modelViewMatrix, !1, T.modelViewMatrix.elements), T.matrixWorld.decompose(d, m, g), M[0] = g.x, M[1] = g.y;
                            var E = 0;
                            n.fog && S.fog && (E = _), y !== E && (p.uniform1i(h.fogType, E), y = E), null !== S.map ? (p.uniform2f(h.uvOffset, S.map.offset.x, S.map.offset.y), p.uniform2f(h.uvScale, S.map.repeat.x, S.map.repeat.y)) : (p.uniform2f(h.uvOffset, 0, 0), p.uniform2f(h.uvScale, 1, 1)), p.uniform1f(h.opacity, S.opacity), p.uniform3f(h.color, S.color.r, S.color.g, S.color.b), p.uniform1f(h.rotation, S.rotation), p.uniform2fv(h.scale, M), f.setBlending(S.blending, S.blendEquation, S.blendSrc, S.blendDst), f.setDepthTest(S.depthTest), f.setDepthWrite(S.depthWrite), S.map && S.map.image && S.map.image.width ? e.setTexture(S.map, 0) : e.setTexture(u, 0), p.drawElements(p.TRIANGLES, 6, p.UNSIGNED_SHORT, 0)
                        }
                        f.enable(p.CULL_FACE), e.resetGLState()
                    }
                }
            }, Object.defineProperties(r.Box2.prototype, {
                empty: {
                    value: function() {
                        return console.warn("THREE.Box2: .empty() has been renamed to .isEmpty()."), this.isEmpty()
                    }
                },
                isIntersectionBox: {
                    value: function(e) {
                        return console.warn("THREE.Box2: .isIntersectionBox() has been renamed to .intersectsBox()."), this.intersectsBox(e)
                    }
                }
            }), Object.defineProperties(r.Box3.prototype, {
                empty: {
                    value: function() {
                        return console.warn("THREE.Box3: .empty() has been renamed to .isEmpty()."), this.isEmpty()
                    }
                },
                isIntersectionBox: {
                    value: function(e) {
                        return console.warn("THREE.Box3: .isIntersectionBox() has been renamed to .intersectsBox()."), this.intersectsBox(e)
                    }
                },
                isIntersectionSphere: {
                    value: function(e) {
                        return console.warn("THREE.Box3: .isIntersectionSphere() has been renamed to .intersectsSphere()."), this.intersectsSphere(e)
                    }
                }
            }), Object.defineProperties(r.Matrix3.prototype, {
                multiplyVector3: {
                    value: function(e) {
                        return console.warn("THREE.Matrix3: .multiplyVector3() has been removed. Use vector.applyMatrix3( matrix ) instead."), e.applyMatrix3(this)
                    }
                },
                multiplyVector3Array: {
                    value: function(e) {
                        return console.warn("THREE.Matrix3: .multiplyVector3Array() has been renamed. Use matrix.applyToVector3Array( array ) instead."), this.applyToVector3Array(e)
                    }
                }
            }), Object.defineProperties(r.Matrix4.prototype, {
                extractPosition: {
                    value: function(e) {
                        return console.warn("THREE.Matrix4: .extractPosition() has been renamed to .copyPosition()."), this.copyPosition(e)
                    }
                },
                setRotationFromQuaternion: {
                    value: function(e) {
                        return console.warn("THREE.Matrix4: .setRotationFromQuaternion() has been renamed to .makeRotationFromQuaternion()."), this.makeRotationFromQuaternion(e)
                    }
                },
                multiplyVector3: {
                    value: function(e) {
                        return console.warn("THREE.Matrix4: .multiplyVector3() has been removed. Use vector.applyMatrix4( matrix ) or vector.applyProjection( matrix ) instead."), e.applyProjection(this)
                    }
                },
                multiplyVector4: {
                    value: function(e) {
                        return console.warn("THREE.Matrix4: .multiplyVector4() has been removed. Use vector.applyMatrix4( matrix ) instead."), e.applyMatrix4(this)
                    }
                },
                multiplyVector3Array: {
                    value: function(e) {
                        return console.warn("THREE.Matrix4: .multiplyVector3Array() has been renamed. Use matrix.applyToVector3Array( array ) instead."), this.applyToVector3Array(e)
                    }
                },
                rotateAxis: {
                    value: function(e) {
                        console.warn("THREE.Matrix4: .rotateAxis() has been removed. Use Vector3.transformDirection( matrix ) instead."), e.transformDirection(this)
                    }
                },
                crossVector: {
                    value: function(e) {
                        return console.warn("THREE.Matrix4: .crossVector() has been removed. Use vector.applyMatrix4( matrix ) instead."), e.applyMatrix4(this)
                    }
                },
                translate: {
                    value: function(e) {
                        console.error("THREE.Matrix4: .translate() has been removed.")
                    }
                },
                rotateX: {
                    value: function(e) {
                        console.error("THREE.Matrix4: .rotateX() has been removed.")
                    }
                },
                rotateY: {
                    value: function(e) {
                        console.error("THREE.Matrix4: .rotateY() has been removed.")
                    }
                },
                rotateZ: {
                    value: function(e) {
                        console.error("THREE.Matrix4: .rotateZ() has been removed.")
                    }
                },
                rotateByAxis: {
                    value: function(e, t) {
                        console.error("THREE.Matrix4: .rotateByAxis() has been removed.")
                    }
                }
            }), Object.defineProperties(r.Plane.prototype, {
                isIntersectionLine: {
                    value: function(e) {
                        return console.warn("THREE.Plane: .isIntersectionLine() has been renamed to .intersectsLine()."), this.intersectsLine(e)
                    }
                }
            }), Object.defineProperties(r.Quaternion.prototype, {
                multiplyVector3: {
                    value: function(e) {
                        return console.warn("THREE.Quaternion: .multiplyVector3() has been removed. Use is now vector.applyQuaternion( quaternion ) instead."), e.applyQuaternion(this)
                    }
                }
            }), Object.defineProperties(r.Ray.prototype, {
                isIntersectionBox: {
                    value: function(e) {
                        return console.warn("THREE.Ray: .isIntersectionBox() has been renamed to .intersectsBox()."), this.intersectsBox(e)
                    }
                },
                isIntersectionPlane: {
                    value: function(e) {
                        return console.warn("THREE.Ray: .isIntersectionPlane() has been renamed to .intersectsPlane()."), this.intersectsPlane(e);
                    }
                },
                isIntersectionSphere: {
                    value: function(e) {
                        return console.warn("THREE.Ray: .isIntersectionSphere() has been renamed to .intersectsSphere()."), this.intersectsSphere(e)
                    }
                }
            }), Object.defineProperties(r.Vector3.prototype, {
                setEulerFromRotationMatrix: {
                    value: function() {
                        console.error("THREE.Vector3: .setEulerFromRotationMatrix() has been removed. Use Euler.setFromRotationMatrix() instead.")
                    }
                },
                setEulerFromQuaternion: {
                    value: function() {
                        console.error("THREE.Vector3: .setEulerFromQuaternion() has been removed. Use Euler.setFromQuaternion() instead.")
                    }
                },
                getPositionFromMatrix: {
                    value: function(e) {
                        return console.warn("THREE.Vector3: .getPositionFromMatrix() has been renamed to .setFromMatrixPosition()."), this.setFromMatrixPosition(e)
                    }
                },
                getScaleFromMatrix: {
                    value: function(e) {
                        return console.warn("THREE.Vector3: .getScaleFromMatrix() has been renamed to .setFromMatrixScale()."), this.setFromMatrixScale(e)
                    }
                },
                getColumnFromMatrix: {
                    value: function(e, t) {
                        return console.warn("THREE.Vector3: .getColumnFromMatrix() has been renamed to .setFromMatrixColumn()."), this.setFromMatrixColumn(e, t)
                    }
                }
            }), r.Face4 = function(e, t, i, n, o, a, s) {
                return console.warn("THREE.Face4 has been removed. A THREE.Face3 will be created instead."), new r.Face3(e, t, i, o, a, s)
            }, r.Vertex = function(e, t, i) {
                return console.warn("THREE.Vertex has been removed. Use THREE.Vector3 instead."), new r.Vector3(e, t, i)
            }, Object.defineProperties(r.Object3D.prototype, {
                eulerOrder: {
                    get: function() {
                        return console.warn("THREE.Object3D: .eulerOrder is now .rotation.order."), this.rotation.order
                    },
                    set: function(e) {
                        console.warn("THREE.Object3D: .eulerOrder is now .rotation.order."), this.rotation.order = e
                    }
                },
                getChildByName: {
                    value: function(e) {
                        return console.warn("THREE.Object3D: .getChildByName() has been renamed to .getObjectByName()."), this.getObjectByName(e)
                    }
                },
                renderDepth: {
                    set: function(e) {
                        console.warn("THREE.Object3D: .renderDepth has been removed. Use .renderOrder, instead.")
                    }
                },
                translate: {
                    value: function(e, t) {
                        return console.warn("THREE.Object3D: .translate() has been removed. Use .translateOnAxis( axis, distance ) instead."), this.translateOnAxis(t, e)
                    }
                },
                useQuaternion: {
                    get: function() {
                        console.warn("THREE.Object3D: .useQuaternion has been removed. The library now uses quaternions by default.")
                    },
                    set: function(e) {
                        console.warn("THREE.Object3D: .useQuaternion has been removed. The library now uses quaternions by default.")
                    }
                }
            }), Object.defineProperties(r, {
                PointCloud: {
                    value: function(e, t) {
                        return console.warn("THREE.PointCloud has been renamed to THREE.Points."), new r.Points(e, t)
                    }
                },
                ParticleSystem: {
                    value: function(e, t) {
                        return console.warn("THREE.ParticleSystem has been renamed to THREE.Points."), new r.Points(e, t)
                    }
                }
            }), Object.defineProperties(r.Light.prototype, {
                onlyShadow: {
                    set: function(e) {
                        console.warn("THREE.Light: .onlyShadow has been removed.")
                    }
                },
                shadowCameraFov: {
                    set: function(e) {
                        console.warn("THREE.Light: .shadowCameraFov is now .shadow.camera.fov."), this.shadow.camera.fov = e
                    }
                },
                shadowCameraLeft: {
                    set: function(e) {
                        console.warn("THREE.Light: .shadowCameraLeft is now .shadow.camera.left."), this.shadow.camera.left = e
                    }
                },
                shadowCameraRight: {
                    set: function(e) {
                        console.warn("THREE.Light: .shadowCameraRight is now .shadow.camera.right."), this.shadow.camera.right = e
                    }
                },
                shadowCameraTop: {
                    set: function(e) {
                        console.warn("THREE.Light: .shadowCameraTop is now .shadow.camera.top."), this.shadow.camera.top = e
                    }
                },
                shadowCameraBottom: {
                    set: function(e) {
                        console.warn("THREE.Light: .shadowCameraBottom is now .shadow.camera.bottom."), this.shadow.camera.bottom = e
                    }
                },
                shadowCameraNear: {
                    set: function(e) {
                        console.warn("THREE.Light: .shadowCameraNear is now .shadow.camera.near."), this.shadow.camera.near = e
                    }
                },
                shadowCameraFar: {
                    set: function(e) {
                        console.warn("THREE.Light: .shadowCameraFar is now .shadow.camera.far."), this.shadow.camera.far = e
                    }
                },
                shadowCameraVisible: {
                    set: function(e) {
                        console.warn("THREE.Light: .shadowCameraVisible has been removed. Use new THREE.CameraHelper( light.shadow.camera ) instead.")
                    }
                },
                shadowBias: {
                    set: function(e) {
                        console.warn("THREE.Light: .shadowBias is now .shadow.bias."), this.shadow.bias = e
                    }
                },
                shadowDarkness: {
                    set: function(e) {
                        console.warn("THREE.Light: .shadowDarkness has been removed.")
                    }
                },
                shadowMapWidth: {
                    set: function(e) {
                        console.warn("THREE.Light: .shadowMapWidth is now .shadow.mapSize.width."), this.shadow.mapSize.width = e
                    }
                },
                shadowMapHeight: {
                    set: function(e) {
                        console.warn("THREE.Light: .shadowMapHeight is now .shadow.mapSize.height."), this.shadow.mapSize.height = e
                    }
                }
            }), Object.defineProperties(r.BufferAttribute.prototype, {
                length: {
                    get: function() {
                        return console.warn("THREE.BufferAttribute: .length has been deprecated. Please use .count."), this.array.length
                    }
                }
            }), Object.defineProperties(r.BufferGeometry.prototype, {
                drawcalls: {
                    get: function() {
                        return console.error("THREE.BufferGeometry: .drawcalls has been renamed to .groups."), this.groups
                    }
                },
                offsets: {
                    get: function() {
                        return console.warn("THREE.BufferGeometry: .offsets has been renamed to .groups."), this.groups
                    }
                },
                addIndex: {
                    value: function(e) {
                        console.warn("THREE.BufferGeometry: .addIndex() has been renamed to .setIndex()."), this.setIndex(e)
                    }
                },
                addDrawCall: {
                    value: function(e, t, i) {
                        void 0 !== i && console.warn("THREE.BufferGeometry: .addDrawCall() no longer supports indexOffset."), console.warn("THREE.BufferGeometry: .addDrawCall() is now .addGroup()."), this.addGroup(e, t)
                    }
                },
                clearDrawCalls: {
                    value: function() {
                        console.warn("THREE.BufferGeometry: .clearDrawCalls() is now .clearGroups()."), this.clearGroups()
                    }
                },
                computeTangents: {
                    value: function() {
                        console.warn("THREE.BufferGeometry: .computeTangents() has been removed.")
                    }
                },
                computeOffsets: {
                    value: function() {
                        console.warn("THREE.BufferGeometry: .computeOffsets() has been removed.")
                    }
                }
            }), Object.defineProperties(r.Material.prototype, {
                wrapAround: {
                    get: function() {
                        console.warn("THREE." + this.type + ": .wrapAround has been removed.")
                    },
                    set: function(e) {
                        console.warn("THREE." + this.type + ": .wrapAround has been removed.")
                    }
                },
                wrapRGB: {
                    get: function() {
                        return console.warn("THREE." + this.type + ": .wrapRGB has been removed."), new r.Color
                    }
                }
            }), Object.defineProperties(r, {
                PointCloudMaterial: {
                    value: function(e) {
                        return console.warn("THREE.PointCloudMaterial has been renamed to THREE.PointsMaterial."), new r.PointsMaterial(e)
                    }
                },
                ParticleBasicMaterial: {
                    value: function(e) {
                        return console.warn("THREE.ParticleBasicMaterial has been renamed to THREE.PointsMaterial."), new r.PointsMaterial(e)
                    }
                },
                ParticleSystemMaterial: {
                    value: function(e) {
                        return console.warn("THREE.ParticleSystemMaterial has been renamed to THREE.PointsMaterial."), new r.PointsMaterial(e)
                    }
                }
            }), Object.defineProperties(r.MeshPhongMaterial.prototype, {
                metal: {
                    get: function() {
                        return console.warn("THREE.MeshPhongMaterial: .metal has been removed. Use THREE.MeshStandardMaterial instead."), !1
                    },
                    set: function(e) {
                        console.warn("THREE.MeshPhongMaterial: .metal has been removed. Use THREE.MeshStandardMaterial instead")
                    }
                }
            }), Object.defineProperties(r.ShaderMaterial.prototype, {
                derivatives: {
                    get: function() {
                        return console.warn("THREE.ShaderMaterial: .derivatives has been moved to .extensions.derivatives."), this.extensions.derivatives
                    },
                    set: function(e) {
                        console.warn("THREE. ShaderMaterial: .derivatives has been moved to .extensions.derivatives."), this.extensions.derivatives = e
                    }
                }
            }), Object.defineProperties(r.WebGLRenderer.prototype, {
                supportsFloatTextures: {
                    value: function() {
                        return console.warn("THREE.WebGLRenderer: .supportsFloatTextures() is now .extensions.get( 'OES_texture_float' )."), this.extensions.get("OES_texture_float")
                    }
                },
                supportsHalfFloatTextures: {
                    value: function() {
                        return console.warn("THREE.WebGLRenderer: .supportsHalfFloatTextures() is now .extensions.get( 'OES_texture_half_float' )."), this.extensions.get("OES_texture_half_float")
                    }
                },
                supportsStandardDerivatives: {
                    value: function() {
                        return console.warn("THREE.WebGLRenderer: .supportsStandardDerivatives() is now .extensions.get( 'OES_standard_derivatives' )."), this.extensions.get("OES_standard_derivatives")
                    }
                },
                supportsCompressedTextureS3TC: {
                    value: function() {
                        return console.warn("THREE.WebGLRenderer: .supportsCompressedTextureS3TC() is now .extensions.get( 'WEBGL_compressed_texture_s3tc' )."), this.extensions.get("WEBGL_compressed_texture_s3tc")
                    }
                },
                supportsCompressedTexturePVRTC: {
                    value: function() {
                        return console.warn("THREE.WebGLRenderer: .supportsCompressedTexturePVRTC() is now .extensions.get( 'WEBGL_compressed_texture_pvrtc' )."), this.extensions.get("WEBGL_compressed_texture_pvrtc")
                    }
                },
                supportsBlendMinMax: {
                    value: function() {
                        return console.warn("THREE.WebGLRenderer: .supportsBlendMinMax() is now .extensions.get( 'EXT_blend_minmax' )."), this.extensions.get("EXT_blend_minmax")
                    }
                },
                supportsVertexTextures: {
                    value: function() {
                        return this.capabilities.vertexTextures
                    }
                },
                supportsInstancedArrays: {
                    value: function() {
                        return console.warn("THREE.WebGLRenderer: .supportsInstancedArrays() is now .extensions.get( 'ANGLE_instanced_arrays' )."), this.extensions.get("ANGLE_instanced_arrays")
                    }
                },
                enableScissorTest: {
                    value: function(e) {
                        console.warn("THREE.WebGLRenderer: .enableScissorTest() is now .setScissorTest()."), this.setScissorTest(e)
                    }
                },
                initMaterial: {
                    value: function() {
                        console.warn("THREE.WebGLRenderer: .initMaterial() has been removed.")
                    }
                },
                addPrePlugin: {
                    value: function() {
                        console.warn("THREE.WebGLRenderer: .addPrePlugin() has been removed.")
                    }
                },
                addPostPlugin: {
                    value: function() {
                        console.warn("THREE.WebGLRenderer: .addPostPlugin() has been removed.")
                    }
                },
                updateShadowMap: {
                    value: function() {
                        console.warn("THREE.WebGLRenderer: .updateShadowMap() has been removed.")
                    }
                },
                shadowMapEnabled: {
                    get: function() {
                        return this.shadowMap.enabled
                    },
                    set: function(e) {
                        console.warn("THREE.WebGLRenderer: .shadowMapEnabled is now .shadowMap.enabled."), this.shadowMap.enabled = e
                    }
                },
                shadowMapType: {
                    get: function() {
                        return this.shadowMap.type
                    },
                    set: function(e) {
                        console.warn("THREE.WebGLRenderer: .shadowMapType is now .shadowMap.type."), this.shadowMap.type = e
                    }
                },
                shadowMapCullFace: {
                    get: function() {
                        return this.shadowMap.cullFace
                    },
                    set: function(e) {
                        console.warn("THREE.WebGLRenderer: .shadowMapCullFace is now .shadowMap.cullFace."), this.shadowMap.cullFace = e
                    }
                }
            }), Object.defineProperties(r.WebGLRenderTarget.prototype, {
                wrapS: {
                    get: function() {
                        return console.warn("THREE.WebGLRenderTarget: .wrapS is now .texture.wrapS."), this.texture.wrapS
                    },
                    set: function(e) {
                        console.warn("THREE.WebGLRenderTarget: .wrapS is now .texture.wrapS."), this.texture.wrapS = e
                    }
                },
                wrapT: {
                    get: function() {
                        return console.warn("THREE.WebGLRenderTarget: .wrapT is now .texture.wrapT."), this.texture.wrapT
                    },
                    set: function(e) {
                        console.warn("THREE.WebGLRenderTarget: .wrapT is now .texture.wrapT."), this.texture.wrapT = e
                    }
                },
                magFilter: {
                    get: function() {
                        return console.warn("THREE.WebGLRenderTarget: .magFilter is now .texture.magFilter."), this.texture.magFilter
                    },
                    set: function(e) {
                        console.warn("THREE.WebGLRenderTarget: .magFilter is now .texture.magFilter."), this.texture.magFilter = e
                    }
                },
                minFilter: {
                    get: function() {
                        return console.warn("THREE.WebGLRenderTarget: .minFilter is now .texture.minFilter."), this.texture.minFilter
                    },
                    set: function(e) {
                        console.warn("THREE.WebGLRenderTarget: .minFilter is now .texture.minFilter."), this.texture.minFilter = e
                    }
                },
                anisotropy: {
                    get: function() {
                        return console.warn("THREE.WebGLRenderTarget: .anisotropy is now .texture.anisotropy."), this.texture.anisotropy
                    },
                    set: function(e) {
                        console.warn("THREE.WebGLRenderTarget: .anisotropy is now .texture.anisotropy."), this.texture.anisotropy = e
                    }
                },
                offset: {
                    get: function() {
                        return console.warn("THREE.WebGLRenderTarget: .offset is now .texture.offset."), this.texture.offset
                    },
                    set: function(e) {
                        console.warn("THREE.WebGLRenderTarget: .offset is now .texture.offset."), this.texture.offset = e
                    }
                },
                repeat: {
                    get: function() {
                        return console.warn("THREE.WebGLRenderTarget: .repeat is now .texture.repeat."), this.texture.repeat
                    },
                    set: function(e) {
                        console.warn("THREE.WebGLRenderTarget: .repeat is now .texture.repeat."), this.texture.repeat = e
                    }
                },
                format: {
                    get: function() {
                        return console.warn("THREE.WebGLRenderTarget: .format is now .texture.format."), this.texture.format
                    },
                    set: function(e) {
                        console.warn("THREE.WebGLRenderTarget: .format is now .texture.format."), this.texture.format = e
                    }
                },
                type: {
                    get: function() {
                        return console.warn("THREE.WebGLRenderTarget: .type is now .texture.type."), this.texture.type
                    },
                    set: function(e) {
                        console.warn("THREE.WebGLRenderTarget: .type is now .texture.type."), this.texture.type = e
                    }
                },
                generateMipmaps: {
                    get: function() {
                        return console.warn("THREE.WebGLRenderTarget: .generateMipmaps is now .texture.generateMipmaps."), this.texture.generateMipmaps
                    },
                    set: function(e) {
                        console.warn("THREE.WebGLRenderTarget: .generateMipmaps is now .texture.generateMipmaps."), this.texture.generateMipmaps = e
                    }
                }
            }), r.GeometryUtils = {
                merge: function(e, t, i) {
                    console.warn("THREE.GeometryUtils: .merge() has been moved to Geometry. Use geometry.merge( geometry2, matrix, materialIndexOffset ) instead.");
                    var n;
                    t instanceof r.Mesh && (t.matrixAutoUpdate && t.updateMatrix(), n = t.matrix, t = t.geometry), e.merge(t, n, i)
                },
                center: function(e) {
                    return console.warn("THREE.GeometryUtils: .center() has been moved to Geometry. Use geometry.center() instead."), e.center()
                }
            }, r.ImageUtils = {
                crossOrigin: void 0,
                loadTexture: function(e, t, i, n) {
                    console.warn("THREE.ImageUtils.loadTexture has been deprecated. Use THREE.TextureLoader() instead.");
                    var o = new r.TextureLoader;
                    o.setCrossOrigin(this.crossOrigin);
                    var a = o.load(e, i, void 0, n);
                    return t && (a.mapping = t), a
                },
                loadTextureCube: function(e, t, i, n) {
                    console.warn("THREE.ImageUtils.loadTextureCube has been deprecated. Use THREE.CubeTextureLoader() instead.");
                    var o = new r.CubeTextureLoader;
                    o.setCrossOrigin(this.crossOrigin);
                    var a = o.load(e, i, void 0, n);
                    return t && (a.mapping = t), a
                },
                loadCompressedTexture: function() {
                    console.error("THREE.ImageUtils.loadCompressedTexture has been removed. Use THREE.DDSLoader instead.")
                },
                loadCompressedTextureCube: function() {
                    console.error("THREE.ImageUtils.loadCompressedTextureCube has been removed. Use THREE.DDSLoader instead.")
                }
            }, r.Projector = function() {
                console.error("THREE.Projector has been moved to /examples/js/renderers/Projector.js."), this.projectVector = function(e, t) {
                    console.warn("THREE.Projector: .projectVector() is now vector.project()."), e.project(t)
                }, this.unprojectVector = function(e, t) {
                    console.warn("THREE.Projector: .unprojectVector() is now vector.unproject()."), e.unproject(t)
                }, this.pickingRay = function(e, t) {
                    console.error("THREE.Projector: .pickingRay() is now raycaster.setFromCamera().")
                }
            }, r.CanvasRenderer = function() {
                console.error("THREE.CanvasRenderer has been moved to /examples/js/renderers/CanvasRenderer.js"), this.domElement = document.createElement("canvas"), this.clear = function() {}, this.render = function() {}, this.setClearColor = function() {}, this.setSize = function() {}
            }, r.MeshFaceMaterial = r.MultiMaterial, r.CurveUtils = {
                tangentQuadraticBezier: function(e, t, i, r) {
                    return 2 * (1 - e) * (i - t) + 2 * e * (r - i)
                },
                tangentCubicBezier: function(e, t, i, r, n) {
                    return -3 * t * (1 - e) * (1 - e) + 3 * i * (1 - e) * (1 - e) - 6 * e * i * (1 - e) + 6 * e * r * (1 - e) - 3 * e * e * r + 3 * e * e * n
                },
                tangentSpline: function(e, t, i, r, n) {
                    var o = 6 * e * e - 6 * e,
                        a = 3 * e * e - 4 * e + 1,
                        s = -6 * e * e + 6 * e,
                        l = 3 * e * e - 2 * e;
                    return o + a + s + l
                },
                interpolate: function(e, t, i, r, n) {
                    var o = .5 * (i - e),
                        a = .5 * (r - t),
                        s = n * n,
                        l = n * s;
                    return (2 * t - 2 * i + o + a) * l + (-3 * t + 3 * i - 2 * o - a) * s + o * n + t
                }
            }, r.SceneUtils = {
                createMultiMaterialObject: function(e, t) {
                    for (var i = new r.Group, n = 0, o = t.length; o > n; n++) i.add(new r.Mesh(e, t[n]));
                    return i
                },
                detach: function(e, t, i) {
                    e.applyMatrix(t.matrixWorld), t.remove(e), i.add(e)
                },
                attach: function(e, t, i) {
                    var n = new r.Matrix4;
                    n.getInverse(i.matrixWorld), e.applyMatrix(n), t.remove(e), i.add(e)
                }
            }, r.ShapeUtils = {
                area: function(e) {
                    for (var t = e.length, i = 0, r = t - 1, n = 0; t > n; r = n++) i += e[r].x * e[n].y - e[n].x * e[r].y;
                    return .5 * i
                },
                triangulate: function() {
                    function e(e, t, i, r, n, o) {
                        var a, s, l, c, h, u, p, f, d;
                        if (s = e[o[t]].x, l = e[o[t]].y, c = e[o[i]].x, h = e[o[i]].y, u = e[o[r]].x, p = e[o[r]].y, Number.EPSILON > (c - s) * (p - l) - (h - l) * (u - s)) return !1;
                        var m, g, v, y, _, x, b, w, T, M, S, E, A, C, L;
                        for (m = u - c, g = p - h, v = s - u, y = l - p, _ = c - s, x = h - l, a = 0; n > a; a++)
                            if (f = e[o[a]].x, d = e[o[a]].y, !(f === s && d === l || f === c && d === h || f === u && d === p) && (b = f - s, w = d - l, T = f - c, M = d - h, S = f - u, E = d - p, L = m * M - g * T, A = _ * w - x * b, C = v * E - y * S, L >= -Number.EPSILON && C >= -Number.EPSILON && A >= -Number.EPSILON)) return !1;
                        return !0
                    }
                    return function(t, i) {
                        var n = t.length;
                        if (3 > n) return null;
                        var o, a, s, l = [],
                            c = [],
                            h = [];
                        if (r.ShapeUtils.area(t) > 0)
                            for (a = 0; n > a; a++) c[a] = a;
                        else
                            for (a = 0; n > a; a++) c[a] = n - 1 - a;
                        var u = n,
                            p = 2 * u;
                        for (a = u - 1; u > 2;) {
                            if (p-- <= 0) return console.warn("THREE.ShapeUtils: Unable to triangulate polygon! in triangulate()"), i ? h : l;
                            if (o = a, o >= u && (o = 0), a = o + 1, a >= u && (a = 0), s = a + 1, s >= u && (s = 0), e(t, o, a, s, u, c)) {
                                var f, d, m, g, v;
                                for (f = c[o], d = c[a], m = c[s], l.push([t[f], t[d], t[m]]), h.push([c[o], c[a], c[s]]), g = a, v = a + 1; u > v; g++, v++) c[g] = c[v];
                                u--, p = 2 * u
                            }
                        }
                        return i ? h : l
                    }
                }(),
                triangulateShape: function(e, t) {
                    function i(e, t, i) {
                        return e.x !== t.x ? e.x < t.x ? e.x <= i.x && i.x <= t.x : t.x <= i.x && i.x <= e.x : e.y < t.y ? e.y <= i.y && i.y <= t.y : t.y <= i.y && i.y <= e.y
                    }

                    function n(e, t, r, n, o) {
                        var a = t.x - e.x,
                            s = t.y - e.y,
                            l = n.x - r.x,
                            c = n.y - r.y,
                            h = e.x - r.x,
                            u = e.y - r.y,
                            p = s * l - a * c,
                            f = s * h - a * u;
                        if (Math.abs(p) > Number.EPSILON) {
                            var d;
                            if (p > 0) {
                                if (0 > f || f > p) return [];
                                if (d = c * h - l * u, 0 > d || d > p) return []
                            } else {
                                if (f > 0 || p > f) return [];
                                if (d = c * h - l * u, d > 0 || p > d) return []
                            }
                            if (0 === d) return !o || 0 !== f && f !== p ? [e] : [];
                            if (d === p) return !o || 0 !== f && f !== p ? [t] : [];
                            if (0 === f) return [r];
                            if (f === p) return [n];
                            var m = d / p;
                            return [{
                                x: e.x + m * a,
                                y: e.y + m * s
                            }]
                        }
                        if (0 !== f || c * h !== l * u) return [];
                        var g = 0 === a && 0 === s,
                            v = 0 === l && 0 === c;
                        if (g && v) return e.x !== r.x || e.y !== r.y ? [] : [e];
                        if (g) return i(r, n, e) ? [e] : [];
                        if (v) return i(e, t, r) ? [r] : [];
                        var y, _, x, b, w, T, M, S;
                        return 0 !== a ? (e.x < t.x ? (y = e, x = e.x, _ = t, b = t.x) : (y = t, x = t.x, _ = e, b = e.x), r.x < n.x ? (w = r, M = r.x, T = n, S = n.x) : (w = n, M = n.x, T = r, S = r.x)) : (e.y < t.y ? (y = e, x = e.y, _ = t, b = t.y) : (y = t, x = t.y, _ = e, b = e.y), r.y < n.y ? (w = r, M = r.y, T = n, S = n.y) : (w = n, M = n.y, T = r, S = r.y)), M >= x ? M > b ? [] : b === M ? o ? [] : [w] : S >= b ? [w, _] : [w, T] : x > S ? [] : x === S ? o ? [] : [y] : S >= b ? [y, _] : [y, T]
                    }

                    function o(e, t, i, r) {
                        var n = t.x - e.x,
                            o = t.y - e.y,
                            a = i.x - e.x,
                            s = i.y - e.y,
                            l = r.x - e.x,
                            c = r.y - e.y,
                            h = n * s - o * a,
                            u = n * c - o * l;
                        if (Math.abs(h) > Number.EPSILON) {
                            var p = l * s - c * a;
                            return h > 0 ? u >= 0 && p >= 0 : u >= 0 || p >= 0
                        }
                        return u > 0
                    }

                    function a(e, t) {
                        function i(e, t) {
                            var i = y.length - 1,
                                r = e - 1;
                            0 > r && (r = i);
                            var n = e + 1;
                            n > i && (n = 0);
                            var a = o(y[e], y[r], y[n], s[t]);
                            if (!a) return !1;
                            var l = s.length - 1,
                                c = t - 1;
                            0 > c && (c = l);
                            var h = t + 1;
                            return h > l && (h = 0), a = o(s[t], s[c], s[h], y[e]), !!a
                        }

                        function r(e, t) {
                            var i, r, o;
                            for (i = 0; i < y.length; i++)
                                if (r = i + 1, r %= y.length, o = n(e, t, y[i], y[r], !0), o.length > 0) return !0;
                            return !1
                        }

                        function a(e, i) {
                            var r, o, a, s, l;
                            for (r = 0; r < _.length; r++)
                                for (o = t[_[r]], a = 0; a < o.length; a++)
                                    if (s = a + 1, s %= o.length, l = n(e, i, o[a], o[s], !0), l.length > 0) return !0;
                            return !1
                        }
                        for (var s, l, c, h, u, p, f, d, m, g, v, y = e.concat(), _ = [], x = [], b = 0, w = t.length; w > b; b++) _.push(b);
                        for (var T = 0, M = 2 * _.length; _.length > 0;) {
                            if (M--, 0 > M) {
                                console.log("Infinite Loop! Holes left:" + _.length + ", Probably Hole outside Shape!");
                                break
                            }
                            for (c = T; c < y.length; c++) {
                                h = y[c], l = -1;
                                for (var b = 0; b < _.length; b++)
                                    if (p = _[b], f = h.x + ":" + h.y + ":" + p, void 0 === x[f]) {
                                        s = t[p];
                                        for (var S = 0; S < s.length; S++)
                                            if (u = s[S], i(c, S) && !r(h, u) && !a(h, u)) {
                                                l = S, _.splice(b, 1), d = y.slice(0, c + 1), m = y.slice(c), g = s.slice(l), v = s.slice(0, l + 1), y = d.concat(g).concat(v).concat(m), T = c;
                                                break
                                            }
                                        if (l >= 0) break;
                                        x[f] = !0
                                    }
                                if (l >= 0) break
                            }
                        }
                        return y
                    }
                    for (var s, l, c, h, u, p, f = {}, d = e.concat(), m = 0, g = t.length; g > m; m++) Array.prototype.push.apply(d, t[m]);
                    for (s = 0, l = d.length; l > s; s++) u = d[s].x + ":" + d[s].y, void 0 !== f[u] && console.warn("THREE.Shape: Duplicate point", u), f[u] = s;
                    var v = a(e, t),
                        y = r.ShapeUtils.triangulate(v, !1);
                    for (s = 0, l = y.length; l > s; s++)
                        for (h = y[s], c = 0; 3 > c; c++) u = h[c].x + ":" + h[c].y, p = f[u], void 0 !== p && (h[c] = p);
                    return y.concat()
                },
                isClockWise: function(e) {
                    return r.ShapeUtils.area(e) < 0
                },
                b2: function() {
                    function e(e, t) {
                        var i = 1 - e;
                        return i * i * t
                    }

                    function t(e, t) {
                        return 2 * (1 - e) * e * t
                    }

                    function i(e, t) {
                        return e * e * t
                    }
                    return function(r, n, o, a) {
                        return e(r, n) + t(r, o) + i(r, a)
                    }
                }(),
                b3: function() {
                    function e(e, t) {
                        var i = 1 - e;
                        return i * i * i * t
                    }

                    function t(e, t) {
                        var i = 1 - e;
                        return 3 * i * i * e * t
                    }

                    function i(e, t) {
                        var i = 1 - e;
                        return 3 * i * e * e * t
                    }

                    function r(e, t) {
                        return e * e * e * t
                    }
                    return function(n, o, a, s, l) {
                        return e(n, o) + t(n, a) + i(n, s) + r(n, l)
                    }
                }()
            }, r.Curve = function() {}, r.Curve.prototype = {
                constructor: r.Curve,
                getPoint: function(e) {
                    return console.warn("THREE.Curve: Warning, getPoint() not implemented!"), null
                },
                getPointAt: function(e) {
                    var t = this.getUtoTmapping(e);
                    return this.getPoint(t)
                },
                getPoints: function(e) {
                    e || (e = 5);
                    var t, i = [];
                    for (t = 0; e >= t; t++) i.push(this.getPoint(t / e));
                    return i
                },
                getSpacedPoints: function(e) {
                    e || (e = 5);
                    var t, i = [];
                    for (t = 0; e >= t; t++) i.push(this.getPointAt(t / e));
                    return i
                },
                getLength: function() {
                    var e = this.getLengths();
                    return e[e.length - 1]
                },
                getLengths: function(e) {
                    if (e || (e = this.__arcLengthDivisions ? this.__arcLengthDivisions : 200), this.cacheArcLengths && this.cacheArcLengths.length === e + 1 && !this.needsUpdate) return this.cacheArcLengths;
                    this.needsUpdate = !1;
                    var t, i, r = [],
                        n = this.getPoint(0),
                        o = 0;
                    for (r.push(0), i = 1; e >= i; i++) t = this.getPoint(i / e), o += t.distanceTo(n), r.push(o), n = t;
                    return this.cacheArcLengths = r, r
                },
                updateArcLengths: function() {
                    this.needsUpdate = !0, this.getLengths()
                },
                getUtoTmapping: function(e, t) {
                    var i, r = this.getLengths(),
                        n = 0,
                        o = r.length;
                    i = t ? t : e * r[o - 1];
                    for (var a, s = 0, l = o - 1; l >= s;)
                        if (n = Math.floor(s + (l - s) / 2), a = r[n] - i, 0 > a) s = n + 1;
                        else {
                            if (!(a > 0)) {
                                l = n;
                                break
                            }
                            l = n - 1
                        }
                    if (n = l, r[n] === i) {
                        var c = n / (o - 1);
                        return c
                    }
                    var h = r[n],
                        u = r[n + 1],
                        p = u - h,
                        f = (i - h) / p,
                        c = (n + f) / (o - 1);
                    return c
                },
                getTangent: function(e) {
                    var t = 1e-4,
                        i = e - t,
                        r = e + t;
                    0 > i && (i = 0), r > 1 && (r = 1);
                    var n = this.getPoint(i),
                        o = this.getPoint(r),
                        a = o.clone().sub(n);
                    return a.normalize()
                },
                getTangentAt: function(e) {
                    var t = this.getUtoTmapping(e);
                    return this.getTangent(t)
                }
            }, r.Curve.create = function(e, t) {
                return e.prototype = Object.create(r.Curve.prototype), e.prototype.constructor = e, e.prototype.getPoint = t, e
            }, r.CurvePath = function() {
                this.curves = [], this.autoClose = !1
            }, r.CurvePath.prototype = Object.create(r.Curve.prototype), r.CurvePath.prototype.constructor = r.CurvePath, r.CurvePath.prototype.add = function(e) {
                this.curves.push(e)
            }, r.CurvePath.prototype.closePath = function() {
                var e = this.curves[0].getPoint(0),
                    t = this.curves[this.curves.length - 1].getPoint(1);
                e.equals(t) || this.curves.push(new r.LineCurve(t, e))
            }, r.CurvePath.prototype.getPoint = function(e) {
                for (var t = e * this.getLength(), i = this.getCurveLengths(), r = 0; r < i.length;) {
                    if (i[r] >= t) {
                        var n = i[r] - t,
                            o = this.curves[r],
                            a = 1 - n / o.getLength();
                        return o.getPointAt(a)
                    }
                    r++
                }
                return null
            }, r.CurvePath.prototype.getLength = function() {
                var e = this.getCurveLengths();
                return e[e.length - 1]
            }, r.CurvePath.prototype.getCurveLengths = function() {
                if (this.cacheLengths && this.cacheLengths.length === this.curves.length) return this.cacheLengths;
                for (var e = [], t = 0, i = 0, r = this.curves.length; r > i; i++) t += this.curves[i].getLength(), e.push(t);
                return this.cacheLengths = e, e
            }, r.CurvePath.prototype.createPointsGeometry = function(e) {
                var t = this.getPoints(e);
                return this.createGeometry(t)
            }, r.CurvePath.prototype.createSpacedPointsGeometry = function(e) {
                var t = this.getSpacedPoints(e);
                return this.createGeometry(t)
            }, r.CurvePath.prototype.createGeometry = function(e) {
                for (var t = new r.Geometry, i = 0, n = e.length; n > i; i++) {
                    var o = e[i];
                    t.vertices.push(new r.Vector3(o.x, o.y, o.z || 0))
                }
                return t
            }, r.Font = function(e) {
                this.data = e
            }, r.Font.prototype = {
                constructor: r.Font,
                generateShapes: function(e, t, i) {
                    function n(e) {
                        for (var i = String(e).split(""), r = t / a.resolution, n = 0, s = [], l = 0; l < i.length; l++) {
                            var c = o(i[l], r, n);
                            n += c.offset, s.push(c.path)
                        }
                        return s
                    }

                    function o(e, t, n) {
                        var o = a.glyphs[e] || a.glyphs["?"];
                        if (o) {
                            var s, l, c, h, u, p, f, d, m, g, v, y = new r.Path,
                                _ = [],
                                x = r.ShapeUtils.b2,
                                b = r.ShapeUtils.b3;
                            if (o.o)
                                for (var w = o._cachedOutline || (o._cachedOutline = o.o.split(" ")), T = 0, M = w.length; M > T;) {
                                    var S = w[T++];
                                    switch (S) {
                                        case "m":
                                            s = w[T++] * t + n, l = w[T++] * t, y.moveTo(s, l);
                                            break;
                                        case "l":
                                            s = w[T++] * t + n, l = w[T++] * t, y.lineTo(s, l);
                                            break;
                                        case "q":
                                            if (c = w[T++] * t + n, h = w[T++] * t, f = w[T++] * t + n, d = w[T++] * t, y.quadraticCurveTo(f, d, c, h), v = _[_.length - 1]) {
                                                u = v.x, p = v.y;
                                                for (var E = 1; i >= E; E++) {
                                                    var A = E / i;
                                                    x(A, u, f, c), x(A, p, d, h)
                                                }
                                            }
                                            break;
                                        case "b":
                                            if (c = w[T++] * t + n, h = w[T++] * t, f = w[T++] * t + n, d = w[T++] * t, m = w[T++] * t + n, g = w[T++] * t, y.bezierCurveTo(f, d, m, g, c, h), v = _[_.length - 1]) {
                                                u = v.x, p = v.y;
                                                for (var E = 1; i >= E; E++) {
                                                    var A = E / i;
                                                    b(A, u, f, m, c), b(A, p, d, g, h)
                                                }
                                            }
                                    }
                                }
                            return {
                                offset: o.ha * t,
                                path: y
                            }
                        }
                    }
                    void 0 === t && (t = 100), void 0 === i && (i = 4);
                    for (var a = this.data, s = n(e), l = [], c = 0, h = s.length; h > c; c++) Array.prototype.push.apply(l, s[c].toShapes());
                    return l
                }
            }, r.Path = function(e) {
                r.CurvePath.call(this), this.actions = [], e && this.fromPoints(e)
            }, r.Path.prototype = Object.create(r.CurvePath.prototype), r.Path.prototype.constructor = r.Path, r.Path.prototype.fromPoints = function(e) {
                this.moveTo(e[0].x, e[0].y);
                for (var t = 1, i = e.length; i > t; t++) this.lineTo(e[t].x, e[t].y)
            }, r.Path.prototype.moveTo = function(e, t) {
                this.actions.push({
                    action: "moveTo",
                    args: [e, t]
                })
            }, r.Path.prototype.lineTo = function(e, t) {
                var i = this.actions[this.actions.length - 1].args,
                    n = i[i.length - 2],
                    o = i[i.length - 1],
                    a = new r.LineCurve(new r.Vector2(n, o), new r.Vector2(e, t));
                this.curves.push(a), this.actions.push({
                    action: "lineTo",
                    args: [e, t]
                })
            }, r.Path.prototype.quadraticCurveTo = function(e, t, i, n) {
                var o = this.actions[this.actions.length - 1].args,
                    a = o[o.length - 2],
                    s = o[o.length - 1],
                    l = new r.QuadraticBezierCurve(new r.Vector2(a, s), new r.Vector2(e, t), new r.Vector2(i, n));
                this.curves.push(l), this.actions.push({
                    action: "quadraticCurveTo",
                    args: [e, t, i, n]
                })
            }, r.Path.prototype.bezierCurveTo = function(e, t, i, n, o, a) {
                var s = this.actions[this.actions.length - 1].args,
                    l = s[s.length - 2],
                    c = s[s.length - 1],
                    h = new r.CubicBezierCurve(new r.Vector2(l, c), new r.Vector2(e, t), new r.Vector2(i, n), new r.Vector2(o, a));
                this.curves.push(h), this.actions.push({
                    action: "bezierCurveTo",
                    args: [e, t, i, n, o, a]
                })
            }, r.Path.prototype.splineThru = function(e) {
                var t = Array.prototype.slice.call(arguments),
                    i = this.actions[this.actions.length - 1].args,
                    n = i[i.length - 2],
                    o = i[i.length - 1],
                    a = [new r.Vector2(n, o)];
                Array.prototype.push.apply(a, e);
                var s = new r.SplineCurve(a);
                this.curves.push(s), this.actions.push({
                    action: "splineThru",
                    args: t
                })
            }, r.Path.prototype.arc = function(e, t, i, r, n, o) {
                var a = this.actions[this.actions.length - 1].args,
                    s = a[a.length - 2],
                    l = a[a.length - 1];
                this.absarc(e + s, t + l, i, r, n, o)
            }, r.Path.prototype.absarc = function(e, t, i, r, n, o) {
                this.absellipse(e, t, i, i, r, n, o)
            }, r.Path.prototype.ellipse = function(e, t, i, r, n, o, a, s) {
                var l = this.actions[this.actions.length - 1].args,
                    c = l[l.length - 2],
                    h = l[l.length - 1];
                this.absellipse(e + c, t + h, i, r, n, o, a, s)
            }, r.Path.prototype.absellipse = function(e, t, i, n, o, a, s, l) {
                var c = [e, t, i, n, o, a, s, l || 0],
                    h = new r.EllipseCurve(e, t, i, n, o, a, s, l);
                this.curves.push(h);
                var u = h.getPoint(1);
                c.push(u.x), c.push(u.y), this.actions.push({
                    action: "ellipse",
                    args: c
                })
            }, r.Path.prototype.getSpacedPoints = function(e) {
                e || (e = 40);
                for (var t = [], i = 0; e > i; i++) t.push(this.getPoint(i / e));
                return this.autoClose && t.push(t[0]), t
            }, r.Path.prototype.getPoints = function(e) {
                e = e || 12;
                for (var t, i, n, o, a, s, l, c, h, u, p, f = r.ShapeUtils.b2, d = r.ShapeUtils.b3, m = [], g = 0, v = this.actions.length; v > g; g++) {
                    var y = this.actions[g],
                        _ = y.action,
                        x = y.args;
                    switch (_) {
                        case "moveTo":
                            m.push(new r.Vector2(x[0], x[1]));
                            break;
                        case "lineTo":
                            m.push(new r.Vector2(x[0], x[1]));
                            break;
                        case "quadraticCurveTo":
                            t = x[2], i = x[3], a = x[0], s = x[1], m.length > 0 ? (h = m[m.length - 1], l = h.x, c = h.y) : (h = this.actions[g - 1].args, l = h[h.length - 2], c = h[h.length - 1]);
                            for (var b = 1; e >= b; b++) {
                                var w = b / e;
                                u = f(w, l, a, t), p = f(w, c, s, i), m.push(new r.Vector2(u, p))
                            }
                            break;
                        case "bezierCurveTo":
                            t = x[4], i = x[5], a = x[0], s = x[1], n = x[2], o = x[3], m.length > 0 ? (h = m[m.length - 1], l = h.x, c = h.y) : (h = this.actions[g - 1].args, l = h[h.length - 2], c = h[h.length - 1]);
                            for (var b = 1; e >= b; b++) {
                                var w = b / e;
                                u = d(w, l, a, n, t), p = d(w, c, s, o, i), m.push(new r.Vector2(u, p))
                            }
                            break;
                        case "splineThru":
                            h = this.actions[g - 1].args;
                            var T = new r.Vector2(h[h.length - 2], h[h.length - 1]),
                                M = [T],
                                S = e * x[0].length;
                            M = M.concat(x[0]);
                            for (var E = new r.SplineCurve(M), b = 1; S >= b; b++) m.push(E.getPointAt(b / S));
                            break;
                        case "arc":
                            for (var A, C = x[0], L = x[1], P = x[2], R = x[3], D = x[4], O = !!x[5], I = D - R, F = 2 * e, b = 1; F >= b; b++) {
                                var w = b / F;
                                O || (w = 1 - w), A = R + w * I, u = C + P * Math.cos(A), p = L + P * Math.sin(A), m.push(new r.Vector2(u, p))
                            }
                            break;
                        case "ellipse":
                            var A, N, B, C = x[0],
                                L = x[1],
                                k = x[2],
                                U = x[3],
                                R = x[4],
                                D = x[5],
                                O = !!x[6],
                                V = x[7],
                                I = D - R,
                                F = 2 * e;
                            0 !== V && (N = Math.cos(V), B = Math.sin(V));
                            for (var b = 1; F >= b; b++) {
                                var w = b / F;
                                if (O || (w = 1 - w), A = R + w * I, u = C + k * Math.cos(A), p = L + U * Math.sin(A), 0 !== V) {
                                    var z = u,
                                        G = p;
                                    u = (z - C) * N - (G - L) * B + C, p = (z - C) * B + (G - L) * N + L
                                }
                                m.push(new r.Vector2(u, p))
                            }
                    }
                }
                var H = m[m.length - 1];
                return Math.abs(H.x - m[0].x) < Number.EPSILON && Math.abs(H.y - m[0].y) < Number.EPSILON && m.splice(m.length - 1, 1), this.autoClose && m.push(m[0]), m
            }, r.Path.prototype.toShapes = function(e, t) {
                function i(e) {
                    for (var t = [], i = new r.Path, n = 0, o = e.length; o > n; n++) {
                        var a = e[n],
                            s = a.args,
                            l = a.action;
                        "moveTo" === l && 0 !== i.actions.length && (t.push(i), i = new r.Path), i[l].apply(i, s)
                    }
                    return 0 !== i.actions.length && t.push(i), t
                }

                function n(e) {
                    for (var t = [], i = 0, n = e.length; n > i; i++) {
                        var o = e[i],
                            a = new r.Shape;
                        a.actions = o.actions, a.curves = o.curves, t.push(a)
                    }
                    return t
                }

                function o(e, t) {
                    for (var i = t.length, r = !1, n = i - 1, o = 0; i > o; n = o++) {
                        var a = t[n],
                            s = t[o],
                            l = s.x - a.x,
                            c = s.y - a.y;
                        if (Math.abs(c) > Number.EPSILON) {
                            if (0 > c && (a = t[o], l = -l, s = t[n], c = -c), e.y < a.y || e.y > s.y) continue;
                            if (e.y === a.y) {
                                if (e.x === a.x) return !0
                            } else {
                                var h = c * (e.x - a.x) - l * (e.y - a.y);
                                if (0 === h) return !0;
                                if (0 > h) continue;
                                r = !r
                            }
                        } else {
                            if (e.y !== a.y) continue;
                            if (s.x <= e.x && e.x <= a.x || a.x <= e.x && e.x <= s.x) return !0
                        }
                    }
                    return r
                }
                var a = r.ShapeUtils.isClockWise,
                    s = i(this.actions);
                if (0 === s.length) return [];
                if (t === !0) return n(s);
                var l, c, h, u = [];
                if (1 === s.length) return c = s[0], h = new r.Shape, h.actions = c.actions, h.curves = c.curves, u.push(h), u;
                var p = !a(s[0].getPoints());
                p = e ? !p : p;
                var f, d = [],
                    m = [],
                    g = [],
                    v = 0;
                m[v] = void 0, g[v] = [];
                for (var y = 0, _ = s.length; _ > y; y++) c = s[y], f = c.getPoints(), l = a(f), l = e ? !l : l, l ? (!p && m[v] && v++, m[v] = {
                    s: new r.Shape,
                    p: f
                }, m[v].s.actions = c.actions, m[v].s.curves = c.curves, p && v++, g[v] = []) : g[v].push({
                    h: c,
                    p: f[0]
                });
                if (!m[0]) return n(s);
                if (m.length > 1) {
                    for (var x = !1, b = [], w = 0, T = m.length; T > w; w++) d[w] = [];
                    for (var w = 0, T = m.length; T > w; w++)
                        for (var M = g[w], S = 0; S < M.length; S++) {
                            for (var E = M[S], A = !0, C = 0; C < m.length; C++) o(E.p, m[C].p) && (w !== C && b.push({
                                froms: w,
                                tos: C,
                                hole: S
                            }), A ? (A = !1, d[C].push(E)) : x = !0);
                            A && d[w].push(E)
                        }
                    b.length > 0 && (x || (g = d))
                }
                for (var L, y = 0, P = m.length; P > y; y++) {
                    h = m[y].s, u.push(h), L = g[y];
                    for (var R = 0, D = L.length; D > R; R++) h.holes.push(L[R].h)
                }
                return u
            }, r.Shape = function() {
                r.Path.apply(this, arguments), this.holes = []
            }, r.Shape.prototype = Object.create(r.Path.prototype), r.Shape.prototype.constructor = r.Shape, r.Shape.prototype.extrude = function(e) {
                return new r.ExtrudeGeometry(this, e)
            }, r.Shape.prototype.makeGeometry = function(e) {
                return new r.ShapeGeometry(this, e)
            }, r.Shape.prototype.getPointsHoles = function(e) {
                for (var t = [], i = 0, r = this.holes.length; r > i; i++) t[i] = this.holes[i].getPoints(e);
                return t
            }, r.Shape.prototype.extractAllPoints = function(e) {
                return {
                    shape: this.getPoints(e),
                    holes: this.getPointsHoles(e)
                }
            }, r.Shape.prototype.extractPoints = function(e) {
                return this.extractAllPoints(e)
            }, r.LineCurve = function(e, t) {
                this.v1 = e, this.v2 = t
            }, r.LineCurve.prototype = Object.create(r.Curve.prototype), r.LineCurve.prototype.constructor = r.LineCurve, r.LineCurve.prototype.getPoint = function(e) {
                var t = this.v2.clone().sub(this.v1);
                return t.multiplyScalar(e).add(this.v1), t
            }, r.LineCurve.prototype.getPointAt = function(e) {
                return this.getPoint(e)
            }, r.LineCurve.prototype.getTangent = function(e) {
                var t = this.v2.clone().sub(this.v1);
                return t.normalize()
            }, r.QuadraticBezierCurve = function(e, t, i) {
                this.v0 = e, this.v1 = t, this.v2 = i
            }, r.QuadraticBezierCurve.prototype = Object.create(r.Curve.prototype), r.QuadraticBezierCurve.prototype.constructor = r.QuadraticBezierCurve, r.QuadraticBezierCurve.prototype.getPoint = function(e) {
                var t = r.ShapeUtils.b2;
                return new r.Vector2(t(e, this.v0.x, this.v1.x, this.v2.x), t(e, this.v0.y, this.v1.y, this.v2.y))
            }, r.QuadraticBezierCurve.prototype.getTangent = function(e) {
                var t = r.CurveUtils.tangentQuadraticBezier;
                return new r.Vector2(t(e, this.v0.x, this.v1.x, this.v2.x), t(e, this.v0.y, this.v1.y, this.v2.y)).normalize()
            }, r.CubicBezierCurve = function(e, t, i, r) {
                this.v0 = e, this.v1 = t, this.v2 = i, this.v3 = r
            }, r.CubicBezierCurve.prototype = Object.create(r.Curve.prototype), r.CubicBezierCurve.prototype.constructor = r.CubicBezierCurve, r.CubicBezierCurve.prototype.getPoint = function(e) {
                var t = r.ShapeUtils.b3;
                return new r.Vector2(t(e, this.v0.x, this.v1.x, this.v2.x, this.v3.x), t(e, this.v0.y, this.v1.y, this.v2.y, this.v3.y))
            }, r.CubicBezierCurve.prototype.getTangent = function(e) {
                var t = r.CurveUtils.tangentCubicBezier;
                return new r.Vector2(t(e, this.v0.x, this.v1.x, this.v2.x, this.v3.x), t(e, this.v0.y, this.v1.y, this.v2.y, this.v3.y)).normalize()
            }, r.SplineCurve = function(e) {
                this.points = void 0 == e ? [] : e
            }, r.SplineCurve.prototype = Object.create(r.Curve.prototype), r.SplineCurve.prototype.constructor = r.SplineCurve, r.SplineCurve.prototype.getPoint = function(e) {
                var t = this.points,
                    i = (t.length - 1) * e,
                    n = Math.floor(i),
                    o = i - n,
                    a = t[0 === n ? n : n - 1],
                    s = t[n],
                    l = t[n > t.length - 2 ? t.length - 1 : n + 1],
                    c = t[n > t.length - 3 ? t.length - 1 : n + 2],
                    h = r.CurveUtils.interpolate;
                return new r.Vector2(h(a.x, s.x, l.x, c.x, o), h(a.y, s.y, l.y, c.y, o));
            }, r.EllipseCurve = function(e, t, i, r, n, o, a, s) {
                this.aX = e, this.aY = t, this.xRadius = i, this.yRadius = r, this.aStartAngle = n, this.aEndAngle = o, this.aClockwise = a, this.aRotation = s || 0
            }, r.EllipseCurve.prototype = Object.create(r.Curve.prototype), r.EllipseCurve.prototype.constructor = r.EllipseCurve, r.EllipseCurve.prototype.getPoint = function(e) {
                var t = this.aEndAngle - this.aStartAngle;
                0 > t && (t += 2 * Math.PI), t > 2 * Math.PI && (t -= 2 * Math.PI);
                var i;
                i = this.aClockwise === !0 ? this.aEndAngle + (1 - e) * (2 * Math.PI - t) : this.aStartAngle + e * t;
                var n = this.aX + this.xRadius * Math.cos(i),
                    o = this.aY + this.yRadius * Math.sin(i);
                if (0 !== this.aRotation) {
                    var a = Math.cos(this.aRotation),
                        s = Math.sin(this.aRotation),
                        l = n,
                        c = o;
                    n = (l - this.aX) * a - (c - this.aY) * s + this.aX, o = (l - this.aX) * s + (c - this.aY) * a + this.aY
                }
                return new r.Vector2(n, o)
            }, r.ArcCurve = function(e, t, i, n, o, a) {
                r.EllipseCurve.call(this, e, t, i, i, n, o, a)
            }, r.ArcCurve.prototype = Object.create(r.EllipseCurve.prototype), r.ArcCurve.prototype.constructor = r.ArcCurve, r.LineCurve3 = r.Curve.create(function(e, t) {
                this.v1 = e, this.v2 = t
            }, function(e) {
                var t = new r.Vector3;
                return t.subVectors(this.v2, this.v1), t.multiplyScalar(e), t.add(this.v1), t
            }), r.QuadraticBezierCurve3 = r.Curve.create(function(e, t, i) {
                this.v0 = e, this.v1 = t, this.v2 = i
            }, function(e) {
                var t = r.ShapeUtils.b2;
                return new r.Vector3(t(e, this.v0.x, this.v1.x, this.v2.x), t(e, this.v0.y, this.v1.y, this.v2.y), t(e, this.v0.z, this.v1.z, this.v2.z))
            }), r.CubicBezierCurve3 = r.Curve.create(function(e, t, i, r) {
                this.v0 = e, this.v1 = t, this.v2 = i, this.v3 = r
            }, function(e) {
                var t = r.ShapeUtils.b3;
                return new r.Vector3(t(e, this.v0.x, this.v1.x, this.v2.x, this.v3.x), t(e, this.v0.y, this.v1.y, this.v2.y, this.v3.y), t(e, this.v0.z, this.v1.z, this.v2.z, this.v3.z))
            }), r.SplineCurve3 = r.Curve.create(function(e) {
                console.warn("THREE.SplineCurve3 will be deprecated. Please use THREE.CatmullRomCurve3"), this.points = void 0 == e ? [] : e
            }, function(e) {
                var t = this.points,
                    i = (t.length - 1) * e,
                    n = Math.floor(i),
                    o = i - n,
                    a = t[0 == n ? n : n - 1],
                    s = t[n],
                    l = t[n > t.length - 2 ? t.length - 1 : n + 1],
                    c = t[n > t.length - 3 ? t.length - 1 : n + 2],
                    h = r.CurveUtils.interpolate;
                return new r.Vector3(h(a.x, s.x, l.x, c.x, o), h(a.y, s.y, l.y, c.y, o), h(a.z, s.z, l.z, c.z, o))
            }), r.CatmullRomCurve3 = function() {
                function e() {}
                var t = new r.Vector3,
                    i = new e,
                    n = new e,
                    o = new e;
                return e.prototype.init = function(e, t, i, r) {
                    this.c0 = e, this.c1 = i, this.c2 = -3 * e + 3 * t - 2 * i - r, this.c3 = 2 * e - 2 * t + i + r
                }, e.prototype.initNonuniformCatmullRom = function(e, t, i, r, n, o, a) {
                    var s = (t - e) / n - (i - e) / (n + o) + (i - t) / o,
                        l = (i - t) / o - (r - t) / (o + a) + (r - i) / a;
                    s *= o, l *= o, this.init(t, i, s, l)
                }, e.prototype.initCatmullRom = function(e, t, i, r, n) {
                    this.init(t, i, n * (i - e), n * (r - t))
                }, e.prototype.calc = function(e) {
                    var t = e * e,
                        i = t * e;
                    return this.c0 + this.c1 * e + this.c2 * t + this.c3 * i
                }, r.Curve.create(function(e) {
                    this.points = e || [], this.closed = !1
                }, function(e) {
                    var a, s, l, c, h = this.points;
                    c = h.length, 2 > c && console.log("duh, you need at least 2 points"), a = (c - (this.closed ? 0 : 1)) * e, s = Math.floor(a), l = a - s, this.closed ? s += s > 0 ? 0 : (Math.floor(Math.abs(s) / h.length) + 1) * h.length : 0 === l && s === c - 1 && (s = c - 2, l = 1);
                    var u, p, f, d;
                    if (this.closed || s > 0 ? u = h[(s - 1) % c] : (t.subVectors(h[0], h[1]).add(h[0]), u = t), p = h[s % c], f = h[(s + 1) % c], this.closed || c > s + 2 ? d = h[(s + 2) % c] : (t.subVectors(h[c - 1], h[c - 2]).add(h[c - 1]), d = t), void 0 === this.type || "centripetal" === this.type || "chordal" === this.type) {
                        var m = "chordal" === this.type ? .5 : .25,
                            g = Math.pow(u.distanceToSquared(p), m),
                            v = Math.pow(p.distanceToSquared(f), m),
                            y = Math.pow(f.distanceToSquared(d), m);
                        1e-4 > v && (v = 1), 1e-4 > g && (g = v), 1e-4 > y && (y = v), i.initNonuniformCatmullRom(u.x, p.x, f.x, d.x, g, v, y), n.initNonuniformCatmullRom(u.y, p.y, f.y, d.y, g, v, y), o.initNonuniformCatmullRom(u.z, p.z, f.z, d.z, g, v, y)
                    } else if ("catmullrom" === this.type) {
                        var _ = void 0 !== this.tension ? this.tension : .5;
                        i.initCatmullRom(u.x, p.x, f.x, d.x, _), n.initCatmullRom(u.y, p.y, f.y, d.y, _), o.initCatmullRom(u.z, p.z, f.z, d.z, _)
                    }
                    var x = new r.Vector3(i.calc(l), n.calc(l), o.calc(l));
                    return x
                })
            }(), r.ClosedSplineCurve3 = function(e) {
                console.warn("THREE.ClosedSplineCurve3 has been deprecated. Please use THREE.CatmullRomCurve3."), r.CatmullRomCurve3.call(this, e), this.type = "catmullrom", this.closed = !0
            }, r.ClosedSplineCurve3.prototype = Object.create(r.CatmullRomCurve3.prototype), r.BoxGeometry = function(e, t, i, n, o, a) {
                r.Geometry.call(this), this.type = "BoxGeometry", this.parameters = {
                    width: e,
                    height: t,
                    depth: i,
                    widthSegments: n,
                    heightSegments: o,
                    depthSegments: a
                }, this.fromBufferGeometry(new r.BoxBufferGeometry(e, t, i, n, o, a)), this.mergeVertices()
            }, r.BoxGeometry.prototype = Object.create(r.Geometry.prototype), r.BoxGeometry.prototype.constructor = r.BoxGeometry, r.CubeGeometry = r.BoxGeometry, r.BoxBufferGeometry = function(e, t, i, n, o, a) {
                function s(e, t, i) {
                    var r = 0;
                    return r += e * t * 2, r += e * i * 2, r += i * t * 2, 4 * r
                }

                function l(e, t, i, n, o, a, s, l, h, u, b) {
                    for (var w = a / h, T = s / u, M = a / 2, S = s / 2, E = l / 2, A = h + 1, C = u + 1, L = 0, P = 0, R = new r.Vector3, D = 0; C > D; D++)
                        for (var O = D * T - S, I = 0; A > I; I++) {
                            var F = I * w - M;
                            R[e] = F * n, R[t] = O * o, R[i] = E, f[g] = R.x, f[g + 1] = R.y, f[g + 2] = R.z, R[e] = 0, R[t] = 0, R[i] = l > 0 ? 1 : -1, d[g] = R.x, d[g + 1] = R.y, d[g + 2] = R.z, m[v] = I / h, m[v + 1] = 1 - D / u, g += 3, v += 2, L += 1
                        }
                    for (D = 0; u > D; D++)
                        for (I = 0; h > I; I++) {
                            var N = _ + I + A * D,
                                B = _ + I + A * (D + 1),
                                k = _ + (I + 1) + A * (D + 1),
                                U = _ + (I + 1) + A * D;
                            p[y] = N, p[y + 1] = B, p[y + 2] = U, p[y + 3] = B, p[y + 4] = k, p[y + 5] = U, y += 6, P += 6
                        }
                    c.addGroup(x, P, b), x += P, _ += L
                }
                r.BufferGeometry.call(this), this.type = "BoxBufferGeometry", this.parameters = {
                    width: e,
                    height: t,
                    depth: i,
                    widthSegments: n,
                    heightSegments: o,
                    depthSegments: a
                };
                var c = this;
                n = Math.floor(n) || 1, o = Math.floor(o) || 1, a = Math.floor(a) || 1;
                var h = s(n, o, a),
                    u = h / 4 * 6,
                    p = new(u > 65535 ? Uint32Array : Uint16Array)(u),
                    f = new Float32Array(3 * h),
                    d = new Float32Array(3 * h),
                    m = new Float32Array(2 * h),
                    g = 0,
                    v = 0,
                    y = 0,
                    _ = 0,
                    x = 0;
                l("z", "y", "x", -1, -1, i, t, e, a, o, 0), l("z", "y", "x", 1, -1, i, t, -e, a, o, 1), l("x", "z", "y", 1, 1, e, i, t, n, a, 2), l("x", "z", "y", 1, -1, e, i, -t, n, a, 3), l("x", "y", "z", 1, -1, e, t, i, n, o, 4), l("x", "y", "z", -1, -1, e, t, -i, n, o, 5), this.setIndex(new r.BufferAttribute(p, 1)), this.addAttribute("position", new r.BufferAttribute(f, 3)), this.addAttribute("normal", new r.BufferAttribute(d, 3)), this.addAttribute("uv", new r.BufferAttribute(m, 2))
            }, r.BoxBufferGeometry.prototype = Object.create(r.BufferGeometry.prototype), r.BoxBufferGeometry.prototype.constructor = r.BoxBufferGeometry, r.CircleGeometry = function(e, t, i, n) {
                r.Geometry.call(this), this.type = "CircleGeometry", this.parameters = {
                    radius: e,
                    segments: t,
                    thetaStart: i,
                    thetaLength: n
                }, this.fromBufferGeometry(new r.CircleBufferGeometry(e, t, i, n))
            }, r.CircleGeometry.prototype = Object.create(r.Geometry.prototype), r.CircleGeometry.prototype.constructor = r.CircleGeometry, r.CircleBufferGeometry = function(e, t, i, n) {
                r.BufferGeometry.call(this), this.type = "CircleBufferGeometry", this.parameters = {
                    radius: e,
                    segments: t,
                    thetaStart: i,
                    thetaLength: n
                }, e = e || 50, t = void 0 !== t ? Math.max(3, t) : 8, i = void 0 !== i ? i : 0, n = void 0 !== n ? n : 2 * Math.PI;
                var o = t + 2,
                    a = new Float32Array(3 * o),
                    s = new Float32Array(3 * o),
                    l = new Float32Array(2 * o);
                s[2] = 1, l[0] = .5, l[1] = .5;
                for (var c = 0, h = 3, u = 2; t >= c; c++, h += 3, u += 2) {
                    var p = i + c / t * n;
                    a[h] = e * Math.cos(p), a[h + 1] = e * Math.sin(p), s[h + 2] = 1, l[u] = (a[h] / e + 1) / 2, l[u + 1] = (a[h + 1] / e + 1) / 2
                }
                for (var f = [], h = 1; t >= h; h++) f.push(h, h + 1, 0);
                this.setIndex(new r.BufferAttribute(new Uint16Array(f), 1)), this.addAttribute("position", new r.BufferAttribute(a, 3)), this.addAttribute("normal", new r.BufferAttribute(s, 3)), this.addAttribute("uv", new r.BufferAttribute(l, 2)), this.boundingSphere = new r.Sphere(new r.Vector3, e)
            }, r.CircleBufferGeometry.prototype = Object.create(r.BufferGeometry.prototype), r.CircleBufferGeometry.prototype.constructor = r.CircleBufferGeometry, r.CylinderBufferGeometry = function(e, t, i, n, o, a, s, l) {
                function c() {
                    var e = (n + 1) * (o + 1);
                    return a === !1 && (e += 2 * (n + 1) + 2 * n), e
                }

                function h() {
                    var e = n * o * 2 * 3;
                    return a === !1 && (e += 2 * n * 3), e
                }

                function u() {
                    var a, c, h = new r.Vector3,
                        u = new r.Vector3,
                        p = (t - e) / i;
                    for (c = 0; o >= c; c++) {
                        var f = [],
                            d = c / o,
                            T = d * (t - e) + e;
                        for (a = 0; n >= a; a++) {
                            var M = a / n;
                            u.x = T * Math.sin(M * l + s), u.y = -d * i + w, u.z = T * Math.cos(M * l + s), g.setXYZ(_, u.x, u.y, u.z), h.copy(u), (0 === e && 0 === c || 0 === t && c === o) && (h.x = Math.sin(M * l + s), h.z = Math.cos(M * l + s)), h.setY(Math.sqrt(h.x * h.x + h.z * h.z) * p).normalize(), v.setXYZ(_, h.x, h.y, h.z), y.setXY(_, M, 1 - d), f.push(_), _++
                        }
                        b.push(f)
                    }
                    for (a = 0; n > a; a++)
                        for (c = 0; o > c; c++) {
                            var S = b[c][a],
                                E = b[c + 1][a],
                                A = b[c + 1][a + 1],
                                C = b[c][a + 1];
                            m.setX(x, S), x++, m.setX(x, E), x++, m.setX(x, C), x++, m.setX(x, E), x++, m.setX(x, A), x++, m.setX(x, C), x++
                        }
                }

                function p(i) {
                    var o, a, c, h = new r.Vector2,
                        u = new r.Vector3,
                        p = i === !0 ? e : t,
                        f = i === !0 ? 1 : -1;
                    for (a = _, o = 1; n >= o; o++) g.setXYZ(_, 0, w * f, 0), v.setXYZ(_, 0, f, 0), i === !0 ? (h.x = o / n, h.y = 0) : (h.x = (o - 1) / n, h.y = 1), y.setXY(_, h.x, h.y), _++;
                    for (c = _, o = 0; n >= o; o++) {
                        var d = o / n;
                        u.x = p * Math.sin(d * l + s), u.y = w * f, u.z = p * Math.cos(d * l + s), g.setXYZ(_, u.x, u.y, u.z), v.setXYZ(_, 0, f, 0), y.setXY(_, d, i === !0 ? 1 : 0), _++
                    }
                    for (o = 0; n > o; o++) {
                        var b = a + o,
                            T = c + o;
                        i === !0 ? (m.setX(x, T), x++, m.setX(x, T + 1), x++, m.setX(x, b), x++) : (m.setX(x, T + 1), x++, m.setX(x, T), x++, m.setX(x, b), x++)
                    }
                }
                r.BufferGeometry.call(this), this.type = "CylinderBufferGeometry", this.parameters = {
                    radiusTop: e,
                    radiusBottom: t,
                    height: i,
                    radialSegments: n,
                    heightSegments: o,
                    openEnded: a,
                    thetaStart: s,
                    thetaLength: l
                }, e = void 0 !== e ? e : 20, t = void 0 !== t ? t : 20, i = void 0 !== i ? i : 100, n = Math.floor(n) || 8, o = Math.floor(o) || 1, a = void 0 !== a ? a : !1, s = void 0 !== s ? s : 0, l = void 0 !== l ? l : 2 * Math.PI;
                var f = c(),
                    d = h(),
                    m = new r.BufferAttribute(new(d > 65535 ? Uint32Array : Uint16Array)(d), 1),
                    g = new r.BufferAttribute(new Float32Array(3 * f), 3),
                    v = new r.BufferAttribute(new Float32Array(3 * f), 3),
                    y = new r.BufferAttribute(new Float32Array(2 * f), 2),
                    _ = 0,
                    x = 0,
                    b = [],
                    w = i / 2;
                u(), a === !1 && (e > 0 && p(!0), t > 0 && p(!1)), this.setIndex(m), this.addAttribute("position", g), this.addAttribute("normal", v), this.addAttribute("uv", y)
            }, r.CylinderBufferGeometry.prototype = Object.create(r.BufferGeometry.prototype), r.CylinderBufferGeometry.prototype.constructor = r.CylinderBufferGeometry, r.CylinderGeometry = function(e, t, i, n, o, a, s, l) {
                r.Geometry.call(this), this.type = "CylinderGeometry", this.parameters = {
                    radiusTop: e,
                    radiusBottom: t,
                    height: i,
                    radialSegments: n,
                    heightSegments: o,
                    openEnded: a,
                    thetaStart: s,
                    thetaLength: l
                }, this.fromBufferGeometry(new r.CylinderBufferGeometry(e, t, i, n, o, a, s, l)), this.mergeVertices()
            }, r.CylinderGeometry.prototype = Object.create(r.Geometry.prototype), r.CylinderGeometry.prototype.constructor = r.CylinderGeometry, r.EdgesGeometry = function(e, t) {
                function i(e, t) {
                    return e - t
                }
                r.BufferGeometry.call(this), t = void 0 !== t ? t : 1;
                var n, o = Math.cos(r.Math.degToRad(t)),
                    a = [0, 0],
                    s = {},
                    l = ["a", "b", "c"];
                e instanceof r.BufferGeometry ? (n = new r.Geometry, n.fromBufferGeometry(e)) : n = e.clone(), n.mergeVertices(), n.computeFaceNormals();
                for (var c = n.vertices, h = n.faces, u = 0, p = h.length; p > u; u++)
                    for (var f = h[u], d = 0; 3 > d; d++) {
                        a[0] = f[l[d]], a[1] = f[l[(d + 1) % 3]], a.sort(i);
                        var m = a.toString();
                        void 0 === s[m] ? s[m] = {
                            vert1: a[0],
                            vert2: a[1],
                            face1: u,
                            face2: void 0
                        } : s[m].face2 = u
                    }
                var g = [];
                for (var m in s) {
                    var v = s[m];
                    if (void 0 === v.face2 || h[v.face1].normal.dot(h[v.face2].normal) <= o) {
                        var y = c[v.vert1];
                        g.push(y.x), g.push(y.y), g.push(y.z), y = c[v.vert2], g.push(y.x), g.push(y.y), g.push(y.z)
                    }
                }
                this.addAttribute("position", new r.BufferAttribute(new Float32Array(g), 3))
            }, r.EdgesGeometry.prototype = Object.create(r.BufferGeometry.prototype), r.EdgesGeometry.prototype.constructor = r.EdgesGeometry, r.ExtrudeGeometry = function(e, t) {
                return "undefined" == typeof e ? void(e = []) : (r.Geometry.call(this), this.type = "ExtrudeGeometry", e = Array.isArray(e) ? e : [e], this.addShapeList(e, t), void this.computeFaceNormals())
            }, r.ExtrudeGeometry.prototype = Object.create(r.Geometry.prototype), r.ExtrudeGeometry.prototype.constructor = r.ExtrudeGeometry, r.ExtrudeGeometry.prototype.addShapeList = function(e, t) {
                for (var i = e.length, r = 0; i > r; r++) {
                    var n = e[r];
                    this.addShape(n, t)
                }
            }, r.ExtrudeGeometry.prototype.addShape = function(e, t) {
                function i(e, t, i) {
                    return t || console.error("THREE.ExtrudeGeometry: vec does not exist"), t.clone().multiplyScalar(i).add(e)
                }

                function n(e, t, i) {
                    var n, o, a = 1,
                        s = e.x - t.x,
                        l = e.y - t.y,
                        c = i.x - e.x,
                        h = i.y - e.y,
                        u = s * s + l * l,
                        p = s * h - l * c;
                    if (Math.abs(p) > Number.EPSILON) {
                        var f = Math.sqrt(u),
                            d = Math.sqrt(c * c + h * h),
                            m = t.x - l / f,
                            g = t.y + s / f,
                            v = i.x - h / d,
                            y = i.y + c / d,
                            _ = ((v - m) * h - (y - g) * c) / (s * h - l * c);
                        n = m + s * _ - e.x, o = g + l * _ - e.y;
                        var x = n * n + o * o;
                        if (2 >= x) return new r.Vector2(n, o);
                        a = Math.sqrt(x / 2)
                    } else {
                        var b = !1;
                        s > Number.EPSILON ? c > Number.EPSILON && (b = !0) : s < -Number.EPSILON ? c < -Number.EPSILON && (b = !0) : Math.sign(l) === Math.sign(h) && (b = !0), b ? (n = -l, o = s, a = Math.sqrt(u)) : (n = s, o = l, a = Math.sqrt(u / 2))
                    }
                    return new r.Vector2(n / a, o / a)
                }

                function o() {
                    if (x) {
                        var e = 0,
                            t = H * e;
                        for (X = 0; j > X; X++) G = F[X], c(G[2] + t, G[1] + t, G[0] + t);
                        for (e = w + 2 * _, t = H * e, X = 0; j > X; X++) G = F[X], c(G[0] + t, G[1] + t, G[2] + t)
                    } else {
                        for (X = 0; j > X; X++) G = F[X], c(G[2], G[1], G[0]);
                        for (X = 0; j > X; X++) G = F[X], c(G[0] + H * w, G[1] + H * w, G[2] + H * w)
                    }
                }

                function a() {
                    var e = 0;
                    for (s(N, e), e += N.length, A = 0, C = O.length; C > A; A++) E = O[A], s(E, e), e += E.length
                }

                function s(e, t) {
                    var i, r;
                    for (X = e.length; --X >= 0;) {
                        i = X, r = X - 1, 0 > r && (r = e.length - 1);
                        var n = 0,
                            o = w + 2 * _;
                        for (n = 0; o > n; n++) {
                            var a = H * n,
                                s = H * (n + 1),
                                l = t + i + a,
                                c = t + r + a,
                                u = t + r + s,
                                p = t + i + s;
                            h(l, c, u, p, e, n, o, i, r)
                        }
                    }
                }

                function l(e, t, i) {
                    L.vertices.push(new r.Vector3(e, t, i))
                }

                function c(e, t, i) {
                    e += P, t += P, i += P, L.faces.push(new r.Face3(e, t, i, null, null, 0));
                    var n = S.generateTopUV(L, e, t, i);
                    L.faceVertexUvs[0].push(n)
                }

                function h(e, t, i, n, o, a, s, l, c) {
                    e += P, t += P, i += P, n += P, L.faces.push(new r.Face3(e, t, n, null, null, 1)), L.faces.push(new r.Face3(t, i, n, null, null, 1));
                    var h = S.generateSideWallUV(L, e, t, i, n);
                    L.faceVertexUvs[0].push([h[0], h[1], h[3]]), L.faceVertexUvs[0].push([h[1], h[2], h[3]])
                }
                var u, p, f, d, m, g = void 0 !== t.amount ? t.amount : 100,
                    v = void 0 !== t.bevelThickness ? t.bevelThickness : 6,
                    y = void 0 !== t.bevelSize ? t.bevelSize : v - 2,
                    _ = void 0 !== t.bevelSegments ? t.bevelSegments : 3,
                    x = void 0 !== t.bevelEnabled ? t.bevelEnabled : !0,
                    b = void 0 !== t.curveSegments ? t.curveSegments : 12,
                    w = void 0 !== t.steps ? t.steps : 1,
                    T = t.extrudePath,
                    M = !1,
                    S = void 0 !== t.UVGenerator ? t.UVGenerator : r.ExtrudeGeometry.WorldUVGenerator;
                T && (u = T.getSpacedPoints(w), M = !0, x = !1, p = void 0 !== t.frames ? t.frames : new r.TubeGeometry.FrenetFrames(T, w, !1), f = new r.Vector3, d = new r.Vector3, m = new r.Vector3), x || (_ = 0, v = 0, y = 0);
                var E, A, C, L = this,
                    P = this.vertices.length,
                    R = e.extractPoints(b),
                    D = R.shape,
                    O = R.holes,
                    I = !r.ShapeUtils.isClockWise(D);
                if (I) {
                    for (D = D.reverse(), A = 0, C = O.length; C > A; A++) E = O[A], r.ShapeUtils.isClockWise(E) && (O[A] = E.reverse());
                    I = !1
                }
                var F = r.ShapeUtils.triangulateShape(D, O),
                    N = D;
                for (A = 0, C = O.length; C > A; A++) E = O[A], D = D.concat(E);
                for (var B, k, U, V, z, G, H = D.length, j = F.length, W = [], X = 0, q = N.length, Y = q - 1, Z = X + 1; q > X; X++, Y++, Z++) Y === q && (Y = 0), Z === q && (Z = 0), W[X] = n(N[X], N[Y], N[Z]);
                var Q, K = [],
                    $ = W.concat();
                for (A = 0, C = O.length; C > A; A++) {
                    for (E = O[A], Q = [], X = 0, q = E.length, Y = q - 1, Z = X + 1; q > X; X++, Y++, Z++) Y === q && (Y = 0), Z === q && (Z = 0), Q[X] = n(E[X], E[Y], E[Z]);
                    K.push(Q), $ = $.concat(Q)
                }
                for (B = 0; _ > B; B++) {
                    for (U = B / _, V = v * (1 - U), k = y * Math.sin(U * Math.PI / 2), X = 0, q = N.length; q > X; X++) z = i(N[X], W[X], k), l(z.x, z.y, -V);
                    for (A = 0, C = O.length; C > A; A++)
                        for (E = O[A], Q = K[A], X = 0, q = E.length; q > X; X++) z = i(E[X], Q[X], k), l(z.x, z.y, -V)
                }
                for (k = y, X = 0; H > X; X++) z = x ? i(D[X], $[X], k) : D[X], M ? (d.copy(p.normals[0]).multiplyScalar(z.x), f.copy(p.binormals[0]).multiplyScalar(z.y), m.copy(u[0]).add(d).add(f), l(m.x, m.y, m.z)) : l(z.x, z.y, 0);
                var J;
                for (J = 1; w >= J; J++)
                    for (X = 0; H > X; X++) z = x ? i(D[X], $[X], k) : D[X], M ? (d.copy(p.normals[J]).multiplyScalar(z.x), f.copy(p.binormals[J]).multiplyScalar(z.y), m.copy(u[J]).add(d).add(f), l(m.x, m.y, m.z)) : l(z.x, z.y, g / w * J);
                for (B = _ - 1; B >= 0; B--) {
                    for (U = B / _, V = v * (1 - U), k = y * Math.sin(U * Math.PI / 2), X = 0, q = N.length; q > X; X++) z = i(N[X], W[X], k), l(z.x, z.y, g + V);
                    for (A = 0, C = O.length; C > A; A++)
                        for (E = O[A], Q = K[A], X = 0, q = E.length; q > X; X++) z = i(E[X], Q[X], k), M ? l(z.x, z.y + u[w - 1].y, u[w - 1].x + V) : l(z.x, z.y, g + V)
                }
                o(), a()
            }, r.ExtrudeGeometry.WorldUVGenerator = {
                generateTopUV: function(e, t, i, n) {
                    var o = e.vertices,
                        a = o[t],
                        s = o[i],
                        l = o[n];
                    return [new r.Vector2(a.x, a.y), new r.Vector2(s.x, s.y), new r.Vector2(l.x, l.y)]
                },
                generateSideWallUV: function(e, t, i, n, o) {
                    var a = e.vertices,
                        s = a[t],
                        l = a[i],
                        c = a[n],
                        h = a[o];
                    return Math.abs(s.y - l.y) < .01 ? [new r.Vector2(s.x, 1 - s.z), new r.Vector2(l.x, 1 - l.z), new r.Vector2(c.x, 1 - c.z), new r.Vector2(h.x, 1 - h.z)] : [new r.Vector2(s.y, 1 - s.z), new r.Vector2(l.y, 1 - l.z), new r.Vector2(c.y, 1 - c.z), new r.Vector2(h.y, 1 - h.z)]
                }
            }, r.ShapeGeometry = function(e, t) {
                r.Geometry.call(this), this.type = "ShapeGeometry", Array.isArray(e) === !1 && (e = [e]), this.addShapeList(e, t), this.computeFaceNormals()
            }, r.ShapeGeometry.prototype = Object.create(r.Geometry.prototype), r.ShapeGeometry.prototype.constructor = r.ShapeGeometry, r.ShapeGeometry.prototype.addShapeList = function(e, t) {
                for (var i = 0, r = e.length; r > i; i++) this.addShape(e[i], t);
                return this
            }, r.ShapeGeometry.prototype.addShape = function(e, t) {
                void 0 === t && (t = {});
                var i, n, o, a = void 0 !== t.curveSegments ? t.curveSegments : 12,
                    s = t.material,
                    l = void 0 === t.UVGenerator ? r.ExtrudeGeometry.WorldUVGenerator : t.UVGenerator,
                    c = this.vertices.length,
                    h = e.extractPoints(a),
                    u = h.shape,
                    p = h.holes,
                    f = !r.ShapeUtils.isClockWise(u);
                if (f) {
                    for (u = u.reverse(), i = 0, n = p.length; n > i; i++) o = p[i], r.ShapeUtils.isClockWise(o) && (p[i] = o.reverse());
                    f = !1
                }
                var d = r.ShapeUtils.triangulateShape(u, p);
                for (i = 0, n = p.length; n > i; i++) o = p[i], u = u.concat(o);
                var m, g, v = u.length,
                    y = d.length;
                for (i = 0; v > i; i++) m = u[i], this.vertices.push(new r.Vector3(m.x, m.y, 0));
                for (i = 0; y > i; i++) {
                    g = d[i];
                    var _ = g[0] + c,
                        x = g[1] + c,
                        b = g[2] + c;
                    this.faces.push(new r.Face3(_, x, b, null, null, s)), this.faceVertexUvs[0].push(l.generateTopUV(this, _, x, b))
                }
            }, r.LatheBufferGeometry = function(e, t, i, n) {
                r.BufferGeometry.call(this), this.type = "LatheBufferGeometry", this.parameters = {
                    points: e,
                    segments: t,
                    phiStart: i,
                    phiLength: n
                }, t = Math.floor(t) || 12, i = i || 0, n = n || 2 * Math.PI, n = r.Math.clamp(n, 0, 2 * Math.PI);
                var o, a, s, l = (t + 1) * e.length,
                    c = t * e.length * 2 * 3,
                    h = new r.BufferAttribute(new(c > 65535 ? Uint32Array : Uint16Array)(c), 1),
                    u = new r.BufferAttribute(new Float32Array(3 * l), 3),
                    p = new r.BufferAttribute(new Float32Array(2 * l), 2),
                    f = 0,
                    d = 0,
                    m = (1 / (e.length - 1), 1 / t),
                    g = new r.Vector3,
                    v = new r.Vector2;
                for (a = 0; t >= a; a++) {
                    var y = i + a * m * n,
                        _ = Math.sin(y),
                        x = Math.cos(y);
                    for (s = 0; s <= e.length - 1; s++) g.x = e[s].x * _, g.y = e[s].y, g.z = e[s].x * x, u.setXYZ(f, g.x, g.y, g.z), v.x = a / t, v.y = s / (e.length - 1), p.setXY(f, v.x, v.y), f++
                }
                for (a = 0; t > a; a++)
                    for (s = 0; s < e.length - 1; s++) {
                        o = s + a * e.length;
                        var b = o,
                            w = o + e.length,
                            T = o + e.length + 1,
                            M = o + 1;
                        h.setX(d, b), d++, h.setX(d, w), d++, h.setX(d, M), d++, h.setX(d, w), d++, h.setX(d, T), d++, h.setX(d, M), d++
                    }
                if (this.setIndex(h), this.addAttribute("position", u), this.addAttribute("uv", p), this.computeVertexNormals(), n === 2 * Math.PI) {
                    var S = this.attributes.normal.array,
                        E = new r.Vector3,
                        A = new r.Vector3,
                        C = new r.Vector3;
                    for (o = t * e.length * 3, a = 0, s = 0; a < e.length; a++, s += 3) E.x = S[s + 0], E.y = S[s + 1], E.z = S[s + 2], A.x = S[o + s + 0], A.y = S[o + s + 1], A.z = S[o + s + 2], C.addVectors(E, A).normalize(), S[s + 0] = S[o + s + 0] = C.x, S[s + 1] = S[o + s + 1] = C.y, S[s + 2] = S[o + s + 2] = C.z
                }
            }, r.LatheBufferGeometry.prototype = Object.create(r.BufferGeometry.prototype), r.LatheBufferGeometry.prototype.constructor = r.LatheBufferGeometry, r.LatheGeometry = function(e, t, i, n) {
                r.Geometry.call(this), this.type = "LatheGeometry", this.parameters = {
                    points: e,
                    segments: t,
                    phiStart: i,
                    phiLength: n
                }, this.fromBufferGeometry(new r.LatheBufferGeometry(e, t, i, n)), this.mergeVertices()
            }, r.LatheGeometry.prototype = Object.create(r.Geometry.prototype), r.LatheGeometry.prototype.constructor = r.LatheGeometry, r.PlaneGeometry = function(e, t, i, n) {
                r.Geometry.call(this), this.type = "PlaneGeometry", this.parameters = {
                    width: e,
                    height: t,
                    widthSegments: i,
                    heightSegments: n
                }, this.fromBufferGeometry(new r.PlaneBufferGeometry(e, t, i, n))
            }, r.PlaneGeometry.prototype = Object.create(r.Geometry.prototype), r.PlaneGeometry.prototype.constructor = r.PlaneGeometry, r.PlaneBufferGeometry = function(e, t, i, n) {
                r.BufferGeometry.call(this), this.type = "PlaneBufferGeometry", this.parameters = {
                    width: e,
                    height: t,
                    widthSegments: i,
                    heightSegments: n
                };
                for (var o = e / 2, a = t / 2, s = Math.floor(i) || 1, l = Math.floor(n) || 1, c = s + 1, h = l + 1, u = e / s, p = t / l, f = new Float32Array(c * h * 3), d = new Float32Array(c * h * 3), m = new Float32Array(c * h * 2), g = 0, v = 0, y = 0; h > y; y++)
                    for (var _ = y * p - a, x = 0; c > x; x++) {
                        var b = x * u - o;
                        f[g] = b, f[g + 1] = -_, d[g + 2] = 1, m[v] = x / s, m[v + 1] = 1 - y / l, g += 3, v += 2
                    }
                g = 0;
                for (var w = new(f.length / 3 > 65535 ? Uint32Array : Uint16Array)(s * l * 6), y = 0; l > y; y++)
                    for (var x = 0; s > x; x++) {
                        var T = x + c * y,
                            M = x + c * (y + 1),
                            S = x + 1 + c * (y + 1),
                            E = x + 1 + c * y;
                        w[g] = T, w[g + 1] = M, w[g + 2] = E, w[g + 3] = M, w[g + 4] = S, w[g + 5] = E, g += 6
                    }
                this.setIndex(new r.BufferAttribute(w, 1)), this.addAttribute("position", new r.BufferAttribute(f, 3)), this.addAttribute("normal", new r.BufferAttribute(d, 3)), this.addAttribute("uv", new r.BufferAttribute(m, 2))
            }, r.PlaneBufferGeometry.prototype = Object.create(r.BufferGeometry.prototype), r.PlaneBufferGeometry.prototype.constructor = r.PlaneBufferGeometry, r.RingBufferGeometry = function(e, t, i, n, o, a) {
                r.BufferGeometry.call(this), this.type = "RingBufferGeometry", this.parameters = {
                    innerRadius: e,
                    outerRadius: t,
                    thetaSegments: i,
                    phiSegments: n,
                    thetaStart: o,
                    thetaLength: a
                }, e = e || 20, t = t || 50, o = void 0 !== o ? o : 0, a = void 0 !== a ? a : 2 * Math.PI, i = void 0 !== i ? Math.max(3, i) : 8, n = void 0 !== n ? Math.max(1, n) : 1;
                var s, l, c, h = (i + 1) * (n + 1),
                    u = i * n * 2 * 3,
                    p = new r.BufferAttribute(new(u > 65535 ? Uint32Array : Uint16Array)(u), 1),
                    f = new r.BufferAttribute(new Float32Array(3 * h), 3),
                    d = new r.BufferAttribute(new Float32Array(3 * h), 3),
                    m = new r.BufferAttribute(new Float32Array(2 * h), 2),
                    g = 0,
                    v = 0,
                    y = e,
                    _ = (t - e) / n,
                    x = new r.Vector3,
                    b = new r.Vector2;
                for (l = 0; n >= l; l++) {
                    for (c = 0; i >= c; c++) s = o + c / i * a, x.x = y * Math.cos(s), x.y = y * Math.sin(s), f.setXYZ(g, x.x, x.y, x.z), d.setXYZ(g, 0, 0, 1), b.x = (x.x / t + 1) / 2, b.y = (x.y / t + 1) / 2, m.setXY(g, b.x, b.y), g++;
                    y += _
                }
                for (l = 0; n > l; l++) {
                    var w = l * (i + 1);
                    for (c = 0; i > c; c++) {
                        s = c + w;
                        var T = s,
                            M = s + i + 1,
                            S = s + i + 2,
                            E = s + 1;
                        p.setX(v, T), v++, p.setX(v, M), v++, p.setX(v, S), v++, p.setX(v, T), v++, p.setX(v, S), v++, p.setX(v, E), v++
                    }
                }
                this.setIndex(p), this.addAttribute("position", f), this.addAttribute("normal", d), this.addAttribute("uv", m)
            }, r.RingBufferGeometry.prototype = Object.create(r.BufferGeometry.prototype), r.RingBufferGeometry.prototype.constructor = r.RingBufferGeometry, r.RingGeometry = function(e, t, i, n, o, a) {
                r.Geometry.call(this), this.type = "RingGeometry", this.parameters = {
                    innerRadius: e,
                    outerRadius: t,
                    thetaSegments: i,
                    phiSegments: n,
                    thetaStart: o,
                    thetaLength: a
                }, this.fromBufferGeometry(new r.RingBufferGeometry(e, t, i, n, o, a))
            }, r.RingGeometry.prototype = Object.create(r.Geometry.prototype), r.RingGeometry.prototype.constructor = r.RingGeometry, r.SphereGeometry = function(e, t, i, n, o, a, s) {
                r.Geometry.call(this), this.type = "SphereGeometry", this.parameters = {
                    radius: e,
                    widthSegments: t,
                    heightSegments: i,
                    phiStart: n,
                    phiLength: o,
                    thetaStart: a,
                    thetaLength: s
                }, this.fromBufferGeometry(new r.SphereBufferGeometry(e, t, i, n, o, a, s))
            }, r.SphereGeometry.prototype = Object.create(r.Geometry.prototype), r.SphereGeometry.prototype.constructor = r.SphereGeometry, r.SphereBufferGeometry = function(e, t, i, n, o, a, s) {
                r.BufferGeometry.call(this), this.type = "SphereBufferGeometry", this.parameters = {
                    radius: e,
                    widthSegments: t,
                    heightSegments: i,
                    phiStart: n,
                    phiLength: o,
                    thetaStart: a,
                    thetaLength: s
                }, e = e || 50, t = Math.max(3, Math.floor(t) || 8), i = Math.max(2, Math.floor(i) || 6), n = void 0 !== n ? n : 0, o = void 0 !== o ? o : 2 * Math.PI, a = void 0 !== a ? a : 0, s = void 0 !== s ? s : Math.PI;
                for (var l = a + s, c = (t + 1) * (i + 1), h = new r.BufferAttribute(new Float32Array(3 * c), 3), u = new r.BufferAttribute(new Float32Array(3 * c), 3), p = new r.BufferAttribute(new Float32Array(2 * c), 2), f = 0, d = [], m = new r.Vector3, g = 0; i >= g; g++) {
                    for (var v = [], y = g / i, _ = 0; t >= _; _++) {
                        var x = _ / t,
                            b = -e * Math.cos(n + x * o) * Math.sin(a + y * s),
                            w = e * Math.cos(a + y * s),
                            T = e * Math.sin(n + x * o) * Math.sin(a + y * s);
                        m.set(b, w, T).normalize(), h.setXYZ(f, b, w, T), u.setXYZ(f, m.x, m.y, m.z), p.setXY(f, x, 1 - y), v.push(f), f++
                    }
                    d.push(v)
                }
                for (var M = [], g = 0; i > g; g++)
                    for (var _ = 0; t > _; _++) {
                        var S = d[g][_ + 1],
                            E = d[g][_],
                            A = d[g + 1][_],
                            C = d[g + 1][_ + 1];
                        (0 !== g || a > 0) && M.push(S, E, C), (g !== i - 1 || l < Math.PI) && M.push(E, A, C)
                    }
                this.setIndex(new(h.count > 65535 ? r.Uint32Attribute : r.Uint16Attribute)(M, 1)), this.addAttribute("position", h), this.addAttribute("normal", u), this.addAttribute("uv", p), this.boundingSphere = new r.Sphere(new r.Vector3, e)
            }, r.SphereBufferGeometry.prototype = Object.create(r.BufferGeometry.prototype), r.SphereBufferGeometry.prototype.constructor = r.SphereBufferGeometry, r.TextGeometry = function(e, t) {
                t = t || {};
                var i = t.font;
                if (i instanceof r.Font == !1) return console.error("THREE.TextGeometry: font parameter is not an instance of THREE.Font."), new r.Geometry;
                var n = i.generateShapes(e, t.size, t.curveSegments);
                t.amount = void 0 !== t.height ? t.height : 50, void 0 === t.bevelThickness && (t.bevelThickness = 10), void 0 === t.bevelSize && (t.bevelSize = 8), void 0 === t.bevelEnabled && (t.bevelEnabled = !1), r.ExtrudeGeometry.call(this, n, t), this.type = "TextGeometry"
            }, r.TextGeometry.prototype = Object.create(r.ExtrudeGeometry.prototype), r.TextGeometry.prototype.constructor = r.TextGeometry, r.TorusBufferGeometry = function(e, t, i, n, o) {
                r.BufferGeometry.call(this), this.type = "TorusBufferGeometry", this.parameters = {
                    radius: e,
                    tube: t,
                    radialSegments: i,
                    tubularSegments: n,
                    arc: o
                }, e = e || 100, t = t || 40, i = Math.floor(i) || 8, n = Math.floor(n) || 6, o = o || 2 * Math.PI;
                var a, s, l = (i + 1) * (n + 1),
                    c = i * n * 2 * 3,
                    h = new(c > 65535 ? Uint32Array : Uint16Array)(c),
                    u = new Float32Array(3 * l),
                    p = new Float32Array(3 * l),
                    f = new Float32Array(2 * l),
                    d = 0,
                    m = 0,
                    g = 0,
                    v = new r.Vector3,
                    y = new r.Vector3,
                    _ = new r.Vector3;
                for (a = 0; i >= a; a++)
                    for (s = 0; n >= s; s++) {
                        var x = s / n * o,
                            b = a / i * Math.PI * 2;
                        y.x = (e + t * Math.cos(b)) * Math.cos(x), y.y = (e + t * Math.cos(b)) * Math.sin(x), y.z = t * Math.sin(b), u[d] = y.x, u[d + 1] = y.y, u[d + 2] = y.z, v.x = e * Math.cos(x), v.y = e * Math.sin(x), _.subVectors(y, v).normalize(), p[d] = _.x, p[d + 1] = _.y, p[d + 2] = _.z, f[m] = s / n, f[m + 1] = a / i, d += 3, m += 2
                    }
                for (a = 1; i >= a; a++)
                    for (s = 1; n >= s; s++) {
                        var w = (n + 1) * a + s - 1,
                            T = (n + 1) * (a - 1) + s - 1,
                            M = (n + 1) * (a - 1) + s,
                            S = (n + 1) * a + s;
                        h[g] = w, h[g + 1] = T, h[g + 2] = S, h[g + 3] = T, h[g + 4] = M, h[g + 5] = S, g += 6
                    }
                this.setIndex(new r.BufferAttribute(h, 1)), this.addAttribute("position", new r.BufferAttribute(u, 3)), this.addAttribute("normal", new r.BufferAttribute(p, 3)), this.addAttribute("uv", new r.BufferAttribute(f, 2))
            }, r.TorusBufferGeometry.prototype = Object.create(r.BufferGeometry.prototype), r.TorusBufferGeometry.prototype.constructor = r.TorusBufferGeometry, r.TorusGeometry = function(e, t, i, n, o) {
                r.Geometry.call(this), this.type = "TorusGeometry", this.parameters = {
                    radius: e,
                    tube: t,
                    radialSegments: i,
                    tubularSegments: n,
                    arc: o
                }, this.fromBufferGeometry(new r.TorusBufferGeometry(e, t, i, n, o))
            }, r.TorusGeometry.prototype = Object.create(r.Geometry.prototype), r.TorusGeometry.prototype.constructor = r.TorusGeometry, r.TorusKnotBufferGeometry = function(e, t, i, n, o, a) {
                function s(e, t, i, r, n) {
                    var o = Math.cos(e),
                        a = Math.sin(e),
                        s = i / t * e,
                        l = Math.cos(s);
                    n.x = r * (2 + l) * .5 * o, n.y = r * (2 + l) * a * .5, n.z = r * Math.sin(s) * .5
                }
                r.BufferGeometry.call(this), this.type = "TorusKnotBufferGeometry", this.parameters = {
                    radius: e,
                    tube: t,
                    tubularSegments: i,
                    radialSegments: n,
                    p: o,
                    q: a
                }, e = e || 100, t = t || 40, i = Math.floor(i) || 64, n = Math.floor(n) || 8, o = o || 2, a = a || 3;
                var l, c, h = (n + 1) * (i + 1),
                    u = n * i * 2 * 3,
                    p = new r.BufferAttribute(new(u > 65535 ? Uint32Array : Uint16Array)(u), 1),
                    f = new r.BufferAttribute(new Float32Array(3 * h), 3),
                    d = new r.BufferAttribute(new Float32Array(3 * h), 3),
                    m = new r.BufferAttribute(new Float32Array(2 * h), 2),
                    g = 0,
                    v = 0,
                    y = new r.Vector3,
                    _ = new r.Vector3,
                    x = new r.Vector2,
                    b = new r.Vector3,
                    w = new r.Vector3,
                    T = new r.Vector3,
                    M = new r.Vector3,
                    S = new r.Vector3;
                for (l = 0; i >= l; ++l) {
                    var E = l / i * o * Math.PI * 2;
                    for (s(E, o, a, e, b), s(E + .01, o, a, e, w), M.subVectors(w, b), S.addVectors(w, b), T.crossVectors(M, S), S.crossVectors(T, M), T.normalize(), S.normalize(), c = 0; n >= c; ++c) {
                        var A = c / n * Math.PI * 2,
                            C = -t * Math.cos(A),
                            L = t * Math.sin(A);
                        y.x = b.x + (C * S.x + L * T.x), y.y = b.y + (C * S.y + L * T.y), y.z = b.z + (C * S.z + L * T.z), f.setXYZ(g, y.x, y.y, y.z), _.subVectors(y, b).normalize(), d.setXYZ(g, _.x, _.y, _.z), x.x = l / i, x.y = c / n, m.setXY(g, x.x, x.y), g++
                    }
                }
                for (c = 1; i >= c; c++)
                    for (l = 1; n >= l; l++) {
                        var P = (n + 1) * (c - 1) + (l - 1),
                            R = (n + 1) * c + (l - 1),
                            D = (n + 1) * c + l,
                            O = (n + 1) * (c - 1) + l;
                        p.setX(v, P), v++, p.setX(v, R), v++, p.setX(v, O), v++, p.setX(v, R), v++, p.setX(v, D), v++, p.setX(v, O), v++
                    }
                this.setIndex(p), this.addAttribute("position", f), this.addAttribute("normal", d), this.addAttribute("uv", m)
            }, r.TorusKnotBufferGeometry.prototype = Object.create(r.BufferGeometry.prototype), r.TorusKnotBufferGeometry.prototype.constructor = r.TorusKnotBufferGeometry, r.TorusKnotGeometry = function(e, t, i, n, o, a, s) {
                r.Geometry.call(this), this.type = "TorusKnotGeometry", this.parameters = {
                    radius: e,
                    tube: t,
                    tubularSegments: i,
                    radialSegments: n,
                    p: o,
                    q: a
                }, void 0 !== s && console.warn("THREE.TorusKnotGeometry: heightScale has been deprecated. Use .scale( x, y, z ) instead."), this.fromBufferGeometry(new r.TorusKnotBufferGeometry(e, t, i, n, o, a)), this.mergeVertices()
            }, r.TorusKnotGeometry.prototype = Object.create(r.Geometry.prototype), r.TorusKnotGeometry.prototype.constructor = r.TorusKnotGeometry, r.TubeGeometry = function(e, t, i, n, o, a) {
                function s(e, t, i) {
                    return P.vertices.push(new r.Vector3(e, t, i)) - 1
                }
                r.Geometry.call(this), this.type = "TubeGeometry", this.parameters = {
                    path: e,
                    segments: t,
                    radius: i,
                    radialSegments: n,
                    closed: o,
                    taper: a
                }, t = t || 64, i = i || 1, n = n || 8, o = o || !1, a = a || r.TubeGeometry.NoTaper;
                var l, c, h, u, p, f, d, m, g, v, y, _, x, b, w, T, M, S, E, A, C, L = [],
                    P = this,
                    R = t + 1,
                    D = new r.Vector3,
                    O = new r.TubeGeometry.FrenetFrames(e, t, o),
                    I = O.tangents,
                    F = O.normals,
                    N = O.binormals;
                for (this.tangents = I, this.normals = F, this.binormals = N, v = 0; R > v; v++)
                    for (L[v] = [], u = v / (R - 1), g = e.getPointAt(u), l = I[v], c = F[v], h = N[v], f = i * a(u), y = 0; n > y; y++) p = y / n * 2 * Math.PI, d = -f * Math.cos(p), m = f * Math.sin(p), D.copy(g), D.x += d * c.x + m * h.x, D.y += d * c.y + m * h.y, D.z += d * c.z + m * h.z, L[v][y] = s(D.x, D.y, D.z);
                for (v = 0; t > v; v++)
                    for (y = 0; n > y; y++) _ = o ? (v + 1) % t : v + 1, x = (y + 1) % n, b = L[v][y], w = L[_][y], T = L[_][x], M = L[v][x], S = new r.Vector2(v / t, y / n), E = new r.Vector2((v + 1) / t, y / n), A = new r.Vector2((v + 1) / t, (y + 1) / n), C = new r.Vector2(v / t, (y + 1) / n), this.faces.push(new r.Face3(b, w, M)), this.faceVertexUvs[0].push([S, E, C]), this.faces.push(new r.Face3(w, T, M)), this.faceVertexUvs[0].push([E.clone(), A, C.clone()]);
                this.computeFaceNormals(), this.computeVertexNormals()
            }, r.TubeGeometry.prototype = Object.create(r.Geometry.prototype), r.TubeGeometry.prototype.constructor = r.TubeGeometry, r.TubeGeometry.NoTaper = function(e) {
                return 1
            }, r.TubeGeometry.SinusoidalTaper = function(e) {
                return Math.sin(Math.PI * e)
            }, r.TubeGeometry.FrenetFrames = function(e, t, i) {
                function n() {
                    d[0] = new r.Vector3, m[0] = new r.Vector3, a = Number.MAX_VALUE, s = Math.abs(f[0].x), l = Math.abs(f[0].y), c = Math.abs(f[0].z), a >= s && (a = s, p.set(1, 0, 0)), a >= l && (a = l, p.set(0, 1, 0)), a >= c && p.set(0, 0, 1), g.crossVectors(f[0], p).normalize(), d[0].crossVectors(f[0], g), m[0].crossVectors(f[0], d[0])
                }
                var o, a, s, l, c, h, u, p = new r.Vector3,
                    f = [],
                    d = [],
                    m = [],
                    g = new r.Vector3,
                    v = new r.Matrix4,
                    y = t + 1;
                for (this.tangents = f, this.normals = d, this.binormals = m, h = 0; y > h; h++) u = h / (y - 1), f[h] = e.getTangentAt(u), f[h].normalize();
                for (n(), h = 1; y > h; h++) d[h] = d[h - 1].clone(), m[h] = m[h - 1].clone(), g.crossVectors(f[h - 1], f[h]), g.length() > Number.EPSILON && (g.normalize(), o = Math.acos(r.Math.clamp(f[h - 1].dot(f[h]), -1, 1)), d[h].applyMatrix4(v.makeRotationAxis(g, o))), m[h].crossVectors(f[h], d[h]);
                if (i)
                    for (o = Math.acos(r.Math.clamp(d[0].dot(d[y - 1]), -1, 1)), o /= y - 1, f[0].dot(g.crossVectors(d[0], d[y - 1])) > 0 && (o = -o), h = 1; y > h; h++) d[h].applyMatrix4(v.makeRotationAxis(f[h], o * h)), m[h].crossVectors(f[h], d[h])
            }, r.PolyhedronGeometry = function(e, t, i, n) {
                function o(e) {
                    var t = e.normalize().clone();
                    t.index = u.vertices.push(t) - 1;
                    var i = l(e) / 2 / Math.PI + .5,
                        n = c(e) / Math.PI + .5;
                    return t.uv = new r.Vector2(i, 1 - n), t
                }

                function a(e, t, i, n) {
                    var o = new r.Face3(e.index, t.index, i.index, [e.clone(), t.clone(), i.clone()], void 0, n);
                    u.faces.push(o), x.copy(e).add(t).add(i).divideScalar(3);
                    var a = l(x);
                    u.faceVertexUvs[0].push([h(e.uv, e, a), h(t.uv, t, a), h(i.uv, i, a)])
                }

                function s(e, t) {
                    for (var i = Math.pow(2, t), r = o(u.vertices[e.a]), n = o(u.vertices[e.b]), s = o(u.vertices[e.c]), l = [], c = e.materialIndex, h = 0; i >= h; h++) {
                        l[h] = [];
                        for (var p = o(r.clone().lerp(s, h / i)), f = o(n.clone().lerp(s, h / i)), d = i - h, m = 0; d >= m; m++) 0 === m && h === i ? l[h][m] = p : l[h][m] = o(p.clone().lerp(f, m / d))
                    }
                    for (var h = 0; i > h; h++)
                        for (var m = 0; 2 * (i - h) - 1 > m; m++) {
                            var g = Math.floor(m / 2);
                            m % 2 === 0 ? a(l[h][g + 1], l[h + 1][g], l[h][g], c) : a(l[h][g + 1], l[h + 1][g + 1], l[h + 1][g], c)
                        }
                }

                function l(e) {
                    return Math.atan2(e.z, -e.x)
                }

                function c(e) {
                    return Math.atan2(-e.y, Math.sqrt(e.x * e.x + e.z * e.z))
                }

                function h(e, t, i) {
                    return 0 > i && 1 === e.x && (e = new r.Vector2(e.x - 1, e.y)), 0 === t.x && 0 === t.z && (e = new r.Vector2(i / 2 / Math.PI + .5, e.y)), e.clone()
                }
                r.Geometry.call(this), this.type = "PolyhedronGeometry", this.parameters = {
                    vertices: e,
                    indices: t,
                    radius: i,
                    detail: n
                }, i = i || 1, n = n || 0;
                for (var u = this, p = 0, f = e.length; f > p; p += 3) o(new r.Vector3(e[p], e[p + 1], e[p + 2]));
                for (var d = this.vertices, m = [], p = 0, g = 0, f = t.length; f > p; p += 3, g++) {
                    var v = d[t[p]],
                        y = d[t[p + 1]],
                        _ = d[t[p + 2]];
                    m[g] = new r.Face3(v.index, y.index, _.index, [v.clone(), y.clone(), _.clone()], void 0, g)
                }
                for (var x = new r.Vector3, p = 0, f = m.length; f > p; p++) s(m[p], n);
                for (var p = 0, f = this.faceVertexUvs[0].length; f > p; p++) {
                    var b = this.faceVertexUvs[0][p],
                        w = b[0].x,
                        T = b[1].x,
                        M = b[2].x,
                        S = Math.max(w, T, M),
                        E = Math.min(w, T, M);
                    S > .9 && .1 > E && (.2 > w && (b[0].x += 1), .2 > T && (b[1].x += 1), .2 > M && (b[2].x += 1))
                }
                for (var p = 0, f = this.vertices.length; f > p; p++) this.vertices[p].multiplyScalar(i);
                this.mergeVertices(), this.computeFaceNormals(), this.boundingSphere = new r.Sphere(new r.Vector3, i)
            }, r.PolyhedronGeometry.prototype = Object.create(r.Geometry.prototype), r.PolyhedronGeometry.prototype.constructor = r.PolyhedronGeometry, r.DodecahedronGeometry = function(e, t) {
                var i = (1 + Math.sqrt(5)) / 2,
                    n = 1 / i,
                    o = [-1, -1, -1, -1, -1, 1, -1, 1, -1, -1, 1, 1, 1, -1, -1, 1, -1, 1, 1, 1, -1, 1, 1, 1, 0, -n, -i, 0, -n, i, 0, n, -i, 0, n, i, -n, -i, 0, -n, i, 0, n, -i, 0, n, i, 0, -i, 0, -n, i, 0, -n, -i, 0, n, i, 0, n],
                    a = [3, 11, 7, 3, 7, 15, 3, 15, 13, 7, 19, 17, 7, 17, 6, 7, 6, 15, 17, 4, 8, 17, 8, 10, 17, 10, 6, 8, 0, 16, 8, 16, 2, 8, 2, 10, 0, 12, 1, 0, 1, 18, 0, 18, 16, 6, 10, 2, 6, 2, 13, 6, 13, 15, 2, 16, 18, 2, 18, 3, 2, 3, 13, 18, 1, 9, 18, 9, 11, 18, 11, 3, 4, 14, 12, 4, 12, 0, 4, 0, 8, 11, 9, 5, 11, 5, 19, 11, 19, 7, 19, 5, 14, 19, 14, 4, 19, 4, 17, 1, 12, 14, 1, 14, 5, 1, 5, 9];
                r.PolyhedronGeometry.call(this, o, a, e, t), this.type = "DodecahedronGeometry", this.parameters = {
                    radius: e,
                    detail: t
                }
            }, r.DodecahedronGeometry.prototype = Object.create(r.PolyhedronGeometry.prototype), r.DodecahedronGeometry.prototype.constructor = r.DodecahedronGeometry, r.IcosahedronGeometry = function(e, t) {
                var i = (1 + Math.sqrt(5)) / 2,
                    n = [-1, i, 0, 1, i, 0, -1, -i, 0, 1, -i, 0, 0, -1, i, 0, 1, i, 0, -1, -i, 0, 1, -i, i, 0, -1, i, 0, 1, -i, 0, -1, -i, 0, 1],
                    o = [0, 11, 5, 0, 5, 1, 0, 1, 7, 0, 7, 10, 0, 10, 11, 1, 5, 9, 5, 11, 4, 11, 10, 2, 10, 7, 6, 7, 1, 8, 3, 9, 4, 3, 4, 2, 3, 2, 6, 3, 6, 8, 3, 8, 9, 4, 9, 5, 2, 4, 11, 6, 2, 10, 8, 6, 7, 9, 8, 1];
                r.PolyhedronGeometry.call(this, n, o, e, t), this.type = "IcosahedronGeometry", this.parameters = {
                    radius: e,
                    detail: t
                }
            }, r.IcosahedronGeometry.prototype = Object.create(r.PolyhedronGeometry.prototype), r.IcosahedronGeometry.prototype.constructor = r.IcosahedronGeometry, r.OctahedronGeometry = function(e, t) {
                var i = [1, 0, 0, -1, 0, 0, 0, 1, 0, 0, -1, 0, 0, 0, 1, 0, 0, -1],
                    n = [0, 2, 4, 0, 4, 3, 0, 3, 5, 0, 5, 2, 1, 2, 5, 1, 5, 3, 1, 3, 4, 1, 4, 2];
                r.PolyhedronGeometry.call(this, i, n, e, t), this.type = "OctahedronGeometry", this.parameters = {
                    radius: e,
                    detail: t
                }
            }, r.OctahedronGeometry.prototype = Object.create(r.PolyhedronGeometry.prototype), r.OctahedronGeometry.prototype.constructor = r.OctahedronGeometry, r.TetrahedronGeometry = function(e, t) {
                var i = [1, 1, 1, -1, -1, 1, -1, 1, -1, 1, -1, -1],
                    n = [2, 1, 0, 0, 3, 2, 1, 3, 0, 2, 3, 1];
                r.PolyhedronGeometry.call(this, i, n, e, t), this.type = "TetrahedronGeometry", this.parameters = {
                    radius: e,
                    detail: t
                }
            }, r.TetrahedronGeometry.prototype = Object.create(r.PolyhedronGeometry.prototype), r.TetrahedronGeometry.prototype.constructor = r.TetrahedronGeometry, r.ParametricGeometry = function(e, t, i) {
                r.Geometry.call(this), this.type = "ParametricGeometry", this.parameters = {
                    func: e,
                    slices: t,
                    stacks: i
                };
                var n, o, a, s, l, c = this.vertices,
                    h = this.faces,
                    u = this.faceVertexUvs[0],
                    p = t + 1;
                for (n = 0; i >= n; n++)
                    for (l = n / i, o = 0; t >= o; o++) s = o / t, a = e(s, l), c.push(a);
                var f, d, m, g, v, y, _, x;
                for (n = 0; i > n; n++)
                    for (o = 0; t > o; o++) f = n * p + o, d = n * p + o + 1, m = (n + 1) * p + o + 1, g = (n + 1) * p + o, v = new r.Vector2(o / t, n / i), y = new r.Vector2((o + 1) / t, n / i), _ = new r.Vector2((o + 1) / t, (n + 1) / i), x = new r.Vector2(o / t, (n + 1) / i), h.push(new r.Face3(f, d, g)), u.push([v, y, x]), h.push(new r.Face3(d, m, g)), u.push([y.clone(), _, x.clone()]);
                this.computeFaceNormals(), this.computeVertexNormals()
            }, r.ParametricGeometry.prototype = Object.create(r.Geometry.prototype), r.ParametricGeometry.prototype.constructor = r.ParametricGeometry, r.WireframeGeometry = function(e) {
                function t(e, t) {
                    return e - t
                }
                r.BufferGeometry.call(this);
                var i = [0, 0],
                    n = {},
                    o = ["a", "b", "c"];
                if (e instanceof r.Geometry) {
                    for (var a = e.vertices, s = e.faces, l = 0, c = new Uint32Array(6 * s.length), h = 0, u = s.length; u > h; h++)
                        for (var p = s[h], f = 0; 3 > f; f++) {
                            i[0] = p[o[f]], i[1] = p[o[(f + 1) % 3]], i.sort(t);
                            var d = i.toString();
                            void 0 === n[d] && (c[2 * l] = i[0], c[2 * l + 1] = i[1], n[d] = !0, l++)
                        }
                    for (var m = new Float32Array(2 * l * 3), h = 0, u = l; u > h; h++)
                        for (var f = 0; 2 > f; f++) {
                            var g = a[c[2 * h + f]],
                                v = 6 * h + 3 * f;
                            m[v + 0] = g.x, m[v + 1] = g.y, m[v + 2] = g.z
                        }
                    this.addAttribute("position", new r.BufferAttribute(m, 3))
                } else if (e instanceof r.BufferGeometry)
                    if (null !== e.index) {
                        var y = e.index.array,
                            a = e.attributes.position,
                            _ = e.groups,
                            l = 0;
                        0 === _.length && e.addGroup(0, y.length);
                        for (var c = new Uint32Array(2 * y.length), x = 0, b = _.length; b > x; ++x)
                            for (var w = _[x], T = w.start, M = w.count, h = T, S = T + M; S > h; h += 3)
                                for (var f = 0; 3 > f; f++) {
                                    i[0] = y[h + f], i[1] = y[h + (f + 1) % 3], i.sort(t);
                                    var d = i.toString();
                                    void 0 === n[d] && (c[2 * l] = i[0], c[2 * l + 1] = i[1], n[d] = !0, l++)
                                }
                        for (var m = new Float32Array(2 * l * 3), h = 0, u = l; u > h; h++)
                            for (var f = 0; 2 > f; f++) {
                                var v = 6 * h + 3 * f,
                                    E = c[2 * h + f];
                                m[v + 0] = a.getX(E), m[v + 1] = a.getY(E), m[v + 2] = a.getZ(E)
                            }
                        this.addAttribute("position", new r.BufferAttribute(m, 3))
                    } else {
                        for (var a = e.attributes.position.array, l = a.length / 3, A = l / 3, m = new Float32Array(2 * l * 3), h = 0, u = A; u > h; h++)
                            for (var f = 0; 3 > f; f++) {
                                var v = 18 * h + 6 * f,
                                    C = 9 * h + 3 * f;
                                m[v + 0] = a[C], m[v + 1] = a[C + 1], m[v + 2] = a[C + 2];
                                var E = 9 * h + 3 * ((f + 1) % 3);
                                m[v + 3] = a[E], m[v + 4] = a[E + 1], m[v + 5] = a[E + 2]
                            }
                        this.addAttribute("position", new r.BufferAttribute(m, 3))
                    }
            }, r.WireframeGeometry.prototype = Object.create(r.BufferGeometry.prototype), r.WireframeGeometry.prototype.constructor = r.WireframeGeometry, r.AxisHelper = function(e) {
                e = e || 1;
                var t = new Float32Array([0, 0, 0, e, 0, 0, 0, 0, 0, 0, e, 0, 0, 0, 0, 0, 0, e]),
                    i = new Float32Array([1, 0, 0, 1, .6, 0, 0, 1, 0, .6, 1, 0, 0, 0, 1, 0, .6, 1]),
                    n = new r.BufferGeometry;
                n.addAttribute("position", new r.BufferAttribute(t, 3)), n.addAttribute("color", new r.BufferAttribute(i, 3));
                var o = new r.LineBasicMaterial({
                    vertexColors: r.VertexColors
                });
                r.LineSegments.call(this, n, o)
            }, r.AxisHelper.prototype = Object.create(r.LineSegments.prototype), r.AxisHelper.prototype.constructor = r.AxisHelper, r.ArrowHelper = function() {
                var e = new r.Geometry;
                e.vertices.push(new r.Vector3(0, 0, 0), new r.Vector3(0, 1, 0));
                var t = new r.CylinderGeometry(0, .5, 1, 5, 1);
                return t.translate(0, -.5, 0),
                    function(i, n, o, a, s, l) {
                        r.Object3D.call(this), void 0 === a && (a = 16776960), void 0 === o && (o = 1), void 0 === s && (s = .2 * o), void 0 === l && (l = .2 * s), this.position.copy(n), this.line = new r.Line(e, new r.LineBasicMaterial({
                            color: a
                        })), this.line.matrixAutoUpdate = !1, this.add(this.line), this.cone = new r.Mesh(t, new r.MeshBasicMaterial({
                            color: a
                        })), this.cone.matrixAutoUpdate = !1, this.add(this.cone), this.setDirection(i), this.setLength(o, s, l)
                    }
            }(), r.ArrowHelper.prototype = Object.create(r.Object3D.prototype), r.ArrowHelper.prototype.constructor = r.ArrowHelper, r.ArrowHelper.prototype.setDirection = function() {
                var e, t = new r.Vector3;
                return function(i) {
                    i.y > .99999 ? this.quaternion.set(0, 0, 0, 1) : i.y < -.99999 ? this.quaternion.set(1, 0, 0, 0) : (t.set(i.z, 0, -i.x).normalize(), e = Math.acos(i.y), this.quaternion.setFromAxisAngle(t, e))
                }
            }(), r.ArrowHelper.prototype.setLength = function(e, t, i) {
                void 0 === t && (t = .2 * e), void 0 === i && (i = .2 * t), this.line.scale.set(1, Math.max(0, e - t), 1), this.line.updateMatrix(), this.cone.scale.set(i, t, i), this.cone.position.y = e, this.cone.updateMatrix()
            }, r.ArrowHelper.prototype.setColor = function(e) {
                this.line.material.color.set(e), this.cone.material.color.set(e)
            }, r.BoxHelper = function(e) {
                var t = new Uint16Array([0, 1, 1, 2, 2, 3, 3, 0, 4, 5, 5, 6, 6, 7, 7, 4, 0, 4, 1, 5, 2, 6, 3, 7]),
                    i = new Float32Array(24),
                    n = new r.BufferGeometry;
                n.setIndex(new r.BufferAttribute(t, 1)), n.addAttribute("position", new r.BufferAttribute(i, 3)), r.LineSegments.call(this, n, new r.LineBasicMaterial({
                    color: 16776960
                })), void 0 !== e && this.update(e)
            }, r.BoxHelper.prototype = Object.create(r.LineSegments.prototype), r.BoxHelper.prototype.constructor = r.BoxHelper, r.BoxHelper.prototype.update = function() {
                var e = new r.Box3;
                return function(t) {
                    if (e.setFromObject(t), !e.isEmpty()) {
                        var i = e.min,
                            r = e.max,
                            n = this.geometry.attributes.position,
                            o = n.array;
                        o[0] = r.x, o[1] = r.y, o[2] = r.z, o[3] = i.x, o[4] = r.y, o[5] = r.z, o[6] = i.x, o[7] = i.y, o[8] = r.z, o[9] = r.x, o[10] = i.y, o[11] = r.z, o[12] = r.x, o[13] = r.y, o[14] = i.z, o[15] = i.x, o[16] = r.y, o[17] = i.z, o[18] = i.x, o[19] = i.y, o[20] = i.z, o[21] = r.x, o[22] = i.y, o[23] = i.z, n.needsUpdate = !0, this.geometry.computeBoundingSphere()
                    }
                }
            }(), r.BoundingBoxHelper = function(e, t) {
                var i = void 0 !== t ? t : 8947848;
                this.object = e, this.box = new r.Box3, r.Mesh.call(this, new r.BoxGeometry(1, 1, 1), new r.MeshBasicMaterial({
                    color: i,
                    wireframe: !0
                }))
            }, r.BoundingBoxHelper.prototype = Object.create(r.Mesh.prototype), r.BoundingBoxHelper.prototype.constructor = r.BoundingBoxHelper, r.BoundingBoxHelper.prototype.update = function() {
                this.box.setFromObject(this.object), this.box.size(this.scale), this.box.center(this.position)
            }, r.CameraHelper = function(e) {
                function t(e, t, r) {
                    i(e, r), i(t, r)
                }

                function i(e, t) {
                    n.vertices.push(new r.Vector3), n.colors.push(new r.Color(t)), void 0 === a[e] && (a[e] = []), a[e].push(n.vertices.length - 1)
                }
                var n = new r.Geometry,
                    o = new r.LineBasicMaterial({
                        color: 16777215,
                        vertexColors: r.FaceColors
                    }),
                    a = {},
                    s = 16755200,
                    l = 16711680,
                    c = 43775,
                    h = 16777215,
                    u = 3355443;
                t("n1", "n2", s), t("n2", "n4", s), t("n4", "n3", s), t("n3", "n1", s), t("f1", "f2", s), t("f2", "f4", s), t("f4", "f3", s), t("f3", "f1", s), t("n1", "f1", s), t("n2", "f2", s), t("n3", "f3", s), t("n4", "f4", s), t("p", "n1", l), t("p", "n2", l), t("p", "n3", l), t("p", "n4", l), t("u1", "u2", c), t("u2", "u3", c), t("u3", "u1", c), t("c", "t", h), t("p", "c", u), t("cn1", "cn2", u), t("cn3", "cn4", u), t("cf1", "cf2", u), t("cf3", "cf4", u), r.LineSegments.call(this, n, o), this.camera = e, this.camera.updateProjectionMatrix(), this.matrix = e.matrixWorld, this.matrixAutoUpdate = !1, this.pointMap = a, this.update()
            }, r.CameraHelper.prototype = Object.create(r.LineSegments.prototype), r.CameraHelper.prototype.constructor = r.CameraHelper, r.CameraHelper.prototype.update = function() {
                function e(e, r, a, s) {
                    n.set(r, a, s).unproject(o);
                    var l = i[e];
                    if (void 0 !== l)
                        for (var c = 0, h = l.length; h > c; c++) t.vertices[l[c]].copy(n)
                }
                var t, i, n = new r.Vector3,
                    o = new r.Camera;
                return function() {
                    t = this.geometry, i = this.pointMap;
                    var r = 1,
                        n = 1;
                    o.projectionMatrix.copy(this.camera.projectionMatrix), e("c", 0, 0, -1), e("t", 0, 0, 1), e("n1", -r, -n, -1), e("n2", r, -n, -1), e("n3", -r, n, -1), e("n4", r, n, -1), e("f1", -r, -n, 1), e("f2", r, -n, 1), e("f3", -r, n, 1), e("f4", r, n, 1), e("u1", .7 * r, 1.1 * n, -1), e("u2", .7 * -r, 1.1 * n, -1), e("u3", 0, 2 * n, -1), e("cf1", -r, 0, 1), e("cf2", r, 0, 1), e("cf3", 0, -n, 1), e("cf4", 0, n, 1), e("cn1", -r, 0, -1), e("cn2", r, 0, -1), e("cn3", 0, -n, -1), e("cn4", 0, n, -1), t.verticesNeedUpdate = !0
                }
            }(), r.DirectionalLightHelper = function(e, t) {
                r.Object3D.call(this), this.light = e, this.light.updateMatrixWorld(), this.matrix = e.matrixWorld, this.matrixAutoUpdate = !1, t = t || 1;
                var i = new r.Geometry;
                i.vertices.push(new r.Vector3(-t, t, 0), new r.Vector3(t, t, 0), new r.Vector3(t, -t, 0), new r.Vector3(-t, -t, 0), new r.Vector3(-t, t, 0));
                var n = new r.LineBasicMaterial({
                    fog: !1
                });
                n.color.copy(this.light.color).multiplyScalar(this.light.intensity), this.lightPlane = new r.Line(i, n), this.add(this.lightPlane), i = new r.Geometry, i.vertices.push(new r.Vector3, new r.Vector3), n = new r.LineBasicMaterial({
                    fog: !1
                }), n.color.copy(this.light.color).multiplyScalar(this.light.intensity), this.targetLine = new r.Line(i, n), this.add(this.targetLine), this.update()
            }, r.DirectionalLightHelper.prototype = Object.create(r.Object3D.prototype), r.DirectionalLightHelper.prototype.constructor = r.DirectionalLightHelper, r.DirectionalLightHelper.prototype.dispose = function() {
                this.lightPlane.geometry.dispose(), this.lightPlane.material.dispose(), this.targetLine.geometry.dispose(), this.targetLine.material.dispose()
            }, r.DirectionalLightHelper.prototype.update = function() {
                var e = new r.Vector3,
                    t = new r.Vector3,
                    i = new r.Vector3;
                return function() {
                    e.setFromMatrixPosition(this.light.matrixWorld), t.setFromMatrixPosition(this.light.target.matrixWorld), i.subVectors(t, e), this.lightPlane.lookAt(i), this.lightPlane.material.color.copy(this.light.color).multiplyScalar(this.light.intensity), this.targetLine.geometry.vertices[1].copy(i), this.targetLine.geometry.verticesNeedUpdate = !0, this.targetLine.material.color.copy(this.lightPlane.material.color)
                }
            }(), r.EdgesHelper = function(e, t, i) {
                var n = void 0 !== t ? t : 16777215;
                r.LineSegments.call(this, new r.EdgesGeometry(e.geometry, i), new r.LineBasicMaterial({
                    color: n
                })), this.matrix = e.matrixWorld, this.matrixAutoUpdate = !1
            }, r.EdgesHelper.prototype = Object.create(r.LineSegments.prototype), r.EdgesHelper.prototype.constructor = r.EdgesHelper, r.FaceNormalsHelper = function(e, t, i, n) {
                this.object = e, this.size = void 0 !== t ? t : 1;
                var o = void 0 !== i ? i : 16776960,
                    a = void 0 !== n ? n : 1,
                    s = 0,
                    l = this.object.geometry;
                l instanceof r.Geometry ? s = l.faces.length : console.warn("THREE.FaceNormalsHelper: only THREE.Geometry is supported. Use THREE.VertexNormalsHelper, instead.");
                var c = new r.BufferGeometry,
                    h = new r.Float32Attribute(2 * s * 3, 3);
                c.addAttribute("position", h), r.LineSegments.call(this, c, new r.LineBasicMaterial({
                    color: o,
                    linewidth: a
                })), this.matrixAutoUpdate = !1, this.update()
            }, r.FaceNormalsHelper.prototype = Object.create(r.LineSegments.prototype), r.FaceNormalsHelper.prototype.constructor = r.FaceNormalsHelper, r.FaceNormalsHelper.prototype.update = function() {
                var e = new r.Vector3,
                    t = new r.Vector3,
                    i = new r.Matrix3;
                return function() {
                    this.object.updateMatrixWorld(!0), i.getNormalMatrix(this.object.matrixWorld);
                    for (var r = this.object.matrixWorld, n = this.geometry.attributes.position, o = this.object.geometry, a = o.vertices, s = o.faces, l = 0, c = 0, h = s.length; h > c; c++) {
                        var u = s[c],
                            p = u.normal;
                        e.copy(a[u.a]).add(a[u.b]).add(a[u.c]).divideScalar(3).applyMatrix4(r), t.copy(p).applyMatrix3(i).normalize().multiplyScalar(this.size).add(e), n.setXYZ(l, e.x, e.y, e.z), l += 1, n.setXYZ(l, t.x, t.y, t.z), l += 1
                    }
                    return n.needsUpdate = !0, this
                }
            }(), r.GridHelper = function(e, t) {
                var i = new r.Geometry,
                    n = new r.LineBasicMaterial({
                        vertexColors: r.VertexColors
                    });
                this.color1 = new r.Color(4473924), this.color2 = new r.Color(8947848);
                for (var o = -e; e >= o; o += t) {
                    i.vertices.push(new r.Vector3(-e, 0, o), new r.Vector3(e, 0, o), new r.Vector3(o, 0, -e), new r.Vector3(o, 0, e));
                    var a = 0 === o ? this.color1 : this.color2;
                    i.colors.push(a, a, a, a)
                }
                r.LineSegments.call(this, i, n)
            }, r.GridHelper.prototype = Object.create(r.LineSegments.prototype), r.GridHelper.prototype.constructor = r.GridHelper, r.GridHelper.prototype.setColors = function(e, t) {
                this.color1.set(e), this.color2.set(t), this.geometry.colorsNeedUpdate = !0
            }, r.HemisphereLightHelper = function(e, t) {
                r.Object3D.call(this), this.light = e, this.light.updateMatrixWorld(), this.matrix = e.matrixWorld, this.matrixAutoUpdate = !1, this.colors = [new r.Color, new r.Color];
                var i = new r.SphereGeometry(t, 4, 2);
                i.rotateX(-Math.PI / 2);
                for (var n = 0, o = 8; o > n; n++) i.faces[n].color = this.colors[4 > n ? 0 : 1];
                var a = new r.MeshBasicMaterial({
                    vertexColors: r.FaceColors,
                    wireframe: !0
                });
                this.lightSphere = new r.Mesh(i, a), this.add(this.lightSphere), this.update()
            }, r.HemisphereLightHelper.prototype = Object.create(r.Object3D.prototype), r.HemisphereLightHelper.prototype.constructor = r.HemisphereLightHelper, r.HemisphereLightHelper.prototype.dispose = function() {
                this.lightSphere.geometry.dispose(), this.lightSphere.material.dispose()
            }, r.HemisphereLightHelper.prototype.update = function() {
                var e = new r.Vector3;
                return function() {
                    this.colors[0].copy(this.light.color).multiplyScalar(this.light.intensity), this.colors[1].copy(this.light.groundColor).multiplyScalar(this.light.intensity), this.lightSphere.lookAt(e.setFromMatrixPosition(this.light.matrixWorld).negate()), this.lightSphere.geometry.colorsNeedUpdate = !0
                }
            }(), r.PointLightHelper = function(e, t) {
                this.light = e, this.light.updateMatrixWorld();
                var i = new r.SphereGeometry(t, 4, 2),
                    n = new r.MeshBasicMaterial({
                        wireframe: !0,
                        fog: !1
                    });
                n.color.copy(this.light.color).multiplyScalar(this.light.intensity), r.Mesh.call(this, i, n), this.matrix = this.light.matrixWorld, this.matrixAutoUpdate = !1
            }, r.PointLightHelper.prototype = Object.create(r.Mesh.prototype), r.PointLightHelper.prototype.constructor = r.PointLightHelper, r.PointLightHelper.prototype.dispose = function() {
                this.geometry.dispose(), this.material.dispose()
            }, r.PointLightHelper.prototype.update = function() {
                this.material.color.copy(this.light.color).multiplyScalar(this.light.intensity)
            }, r.SkeletonHelper = function(e) {
                this.bones = this.getBoneList(e);
                for (var t = new r.Geometry, i = 0; i < this.bones.length; i++) {
                    var n = this.bones[i];
                    n.parent instanceof r.Bone && (t.vertices.push(new r.Vector3), t.vertices.push(new r.Vector3), t.colors.push(new r.Color(0, 0, 1)), t.colors.push(new r.Color(0, 1, 0)))
                }
                t.dynamic = !0;
                var o = new r.LineBasicMaterial({
                    vertexColors: r.VertexColors,
                    depthTest: !1,
                    depthWrite: !1,
                    transparent: !0
                });
                r.LineSegments.call(this, t, o), this.root = e, this.matrix = e.matrixWorld, this.matrixAutoUpdate = !1, this.update()
            }, r.SkeletonHelper.prototype = Object.create(r.LineSegments.prototype), r.SkeletonHelper.prototype.constructor = r.SkeletonHelper, r.SkeletonHelper.prototype.getBoneList = function(e) {
                var t = [];
                e instanceof r.Bone && t.push(e);
                for (var i = 0; i < e.children.length; i++) t.push.apply(t, this.getBoneList(e.children[i]));
                return t
            }, r.SkeletonHelper.prototype.update = function() {
                for (var e = this.geometry, t = (new r.Matrix4).getInverse(this.root.matrixWorld), i = new r.Matrix4, n = 0, o = 0; o < this.bones.length; o++) {
                    var a = this.bones[o];
                    a.parent instanceof r.Bone && (i.multiplyMatrices(t, a.matrixWorld), e.vertices[n].setFromMatrixPosition(i), i.multiplyMatrices(t, a.parent.matrixWorld), e.vertices[n + 1].setFromMatrixPosition(i), n += 2)
                }
                e.verticesNeedUpdate = !0, e.computeBoundingSphere()
            }, r.SpotLightHelper = function(e) {
                r.Object3D.call(this), this.light = e, this.light.updateMatrixWorld(), this.matrix = e.matrixWorld, this.matrixAutoUpdate = !1;
                var t = new r.CylinderGeometry(0, 1, 1, 8, 1, !0);
                t.translate(0, -.5, 0), t.rotateX(-Math.PI / 2);
                var i = new r.MeshBasicMaterial({
                    wireframe: !0,
                    fog: !1
                });
                this.cone = new r.Mesh(t, i), this.add(this.cone), this.update()
            }, r.SpotLightHelper.prototype = Object.create(r.Object3D.prototype), r.SpotLightHelper.prototype.constructor = r.SpotLightHelper, r.SpotLightHelper.prototype.dispose = function() {
                this.cone.geometry.dispose(), this.cone.material.dispose()
            }, r.SpotLightHelper.prototype.update = function() {
                var e = new r.Vector3,
                    t = new r.Vector3;
                return function() {
                    var i = this.light.distance ? this.light.distance : 1e4,
                        r = i * Math.tan(this.light.angle);
                    this.cone.scale.set(r, r, i), e.setFromMatrixPosition(this.light.matrixWorld), t.setFromMatrixPosition(this.light.target.matrixWorld), this.cone.lookAt(t.sub(e)), this.cone.material.color.copy(this.light.color).multiplyScalar(this.light.intensity)
                }
            }(), r.VertexNormalsHelper = function(e, t, i, n) {
                this.object = e, this.size = void 0 !== t ? t : 1;
                var o = void 0 !== i ? i : 16711680,
                    a = void 0 !== n ? n : 1,
                    s = 0,
                    l = this.object.geometry;
                l instanceof r.Geometry ? s = 3 * l.faces.length : l instanceof r.BufferGeometry && (s = l.attributes.normal.count);
                var c = new r.BufferGeometry,
                    h = new r.Float32Attribute(2 * s * 3, 3);
                c.addAttribute("position", h), r.LineSegments.call(this, c, new r.LineBasicMaterial({
                    color: o,
                    linewidth: a
                })), this.matrixAutoUpdate = !1, this.update()
            }, r.VertexNormalsHelper.prototype = Object.create(r.LineSegments.prototype), r.VertexNormalsHelper.prototype.constructor = r.VertexNormalsHelper, r.VertexNormalsHelper.prototype.update = function() {
                var e = new r.Vector3,
                    t = new r.Vector3,
                    i = new r.Matrix3;
                return function() {
                    var n = ["a", "b", "c"];
                    this.object.updateMatrixWorld(!0), i.getNormalMatrix(this.object.matrixWorld);
                    var o = this.object.matrixWorld,
                        a = this.geometry.attributes.position,
                        s = this.object.geometry;
                    if (s instanceof r.Geometry)
                        for (var l = s.vertices, c = s.faces, h = 0, u = 0, p = c.length; p > u; u++)
                            for (var f = c[u], d = 0, m = f.vertexNormals.length; m > d; d++) {
                                var g = l[f[n[d]]],
                                    v = f.vertexNormals[d];
                                e.copy(g).applyMatrix4(o), t.copy(v).applyMatrix3(i).normalize().multiplyScalar(this.size).add(e), a.setXYZ(h, e.x, e.y, e.z), h += 1, a.setXYZ(h, t.x, t.y, t.z), h += 1
                            } else if (s instanceof r.BufferGeometry)
                                for (var y = s.attributes.position, _ = s.attributes.normal, h = 0, d = 0, m = y.count; m > d; d++) e.set(y.getX(d), y.getY(d), y.getZ(d)).applyMatrix4(o), t.set(_.getX(d), _.getY(d), _.getZ(d)), t.applyMatrix3(i).normalize().multiplyScalar(this.size).add(e), a.setXYZ(h, e.x, e.y, e.z), h += 1, a.setXYZ(h, t.x, t.y, t.z), h += 1;
                    return a.needsUpdate = !0, this
                }
            }(), r.WireframeHelper = function(e, t) {
                var i = void 0 !== t ? t : 16777215;
                r.LineSegments.call(this, new r.WireframeGeometry(e.geometry), new r.LineBasicMaterial({
                    color: i
                })), this.matrix = e.matrixWorld, this.matrixAutoUpdate = !1
            }, r.WireframeHelper.prototype = Object.create(r.LineSegments.prototype), r.WireframeHelper.prototype.constructor = r.WireframeHelper, r.ImmediateRenderObject = function(e) {
                r.Object3D.call(this), this.material = e, this.render = function(e) {}
            }, r.ImmediateRenderObject.prototype = Object.create(r.Object3D.prototype), r.ImmediateRenderObject.prototype.constructor = r.ImmediateRenderObject, r.MorphBlendMesh = function(e, t) {
                r.Mesh.call(this, e, t), this.animationsMap = {}, this.animationsList = [];
                var i = this.geometry.morphTargets.length,
                    n = "__default",
                    o = 0,
                    a = i - 1,
                    s = i / 1;
                this.createAnimation(n, o, a, s), this.setAnimationWeight(n, 1)
            }, r.MorphBlendMesh.prototype = Object.create(r.Mesh.prototype), r.MorphBlendMesh.prototype.constructor = r.MorphBlendMesh, r.MorphBlendMesh.prototype.createAnimation = function(e, t, i, r) {
                var n = {
                    start: t,
                    end: i,
                    length: i - t + 1,
                    fps: r,
                    duration: (i - t) / r,
                    lastFrame: 0,
                    currentFrame: 0,
                    active: !1,
                    time: 0,
                    direction: 1,
                    weight: 1,
                    directionBackwards: !1,
                    mirroredLoop: !1
                };
                this.animationsMap[e] = n, this.animationsList.push(n)
            }, r.MorphBlendMesh.prototype.autoCreateAnimations = function(e) {
                for (var t, i = /([a-z]+)_?(\d+)/i, r = {}, n = this.geometry, o = 0, a = n.morphTargets.length; a > o; o++) {
                    var s = n.morphTargets[o],
                        l = s.name.match(i);
                    if (l && l.length > 1) {
                        var c = l[1];
                        r[c] || (r[c] = {
                            start: 1 / 0,
                            end: -(1 / 0)
                        });
                        var h = r[c];
                        o < h.start && (h.start = o), o > h.end && (h.end = o), t || (t = c)
                    }
                }
                for (var c in r) {
                    var h = r[c];
                    this.createAnimation(c, h.start, h.end, e)
                }
                this.firstAnimation = t
            }, r.MorphBlendMesh.prototype.setAnimationDirectionForward = function(e) {
                var t = this.animationsMap[e];
                t && (t.direction = 1, t.directionBackwards = !1)
            }, r.MorphBlendMesh.prototype.setAnimationDirectionBackward = function(e) {
                var t = this.animationsMap[e];
                t && (t.direction = -1, t.directionBackwards = !0)
            }, r.MorphBlendMesh.prototype.setAnimationFPS = function(e, t) {
                var i = this.animationsMap[e];
                i && (i.fps = t, i.duration = (i.end - i.start) / i.fps)
            }, r.MorphBlendMesh.prototype.setAnimationDuration = function(e, t) {
                var i = this.animationsMap[e];
                i && (i.duration = t, i.fps = (i.end - i.start) / i.duration)
            }, r.MorphBlendMesh.prototype.setAnimationWeight = function(e, t) {
                var i = this.animationsMap[e];
                i && (i.weight = t)
            }, r.MorphBlendMesh.prototype.setAnimationTime = function(e, t) {
                var i = this.animationsMap[e];
                i && (i.time = t)
            }, r.MorphBlendMesh.prototype.getAnimationTime = function(e) {
                var t = 0,
                    i = this.animationsMap[e];
                return i && (t = i.time), t
            }, r.MorphBlendMesh.prototype.getAnimationDuration = function(e) {
                var t = -1,
                    i = this.animationsMap[e];
                return i && (t = i.duration), t
            }, r.MorphBlendMesh.prototype.playAnimation = function(e) {
                var t = this.animationsMap[e];
                t ? (t.time = 0, t.active = !0) : console.warn("THREE.MorphBlendMesh: animation[" + e + "] undefined in .playAnimation()")
            }, r.MorphBlendMesh.prototype.stopAnimation = function(e) {
                var t = this.animationsMap[e];
                t && (t.active = !1)
            }, r.MorphBlendMesh.prototype.update = function(e) {
                for (var t = 0, i = this.animationsList.length; i > t; t++) {
                    var n = this.animationsList[t];
                    if (n.active) {
                        var o = n.duration / n.length;
                        n.time += n.direction * e, n.mirroredLoop ? (n.time > n.duration || n.time < 0) && (n.direction *= -1, n.time > n.duration && (n.time = n.duration, n.directionBackwards = !0), n.time < 0 && (n.time = 0, n.directionBackwards = !1)) : (n.time = n.time % n.duration, n.time < 0 && (n.time += n.duration));
                        var a = n.start + r.Math.clamp(Math.floor(n.time / o), 0, n.length - 1),
                            s = n.weight;
                        a !== n.currentFrame && (this.morphTargetInfluences[n.lastFrame] = 0, this.morphTargetInfluences[n.currentFrame] = 1 * s, this.morphTargetInfluences[a] = 0, n.lastFrame = n.currentFrame, n.currentFrame = a);
                        var l = n.time % o / o;
                        n.directionBackwards && (l = 1 - l), n.currentFrame !== n.lastFrame ? (this.morphTargetInfluences[n.currentFrame] = l * s, this.morphTargetInfluences[n.lastFrame] = (1 - l) * s) : this.morphTargetInfluences[n.currentFrame] = s
                    }
                }
            }, "undefined" != typeof i ? ("undefined" != typeof t && t.exports && (i = t.exports = r), i.THREE = r) : this.THREE = r
    }, {}],
    8: [function(e, t, i) {
        "use strict";
        var r = e("jquery"),
            n = e("scrollmagic");
        e("gsap");
        var o = function() {
            function e() {
                r(".Slide").each(function() {
                    function e() {
                        i.hasClass("bg--dark") ? r(".Header").addClass("onDark") : r(".Header").removeClass("onDark")
                    }
                    var i = r(this);
                    new n.Scene({
                        triggerElement: this,
                        triggerHook: "onLeave",
                        duration: this.clientHeight
                    }).on("progress", function(t) {
                        e()
                    }).addTo(t)
                })
            }
            var t = new n.Controller;
            e()
        };
        t.exports = o
    }, {
        gsap: 1,
        jquery: 4,
        scrollmagic: 5
    }],
    9: [function(e, t, i) {
        "use strict";
        var r = (e("jquery"), e("three")),
            n = e("gsap"),
            o = function() {
                function e() {
                    var e, o, s, x, b;
                    l = document.querySelector(".Hero-canvas"), document.body.appendChild(l), c = new r.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 1, 2e3), c.position.z = 1200, h = new r.Scene, h.fog = new r.FogExp2(0, 8e-4), f = new r.Geometry;
                    var w = new r.TextureLoader;
                    for (e = w.load("images/sprite1.png"), o = w.load("images/sprite1.png"), s = w.load("images/sprite1.png"), x = w.load("images/sprite1.png"), b = w.load("images/sprite1.png"), m = 0; M > m; m++) {
                        var T = new r.Vector3;
                        T.x = 0, T.y = 0, T.z = 0, f.vertices.push(T)
                    }
                    for (d = [
                            [
                                [.8, .79, 1], o, 10
                            ],
                            [
                                [.8, .79, 1], s, 10
                            ],
                            [
                                [.8, .79, 1], e, 10
                            ],
                            [
                                [.8, .79, 1], b, 10
                            ],
                            [
                                [.8, .79, 1], x, 10
                            ]
                        ], m = 0; m < d.length; m++) g = d[m][0], v = d[m][1], y = d[m][2], _[m] = new r.PointsMaterial({
                        size: y,
                        map: v,
                        depthTest: !1,
                        transparent: !0
                    }), _[m].color.setHSL(g[0], g[1], g[2]), p = new r.Points(f, _[m]), p.rotation.x = .01 * Math.random(), p.rotation.y = .01 * Math.random(), p.rotation.z = .01 * Math.random(), h.add(p);
                    for (m = 0; M > m; m++) n.fromTo(f.vertices[m], 2, {
                        x: 0,
                        y: 0,
                        z: 0
                    }, {
                        y: 2e3 * Math.random() - 1e3,
                        x: 2e3 * Math.random() - 1e3,
                        z: 2e3 * Math.random() - 1e3,
                        ease: Power4.easeOut
                    });
                    a(), u = new r.WebGLRenderer, u.setPixelRatio(window.devicePixelRatio), u.setSize(window.innerWidth, window.innerHeight), l.appendChild(u.domElement), document.addEventListener("mousemove", i, !1), window.addEventListener("resize", t, !1)
                }

                function t() {
                    w = window.innerWidth / 2, T = window.innerHeight / 2, c.aspect = window.innerWidth / window.innerHeight, c.updateProjectionMatrix(), u.setSize(window.innerWidth, window.innerHeight)
                }

                function i(e) {
                    x = e.clientX - w, b = e.clientY - T
                }

                function o() {
                    requestAnimationFrame(o), s()
                }

                function a() {
                    (S = !0) && (f.verticesNeedUpdate = !0, requestAnimationFrame(a))
                }

                function s() {
                    var e = 5e-5 * Date.now();
                    for (c.position.y += .005 * (-b - c.position.y), c.lookAt(h.position), m = 0; m < h.children.length; m++) {
                        var t = h.children[m];
                        t instanceof r.Points && (t.rotation.y = e * (4 > m ? m + 1 : -(m + 1)) * .2)
                    }
                    u.render(h, c)
                }
                var l, c, h, u, p, f, d, m, g, v, y, _ = [],
                    x = 0,
                    b = 0,
                    w = window.innerWidth / 2,
                    T = window.innerHeight / 2,
                    M = 150,
                    S = !1;
                this.init = function() {
                    var t = new TimelineMax;
                    t.fromTo(".loading-bar", 1, {
                        scaleX: 0
                    }, {
                        scaleX: 1
                    }).fromTo(".loading-bar", .4, {
                        opacity: 1
                    }, {
                        opacity: 0
                    }).fromTo(".loading", 1, {
                        opacity: 1,
                        display: "block"
                    }, {
                        opacity: 0,
                        display: "none"
                    }, "-=.4"), setTimeout(function() {
                        e(), o();
                        var t = new TimelineMax;
                        t.fromTo(".Hero-wrapper", 1.4, {
                            scale: 0,
                            opacity: 0
                        }, {
                            scale: 1,
                            opacity: 1,
                            ease: Power4.easeOut
                        }).fromTo(".Hero-claim", .5, {
                            opacity: 0
                        }, {
                            opacity: 1
                        }, .8)
                    }, 800)
                }
            };
        t.exports = o
    }, {
        gsap: 1,
        jquery: 4,
        three: 7
    }],
    10: [function(e, t, i) {
        "use strict";

        function r(e, t) {
            return e / t * 100
        }
        var n = e("jquery");
        e("gsap"), e("hammerjs");
        var o = function() {
            function e() {
                u = u + 1 > p - 1 ? 0 : u + 1, i("forward")
            }

            function t() {
                u = 0 > u - 1 ? p : u - 1, i("back")
            }

            function i(e) {
                console.log("moving with index %s", u), TweenMax.to(".Skills-slider", .4, {
                    x: 100 * -u + "%"
                }), o()
            }

            function o() {
                n(".Skills-slide").each(function() {
                    a(n(this))
                })
            }

            function a(e) {
                return e.hasClass("is-open") ? (e.removeClass("is-open"), void d[e.index()].reverse()) : !0
            }

            function s(e) {
                var t = e.index();
                e.hasClass("is-open") ? (console.log("ciaone proprio"), d[t].reverse()) : d[t].play(), e.toggleClass("is-open")
            }

            function l() {
                n(".Skills-slide").each(function(e) {
                    var t = new TimelineMax,
                        i = n(this),
                        r = i.find(".Icon-copy"),
                        o = i.find(".Icon-letter"),
                        a = i.find(".Icon-logo"),
                        s = n(".Hero-canvas");
                    f && n(".Skills-control").addClass("hidden"), t.set(r, {
                        display: "block"
                    }).fromTo(o, .4, {
                        scale: 1
                    }, {
                        scale: 0,
                        ease: Power2.easeInOut
                    }), f ? t.fromTo(a, .6, {
                        width: 216,
                        height: 216,
                        zIndex: 2,
                        position: "absolute",
                        backgroundColor: "rgba(0,0,0,0)"
                    }, {
                        width: window.innerWidth,
                        height: window.innerHeight,
                        backgroundColor: "rgba(0,0,0,1)",
                        zIndex: 100,
                        position: "fixed",
                        ease: Power4.easeInOut
                    }).to(a, .6, {
                        borderWidth: 0
                    }, "-=.6") : t.fromTo(a, .6, {
                        width: 216,
                        height: 216,
                        zIndex: 2,
                        backgroundColor: "rgba(0,0,0,0)"
                    }, {
                        width: f ? window.innerWidth - 32 : 500,
                        height: f ? 420 : 500,
                        backgroundColor: f ? "rgba(0,0,0,1)" : "rgba(0,0,0,0)",
                        zIndex: 100,
                        ease: Power4.easeInOut
                    }, 0), t.fromTo(s, .6, {
                        scale: 1
                    }, {
                        scale: 1.4,
                        ease: Power4.easeInOut
                    }, 0).staggerFromTo(r.find("li"), .5, {
                        opacity: 0,
                        scale: 0
                    }, {
                        opacity: 1,
                        scale: 1,
                        ease: Power4.easeOut
                    }, .05, "-=.2"), t.pause(0), d.push(t)
                })
            }

            function c() {
                n(".Skills-control").on("click", function() {
                    "forward" == n(this).attr("data-nav") ? e() : t()
                }), n(".Skills-slide").on("mouseup", function() {
                    s(n(this))
                });
                var o = document.querySelector(".Skills-slider"),
                    a = 5 * o.clientWidth,
                    l = new Hammer(o),
                    c = window.innerWidth;
                console.warn("slider width: %spx", a), console.warn("slider timeline duration %ss", m.duration()), l.on("pan", function(e) {
                    var t = (e.deltaX > 0 ? 1 : -1, Math.abs(e.deltaX));
                    r(t, a), r(t, c);
                    console.log(-u * (a / 5) - e.deltaX + "px"), TweenMax.set(".Skills-slider", {
                        x: e.deltaX + "px"
                    })
                }), l.on("panend", function(n) {
                    var o = n.deltaX > 0 ? 1 : -1,
                        s = Math.abs(n.deltaX),
                        l = (r(s, a), r(s, c));
                    console.warn("panned for %ipx, %i% of viewport, %i% of slider", s * o, l, r(s, a)), s > 100 ? 0 > o ? e() : 0 == u ? i() : t() : i()
                })
            }

            function h() {
                c(), l()
            }
            this.name = "slide";
            var u = 0,
                p = document.querySelectorAll(".Skills-slide").length,
                f = window.innerWidth < 600,
                d = [],
                m = new TimelineMax;
            h()
        };
        t.exports = o
    }, {
        gsap: 1,
        hammerjs: 3,
        jquery: 4
    }],
    11: [function(e, t, i) {
        "use strict";
        var r = e("jquery"),
            n = e("scrollmagic");
        e("gsap"), e("node_modules/scrollmagic/scrollmagic/uncompressed/plugins/animation.gsap.js"), e("node_modules/scrollmagic/scrollmagic/uncompressed/plugins/animation.gsap.js"), e("node_modules/gsap/src/uncompressed/plugins/AttrPlugin.js");
        var o = function() {
            if (r(window).width() < 1025) return !1;
            var e, t = new n.Controller,
                i = [],
                o = new TimelineMax({
                    onStart: function() {
                        e = 0
                    }
                }).staggerFromTo(".sec-icon", .3, {
                    scale: 0
                }, {
                    scale: 1
                }, .3).staggerFromTo(".sec-content", .4, {
                    y: 100,
                    opacity: 0,
                    ease: Power3.easeOut
                }, {
                    y: 0,
                    opacity: 1
                }, .05),
                a = new n.Scene({
                    triggerElement: ".sec",
                    triggerHook: "onEnter",
                    reverse: !1
                }).setTween(o);
            a.addTo(t)
        };
        t.exports = o
    }, {
        "node_modules/gsap/src/uncompressed/plugins/AttrPlugin.js": 2,
        "node_modules/scrollmagic/scrollmagic/uncompressed/plugins/animation.gsap.js": 6,
        gsap: 1,
        jquery: 4,
        scrollmagic: 5
    }],
    12: [function(e, t, i) {
        "use strict";
        var r = (e("jquery"), e("scrollmagic"), function() {});
        t.exports = r
    }, {
        jquery: 4,
        scrollmagic: 5
    }],
    13: [function(e, t, i) {
        "use strict";
        var r = e("jquery"),
            n = e("modules/header"),
            o = e("modules/hero"),
            a = e("modules/slide"),
            s = e("modules/sec"),
            l = e("modules/welcome");
        e("gsap");
        r(function() {
            new n, new a, (new o).init(), new s, new l;
            var e = function() {
                var e = document.createElement("div");
                e.style.visibility = "hidden", e.style.width = "100px", e.style.msOverflowStyle = "scrollbar", document.body.appendChild(e);
                var t = e.offsetWidth;
                e.style.overflow = "scroll";
                var i = document.createElement("div");
                i.style.width = "100%", e.appendChild(i);
                var r = i.offsetWidth;
                return e.parentNode.removeChild(e), t - r
            }();
            r(".openPrivacyPolicy").on("click", function() {
                (new TimelineMax).set("html", {
                    overflowY: "hidden",
                    "margin-right": e
                }).fromTo(".Privacy", .4, {
                    display: "none",
                    y: "100%"
                }, {
                    display: "block",
                    y: "0%"
                }).fromTo(".Privacy-wrapper", .4, {
                    opacity: 0,
                    y: 100,
                    display: "none"
                }, {
                    opacity: 1,
                    y: 0,
                    display: "block"
                }).fromTo(".Privacy-close", .3, {
                    y: -100,
                    display: "none"
                }, {
                    y: 0,
                    display: "block"
                }), r(".Privacy-close").on("click", function() {
                    (new TimelineMax).to(".Privacy-close", .3, {
                        y: -100
                    }).to(".Privacy", .4, {
                        y: "100%"
                    }).set(".Privacy", {
                        display: "none"
                    }).set("html", {
                        overflowY: "scroll",
                        "margin-right": 0
                    })
                })
            })
        })
    }, {
        "modules/header": 8,
        "modules/hero": 9,
        "modules/slide": 10,
        "modules/sec": 11,
        "modules/welcome": 12,
        gsap: 1,
        jquery: 4
    }]
}, {}, [13]);
//# sourceMappingURL=main.js.map